# Mox rocks

## Objectives
- introduction to mock based tests
- fix configuration
- add the Mox package
- define behaviour

## Introduction to mock based tests

In the previous chapter, we've implemented the end-to-end test. It required a lot of prep work as well as we were able to see the downsides of this type of test clearly:

- we will be unable to run more than one end-to-end test in parallel as they rely on the database's state
- we need to set up the database before every test run
- we need to start processes in the correct order with the suitable parameters
- we needed to wait a (guessed) hardcoded amount of time that it will take to finish the trading(this is extremely bad as it will cause randomly failing tests as people will make the time shorter to speed up tests)
- we wouldn't be able to quickly pinpoint which part error originated from as the test spans over a vast amount of the system
- logging was polluting our test output

How could we fix the above issues?

The most common way is to limit the scope of the test. Instead of testing the whole trading flow, we could focus on testing a single `Naive.Trader` process.

Focusing on a single trader process would remove the requirement for starting multiple processes before testing, but it would also bring its own challenges.

Let's look at a concrete example:

When the `Naive.Trader` process starts, it subscribes to the `TRADE_EVENTS:#{symbol}` PubSub topic. It also broadcasts updates of the orders it's placed to the `ORDERS:#{symbol}` PubSub topic.

How could we break the link between the `Naive.Trader` and the PubSub(or any other module it depends on)?

We could utilize the trick that we used for the `Binance` module. We could create a module that provides the same functions as the `PubSub` module.

We know that the trader process calls `Phoenix.PubSub.subscribe/2` and `Phoenix.PubSub.broadcast/3` functions. We could implement a module that contains the same functions:

```{r, engine = 'elixir', eval = FALSE}
defmodule Test.PubSub do
    def subscribe(_, _), do: :ok
    def broadcast(_, _, _), do: :ok
end
```

The above module would satisfy the PubSub's functionality required by the `Naive.Trader` module, but this solution comes with a couple of drawbacks:

- it doesn't validate incoming arguments. It just ignores them, which is a missed opportunity to confirm that the PubSub module was called with the expected values.
- we cannot define the results of calling the above functions specific to test, for example, if the first argument is `true` return `false`, otherwise `true`.

Using the `mox` module would fix both of the problems mentioned above. With the `mox` module we can define add-hoc function implemention per test:

```{r, engine = 'elixir', eval = FALSE}
    # inside test file
    test ...
        Test.PubSubMock
        |> expect(:subscribe, fn (_module, "TRADE_EVENTS:XRPUSDT") -> :ok end)
        |> expect(:broadcast, fn (_module, "ORDERS:XRPUSDT", _order) -> :ok end)
```

There are multiple benefits to using the `mox` module instead of handcrafting the implementation:

- it allows defining functions that will pattern match values specific to each test(as in the case of the "usual" pattern matching, they will break when called with unexpected values)
- it allows defining implementations of the mocked functions based on incoming(test specific) values
- it can validate that all defined mocked functions have been called when the test was run
- it comes with its own tests, so we don't need to test it as it would need with our custom handcrafted mimicking module implementation

But there's a catch* ;)

For the `mox` to know what sort of functions the module provides, it needs to know its `behaviour`.

In Elixir, to define a behaviour of the module, we need to add the `@callback` attributes to it:

```{r, engine = 'elixir', eval = FALSE}
  defmodule Core.Test.PubSub do
    @type t :: atom
    @type topic :: binary
    @type message :: term

    @callback subscribe(t, topic) :: :ok | {:error, term}
    @callback broadcast(t, topic, message) :: :ok | {:error, term}
  end
```

A `behaviour` can be defined in a separate module if we are working with 3rd party module that doesn't provide it(like in the case of the `Phoenix.PubSub` module).

Note: The additional benefit of using the `behaviours` is that we could tell Elixir that our module *implements* the behaviour by adding the `@behaviour` attribute:

```{r, engine = 'elixir', eval = FALSE}
def MyPubSub do
    @behaviour Core.Test.PubSub
    ...
```

Using the above will cause Elixir to validate at compile time that the `MyPubSub` module implements all functions defined inside the `Core.Test.PubSub` module(or it will cause compilation error).

Back to the main topic. We figured out that we could mock all of the modules that the `Naive.Trader` depends on using the `mox` module. 

But, how would we tell the `Naive.Trader` to use the mocked modules instead of the "real" ones when we run tests?

We could make all modules that the `Naive.Trader` depends on be dynamically injected from the configuration(based on the environment).

The second requirement to make `mox` work is to define the mocks upfront using the `Mox.defmock/2` function. It will dynamically define a new module(first value) that will be limited by the passed behaviour(we will only be able to mock[inside tests] functions defined as a part of that behaviour). 

To sum up, there are a few steps to get the `mox` running:

- implement behaviours that we would like to mock(as most of the packages[like `Phoenix.PubSub`] are not coming with those)
- define mock module using the `Mox.defmock` function
- modify the application's configuration to use the mocked module(s)
- specify mocked module's expectation inside the test

Let's move to the implementation.

## Add the `mox` package

First let's add the `mox` package to the `naive` application's dependencies:

```{r, engine = 'elixir', eval = FALSE}
# /apps/naive/mix.exs
  ...
  defp deps do
    [
      ...
      {:mox, "~> 1.0", only: :test},
      ...
```

We can now run `mix deps.get` to fetch the `mox` package.

## Define behavior

Before we will be able to call `Mox.defmock` function, we need to implement a behavior that needs to be passed to it.

As the `binance` module doesn't provide a behaviour, we need to create a new module where we will specify it based on the `binance`'s current implemention. Let's start by creating a new file called `test.ex` inside the `/apps/binance_mock/lib/binance_mock` directory and fill it with the following:

```{r, engine = 'elixir', eval = FALSE}
# /apps/naive/mix.exs
  ...
  defp deps do
    [
      ...
      {:mox, "~> 1.0", only: :test},
      ...
```


[Note] Please remember to run the `mix format` to keep things nice and tidy.

Source code for this chapter can be found at [Github](https://github.com/frathon/create-a-cryptocurrency-trading-bot-in-elixir-source-code/tree/chapter_17)
