--- 
title: "Práctica con Elixir y OTP: Bot de Comercio de Criptomonedas"
author: "Kamil Skowron"
date: "0.5.1"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
link-citations: yes
github-repo: Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot
description: ""
graphics: yes
nocite: '@*'
classoption: oneside
geometry: "left=3cm, right=3cm, top=2.5cm, bottom=2.5cm"
twitter-handle: kamilskowron
monofont: Consolas.ttf
---

# Prefacio {-}

### ¿Quieres aprender Elixir y OTP creando un proyecto real? {-}

<img src="images/cover.png" width="250" height="324" alt="The book cover" align="right" style="margin: 0 1em 0 1em"/>

Con "Práctica con Elixir y OTP: Bot de Comercio de Criptomonedas", **ganarás experiencia práctica escribiendo un emocionante proyecto de software desde cero.** Exploraremos todas las abstracciones clave y principios esenciales a través de mejoras iterativas en la implementación.

Comenzaremos creando una nueva aplicación paraguas, suscribiéndonos a flujos WebSocket, implementando un flujo de comercio básico y centrándonos en mejorarlo expandiendo temas como árboles de supervisión, resiliencia, refactorización usando macros, utilizando el Registro, pruebas y otros.

**Este libro está completado en un 93% - los capítulos 1-21 están terminados,** y pronto añadiré más contenido. También es una representación escrita y poco rigurosa del curso en video [Práctica con Elixir y OTP: Bot de Comercio de Criptomonedas](https://www.youtube.com/watch?v=wVYIx7M6o28&list=PLxsE19GnjC5Nv1CbeKOiS5YqGqw35aZFJ) publicado en YouTube.

Esta obra está licenciada bajo la licencia Creative Commons Atribución-NoComercial-CompartirIgual 4.0 Internacional [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/).

**Para recibir notificaciones sobre actualizaciones** de este libro, simplemente "vigila" el [repositorio del código fuente](https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot) y no olvides dejar una estrella:

```{r, fig.align="center", out.width="60%", echo=FALSE}
knitr::include_graphics("images/watch_book_howto.png")
```

\newpage

## Límite de Responsabilidad/Descargo de Garantía {-}

**ESTE LIBRO NO ES ASESORAMIENTO FINANCIERO**

EL SOFTWARE/LIBRO SE PROPORCIONA "TAL CUAL", SIN GARANTÍA DE NINGÚN TIPO, EXPRESA O IMPLÍCITA, INCLUYENDO PERO NO LIMITADO A LAS GARANTÍAS DE COMERCIABILIDAD, APTITUD PARA UN PROPÓSITO PARTICULAR Y NO INFRACCIÓN. EN NINGÚN CASO LOS AUTORES O TITULARES DE DERECHOS DE AUTOR SERÁN RESPONSABLES DE CUALQUIER RECLAMACIÓN, DAÑOS U OTRA RESPONSABILIDAD, YA SEA EN UNA ACCIÓN DE CONTRATO, AGRAVIO U OTRA, QUE SURJA DE, FUERA DE O EN RELACIÓN CON EL SOFTWARE/LIBRO O EL USO U OTROS TRATOS EN EL SOFTWARE/LIBRO.

## PDF & EPUB {-}

Para mantener este libro actualizado y disponible públicamente para las personas que no pueden permitirse pagar por él, lo he publicado en formato HTML de forma gratuita en línea en [https://www.elixircryptobot.com](https://www.elixircryptobot.com).

Los formatos PDF y EPUB están disponibles para su compra en [Gumroad](https://gum.co/cSGdY).

## Prefacio {-}

En los últimos años, el lenguaje de programación [Elixir](https://elixir-lang.org/) ha ganado mucho interés en la industria.

Sus capacidades de paralelización inigualables son únicas y poderosas, lo que lo convierte en un gran candidato para sistemas altamente concurrentes como los que negocian activos en bolsas.

En este libro, recorreremos el proceso de desarrollo de un bot de comercio de criptomonedas en Elixir. Comenzaremos desde cero y capítulo a capítulo progresaremos con la implementación hasta terminar con una estrategia de comercio naive completamente desarrollada. Diseñaremos árboles de supervisión de procesos, describiendo por qué se tomaron decisiones específicas y cómo afectarán al sistema en el futuro.

De ninguna manera creo que "esta es la única manera" (ni siquiera la mejor manera) de crear un bot de comercio de criptomonedas en Elixir. Este libro se enfoca más en construir un proyecto de la vida real e iterar sobre él, tomando decisiones en el camino como ocurriría en un entorno de trabajo real. Algunas partes serán "perfectas" a la primera, pero también hay otras, donde haremos compromisos para "hacer que funcione", y luego, cuando sea el momento adecuado, las refactorizaremos a medida que obtengamos un mejor entendimiento de Elixir/OTP y el dominio.

## Para quién es este libro {-}

Este libro será un excelente recurso para todos aquellos que ya conocen los conceptos básicos de Elixir y quieren entender cómo se ve el desarrollo de un sistema no trivial utilizando este lenguaje.

Los lectores no necesitan un conocimiento profundo sobre criptomonedas para seguir el contenido, ya que evitaré el argot de cripto/comercio y lo explicaré siempre que sea inevitable.

**Este no es un libro enfocado en estrategias de comercio, ni es un asesoramiento financiero para comerciar en absoluto.** El enfoque principal de este libro es mostrar cómo la implementación de problemas incluso complejos se puede lograr en Elixir mediante procesos simples que trabajan juntos de manera orquestada.

**La estrategia descrita en este libro es ingenua y lo más probable es que pierda dinero,** pero ese no es el punto de este libro. **A medida que construimos la estrategia, nos enfrentaremos a un espectro de problemas que los desarrolladores enfrentan en el trabajo. Es un excelente primer paso si quieres tener tu primer "proyecto" bajo tu cinturón.**

Entonces, si ya has pasado por el proceso de aprender Elixir y OTP pero aún sientes que necesitas ensuciarte las manos con un "problema real" para que "se asiente", este libro es para ti.

## Qué cubre este libro {-}

Este libro es un proyecto en curso, y actualmente contiene los siguientes capítulos:

* Capítulo 1 - Transmisión en vivo de precios de criptomonedas desde Binance WSS

Transmitir precios en vivo de criptomonedas (eventos de comercio) desde el intercambio de Binance. Crearemos un nuevo proyecto paraguas y una aplicación `streamer` dentro de él desde cero. La aplicación `streamer` usará un cliente Websocket llamado `WebSockex` para conectarse con la API de Binance y recibir una transmisión en vivo. Después de recibir el evento como una cadena JSON, lo decodificaremos usando la biblioteca `jason` y lo convertiremos en nuestra estructura de datos. Veremos eventos de comercio decodificados registrados en la terminal al final del capítulo.

* Capítulo 2 - Crear una estrategia de comercio ingenua - un solo comerciante sin supervisión

En este capítulo, crearemos nuestra primera estrategia de comercio *ingenua*. Generaremos otra aplicación dentro de nuestro paraguas llamada `naive`. Pondremos los datos transmitidos a nuestra aplicación `streamer` en buen uso enviándolos a la aplicación `naive`. Comenzaremos con una solución muy básica que consiste en un solo proceso llamado `trader` que utilizará el comportamiento `GenServer`. Nos permitirá pasar por el ciclo completo de comercio y darnos algo que "funciona".

* Capítulo 3 - Introducir PubSub como método de comunicación

Para permitir que nuestra estrategia de comercio escale a múltiples comerciantes en paralelo, necesitamos encontrar una manera de distribuir los precios más recientes (eventos de comercio) a esos múltiples comerciantes. Introduciremos PubSub para transmitir mensajes desde el/los streamer(s) al/los trader(s). PubSub nos permitirá romper referencias codificadas entre aplicaciones en nuestro paraguas y se convertirá en un patrón que utilizaremos en adelante.

* Capítulo 4 - Simular la API de Binance

Además de precios históricos (eventos de comercio), para realizar backtesting, necesitamos poder simular la colocación de órdenes y recibir eventos de comercio de vuelta a medida que se llenan. En este capítulo, nos enfocaremos en desarrollar la solución que permitirá a nuestros comerciantes "comerciar" sin contactar al intercambio de Binance (para personas sin cuentas de Binance). Esto también nos permitirá hacer backtesting de nuestra estrategia de comercio.

Capítulo 5 - Habilitar el comercio paralelo en múltiples símbolos

Nuestra implementación básica de estrategia del último capítulo es definitivamente demasiado básica para ser usada en un "entorno de producción" - no puede ser escalada ni es tolerante a fallos. En este capítulo, actualizaremos nuestra estrategia ingenua para hacerla más resistente. Esto requerirá la creación de un árbol de supervisión y nos permitirá ver diferentes estrategias de supervisión en acción y entender la motivación detrás de su uso y combinación.

* Capítulo 6 - Introducir un "intervalo de compra descendente" para hacer un solo comerciante más rentable

En este momento, nuestra implementación de `Naive.Trader` colocará una orden de compra ciegamente al precio del último evento de comercio. Siempre que el proceso `Naive.Trader` termine un comercio, se iniciará un nuevo proceso `Naive.Trader` y terminará colocando una orden de compra al mismo precio que el precio de la orden de venta anterior. Esto nos costará el doble de la comisión sin obtener ninguna ventaja y causaría complicaciones adicionales más adelante, por lo que introduciremos un "intervalo de compra descendente" que permitirá a los procesos `Naive.Trader` colocar una orden de compra por debajo del precio del evento de comercio actual.

* Capítulo 7 - Introducir un presupuesto para el comerciante y calcular la cantidad

Desde el segundo capítulo, nuestros procesos `Naive.Trader` están colocando órdenes con una cantidad codificada de 100. En este capítulo, introduciremos un presupuesto que se dividirá uniformemente entre los procesos `Naive.Trader` usando partes. Utilizaremos ese presupuesto para calcular la cantidad (para poder hacerlo necesitamos obtener más información del "tamaño del paso" de la API de Binance).

* Capítulo 8 - Añadir soporte para múltiples transacciones por orden

Nuestra implementación de `Naive.Trader` asume que nuestras órdenes se llenarán en una sola transacción, pero esto no siempre es el caso. En este capítulo, discutiremos cómo podríamos implementar el soporte para múltiples transacciones por orden y las condiciones de carrera que podrían ocurrir entre el bot y la API de Binance.

* Capítulo 9 - Ejecutar múltiples comerciantes en paralelo

Con PubSub, el árbol de supervisión, la compra descendente y el presupuesto en su lugar, podemos avanzar con la escala del número de comerciantes. Esto requerirá más mejoras en nuestra estrategia de comercio, como introducir un "intervalo de recompra". Al final de este capítulo, nuestra estrategia de comercio será capaz de iniciar y ejecutar múltiples comerciantes en paralelo.

* Capítulo 10 - Ajustar la estrategia de comercio por símbolo

Actualmente, la estrategia ingenua funciona basada en configuraciones codificadas en el módulo `leader`. Para permitir un ajuste fino de la estrategia de comercio ingenua por símbolo, introduciremos una nueva base de datos junto con la tabla que almacenará las configuraciones de comercio.

* Capítulo 11 - Supervisar y autocomenzar la transmisión

En el último capítulo, introdujimos una nueva base de datos dentro de la aplicación `naive` para almacenar configuraciones predeterminadas, en este capítulo haremos lo mismo para la aplicación `streamer`. Dentro de las configuraciones, habrá una bandera de "estado" que nos permitirá implementar la funcionalidad de autocomienzo en la inicialización usando la abstracción de Tarea.

* Capítulo 12 - Iniciar, detener, apagar y autocomenzar el comercio

Para seguir después de autocomenzar la transmisión, aplicaremos el mismo truco al árbol de supervisión de comercio usando la abstracción de Tarea. Necesitaremos introducir un nuevo nivel de supervisión para lograr la estrategia de supervisión correcta.

* Capítulo 13 - Abstraer código de supervisión duplicado

Tanto las aplicaciones `naive` como `streamer` contienen casi el mismo código copiado y pegado que nos permite iniciar, detener y autocomenzar trabajadores. Veremos cómo podríamos abstraer las partes comunes de esa implementación en un solo módulo. Nos aventuraremos en utilizar la macro `__using__` para deshacernos del código repetitivo.

* Capítulo 14 - Almacenar eventos de comercio y órdenes dentro de la base de datos

Para poder hacer backtesting de la estrategia de comercio, necesitamos tener precios históricos (eventos de comercio) y una lista de órdenes que se colocaron almacenadas en la base de datos, lo cual será el enfoque de este capítulo. En este momento, los últimos precios (eventos de comercio) se transmiten al tema de PubSub y los comerciantes se suscriben a él. Crearemos una nueva aplicación llamada `data_warehouse` dentro de nuestro paraguas que será responsable de suscribirse a los mismos temas de PubSub y almacenar los precios entrantes (eventos de comercio) en la base de datos Postgres. Actualizaremos el módulo `Naive.Trader` para transmitir órdenes a medida que los comerciantes las coloquen.

Luego pasaremos a agregar supervisión similar a la de las aplicaciones `naive` y `streamer`, pero esta vez mostraremos cómo podríamos evitar usar tanto el módulo común como las macros utilizando el módulo `Registry`.

* Capítulo 15 - Prueba de retroceso de la estrategia de comercio

En este capítulo, realizaremos una prueba de retroceso de nuestra estrategia de comercio desarrollando un publicador dentro de la aplicación DataWarehouse. Transmitirá eventos de comercio desde la base de datos para difundirlos en el tema PubSub `TRADE_EVENTS:#{símbolo}`. Usará el mismo tema como si los datos se transmitieran directamente desde Binance. Desde la perspectiva del comerciante, no habrá ninguna diferencia y provocará una actividad comercial normal que se almacenará en la base de datos para analizarla más tarde.

* Capítulo 16 - Pruebas de extremo a extremo

Hemos llegado a la etapa en la que tenemos una solución decente en su lugar, y para asegurarnos de que aún funcione correctamente después de cualquier refactorización futura, agregaremos pruebas. Comenzaremos con la prueba de "integración"/"extremo a extremo" (E2E), que confirmará que todo el "comercio" funciona. Para realizar pruebas a este nivel, necesitaremos orquestar bases de datos junto con procesos y difundir eventos de comercio desde dentro de la prueba para hacer que nuestra estrategia de comercio coloque órdenes. Podremos confirmar el comportamiento correcto revisando la base de datos después de ejecutar la prueba.

* Capítulo 17 - Mox rocks

En el capítulo anterior, implementamos la prueba de extremo a extremo que requería mucho trabajo de preparación, y pudimos ver claramente las desventajas de este tipo de pruebas. Este capítulo se centrará en implementar una prueba más granular que utilizará el paquete `mox` para simular las dependencias del `Naive.Trader`. Veremos cómo funciona Mox y cómo necesitaremos modificar nuestro código para usarlo.

* Capítulo 18 - Elixir funcional

En este capítulo, nos aventuraremos en el mundo funcional mirando cómo podríamos mejorar nuestro código para empujar los efectos secundarios al límite. Revisaremos el código de `Naive.Trader` para abstraer nuestro código de estrategia en un nuevo módulo llamado `Naive.Strategy`. Desde este lugar, reorganizaremos el código para maximizar la cantidad de funciones puras fácilmente comprobables. Finalmente, exploraremos implementaciones hipotéticas que nos permitirán inyectar datos en la función o incluso gestionar efectos para ayudar a la comprobabilidad. Compararemos esos con soluciones integradas en Elixir como la declaración `with`.

* Capítulo 19 - OTP idiomático

En el último capítulo, estábamos viendo cómo podríamos reorganizar el código para maximizar la cantidad de código puro. En este capítulo, veremos diferentes formas de implementar el agregador OHLC (open-high-low-close), considerando una optimización similar pero expandiéndose para limitar el número de procesos para ayudar a la comprobabilidad y mantenibilidad.

* Capítulo 20 - Estrategia de comercio idiomática

Usaremos el conocimiento adquirido en el último capítulo para revisar nuestra estrategia de comercio Naive de modo que minimicemos el número de procesos necesarios para comerciar. Moveremos las funcionalidades proporcionadas por `Naive.Leader` y `Naive.SymbolSupervisor` a nuestra estrategia, cuidando de poner tanto como sea posible en la parte pura. Al final, nuestro `Naive.Trader` podrá manejar múltiples posiciones (ciclos de comercio), y la gran mayoría del código previamente disperso en múltiples módulos/procesos se convertirá en funciones puras fácilmente comprobables dentro de nuestro `Naive.Strategy`.

## Contribuyendo, Erratas y Código Fuente {-}

El libro está escrito usando [R Markdown](http://rmarkdown.rstudio.com/)(tiene una sintaxis muy similar al markdown de GitHub pero soporta muchas más características incluyendo la ejecución de código, etc.) y convertido a su forma final (por ejemplo, PDF) utilizando la aplicación [bookdown](https://www.bookdown.org/). Esto significa que editar un capítulo es tan simple como editar la fuente markdown de ese capítulo.

Hay dos repositorios relacionados con este libro (ambos alojados en Github):

* [código fuente del propio libro](https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot)
* [código escrito a lo largo del libro donde el código final de cada capítulo tiene su propia rama](https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code)

En cuanto a las contribuciones - me encantaría seguir el proceso estándar de hacer fork, realizar cambios, abrir PR (por favor, verifica si hay una rama para la próxima versión y apunta a ella en lugar de `main`), fusionar y lanzar una nueva versión del libro.

Este libro también tiene **Discusiones de GitHub** habilitadas tanto para el [repositorio del libro](https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot/discussions) como para el [repositorio del código fuente](https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/discussions), por favor, siéntete bienvenido a iniciar cualquier discusión relacionada con el libro allí.

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```
