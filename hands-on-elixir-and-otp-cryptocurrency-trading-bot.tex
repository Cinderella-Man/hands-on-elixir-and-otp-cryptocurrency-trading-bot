% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
  oneside]{book}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
    \setmonofont[]{Consolas.ttf}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[left=3cm, right=3cm, top=2.5cm, bottom=2.5cm]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% sample comment
\usepackage{pdfpages}

% line spacing
\usepackage{setspace}
\renewcommand{\baselinestretch}{1.25}

\pagestyle{plain}
\raggedbottom

\setmainfont[
  BoldFont={EBGaramond-Bold.ttf},
  ItalicFont={EBGaramond-Italic.ttf},
  BoldItalicFont={EBGaramond-BoldItalic.ttf}
]{EBGaramond-Regular.ttf}

\let\oldmaketitle\maketitle
\AtBeginDocument{\let\maketitle\relax}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Hands-on Elixir \& OTP: Cryptocurrency trading bot},
  pdfauthor={Kamil Skowron},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Hands-on Elixir \& OTP: Cryptocurrency trading bot}
\author{Kamil Skowron}
\date{0.6.1}

\begin{document}
\maketitle

\includepdf[pages={1}, scale=1]{images/cover.pdf}
\includepdf[pages={1}, scale=1]{images/dedication.pdf}
\newpage

\let\maketitle\oldmaketitle
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\chapter*{Preface}\label{preface}
\addcontentsline{toc}{chapter}{Preface}

\subsection*{Want to learn Elixir \& OTP by creating a real-world project?}\label{want-to-learn-elixir-otp-by-creating-a-real-world-project}
\addcontentsline{toc}{subsection}{Want to learn Elixir \& OTP by creating a real-world project?}

With ``Hands-on Elixir \& OTP: Cryptocurrency trading bot'', you will \textbf{gain hands-on experience by writing an exciting software project from scratch.} We will explore all the key abstractions and essential principles through iterative implementation improvements.

We will start by creating a new umbrella application, subscribing to WebSocket streams, implementing a basic trading flow, and focusing on improving it by expanding on the topics like supervision trees, resiliency, refactoring using macros, utilising the Registry, testing and others.

\textbf{This book is 95\% complete - chapters 1-23 are finished,} and I'll add more content soon. It's also a loosely written representation of the \href{https://www.youtube.com/watch?v=wVYIx7M6o28&list=PLxsE19GnjC5Nv1CbeKOiS5YqGqw35aZFJ}{Hands-on Elixir \& OTP: Cryptocurrency trading bot} video course released on YouTube.

This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International \href{https://creativecommons.org/licenses/by-nc-sa/4.0/}{CC BY-NC-SA 4.0}.

\textbf{To get notified about updates} to this book just ``watch'' the \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot}{source code's repository}, and don't forget to leave a star:

\begin{center}\includegraphics[width=0.6\linewidth]{images/watch_book_howto} \end{center}

\newpage

\section*{Limit of Liability/Disclaimer of Warranty}\label{limit-of-liabilitydisclaimer-of-warranty}
\addcontentsline{toc}{section}{Limit of Liability/Disclaimer of Warranty}

\textbf{THIS BOOK IS NOT FINANCIAL ADVICE}

THE SOFTWARE/BOOK IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE/BOOK OR THE USE OR OTHER DEALINGS IN THE SOFTWARE/BOOK.

\section*{PDF \& EPUB}\label{pdf-epub}
\addcontentsline{toc}{section}{PDF \& EPUB}

To keep this book up to date and publicly available for people who can't afford to pay for it, I've released it in the HTML format free online at \url{https://www.elixircryptobot.com}.

The PDF \& EPUB formats are available for purchase on \href{https://gum.co/cSGdY}{Gumroad}.

\section*{Preface}\label{preface-1}
\addcontentsline{toc}{section}{Preface}

In recent years \href{https://elixir-lang.org/}{Elixir} programming language gained a lot of interest in the industry.

Its unmatched parallelisation capabilities are unique and powerful, making it a great candidate for highly concurrent systems like the ones trading assets on exchanges.

In this book, we will go through the development process of a cryptocurrency trading bot in Elixir. We will start ground up and chapter by chapter progress with the implementation ending up with a fully-fledged \emph{naive} trading strategy. We will be designing process supervision trees, describing why specific decisions were taken and how will they impact the system going forward.

By any stretch of the imagination, I don't believe that ``this is \emph{the only} way''(nor even the best way) to create a cryptocurrency trading bot in Elixir. This book focuses more on building a real-life project and iterating over it, taking decisions on the way as it would happen in a real work environment. Some parts will be ``perfect'' the first time around, but there are also others, where we will make compromises to ``get it to working'', and then when the time is right, we will refactor them as we will gain a better understanding of Elixir/OTP and the domain.

\section*{Who this book is for}\label{who-this-book-is-for}
\addcontentsline{toc}{section}{Who this book is for}

This book will be an excellent resource for everyone that already knows the basics of Elixir and wants to get a feel of how developing a non-trivial system looks like using it.

Readers do not need deep knowledge about cryptocurrencies to follow along, as I will shy away from crypto/trading jargon as well as will explain it whenever it's unavoidable.

\textbf{This is not a book focused on trading strategies, neither it's financial advice to trade at all.} The main focus of this book is to showcase how the implementation of even complex problems can be achieved in Elixir by simple processes working together in an orchestrated manner.

\textbf{The strategy described in this book is naive and most probably will lose money}, but that's not the point of this book. \textbf{As we will build up the strategy, we will face a spectrum of problems developers face at work. It's a great primer if you want to get your first ``project'' behind your belt}.

So, if you've already gone through the motions and learned Elixir and OTP but still feel like you need to get your hands dirty with a ``real problem'' to ``make it stick'', this book is for you.

\section*{What this book covers}\label{what-this-book-covers}
\addcontentsline{toc}{section}{What this book covers}

This book is an ongoing project, and at present, it contains the following chapters:

\begin{itemize}
\tightlist
\item
  Chapter 1 - Stream live cryptocurrency prices from the Binance WSS
\end{itemize}

Stream live cryptocurrency prices (trade events) from the Binance exchange. We will create a new umbrella project and a \texttt{streamer} application inside it starting grounds up. The streamer application will use a Websocket client called \texttt{WebSockex} to connect with the Binance API and receive a live feed. After receiving the event as a JSON string, we will decode it using the \texttt{jason} library and convert it to our data struct. We will see decoded trade events logged to the terminal by the end of the chapter.

\begin{itemize}
\tightlist
\item
  Chapter 2 - Create a naive trading strategy - single trader without supervision
\end{itemize}

In this chapter, we will create our first \emph{naive} trading strategy. We will generate another application inside our umbrella called \texttt{naive}. We will put data streamed to our \texttt{streamer} application to good use by sending it over to the \texttt{naive} application. We will start with a very basic solution consisting of a single process called \texttt{trader} that will utilise the \texttt{GenServer} behaviour. It will allow us to go through the complete trading cycle and give us something that ``works''.

\begin{itemize}
\tightlist
\item
  Chapter 3 - Introduce PubSub as a communication method
\end{itemize}

To allow our trading strategy to scale to multiple parallel traders, we need to find a way to distribute the latest prices (trade events) to those multiple traders. We will introduce PubSub to broadcast messages from the streamer(s) to the trader(s). PubSub will allow us to break hardcoded references between applications in our umbrella and become a pattern that we will utilise moving forward.

\begin{itemize}
\tightlist
\item
  Chapter 4 - Mock the Binance API
\end{itemize}

Besides historical prices (trade events), to perform backtesting, we need to be able to mock placing orders and get trade events back as they are filled. In this chapter, we will focus on developing the solution that will allow our traders to ``trade'' without contacting the Binance exchange(for people without Binance accounts). This will also allow us to backtest our trading strategy.

\begin{itemize}
\tightlist
\item
  Chapter 5 - Enable parallel trading on multiple symbols
\end{itemize}

Our basic strategy implementation from the last chapter is definitely too basic to be used in a ``production environment'' - it can't be neither scaled nor it is fault-tolerant. In this chapter, we will upgrade our naive strategy to be more resilient. This will require a supervision tree to be created and will allow us to see different supervision strategies in action and understand the motivation behind using and stacking them.

\begin{itemize}
\tightlist
\item
  Chapter 6 - Introduce a \texttt{buy\_down\_interval} to make a single trader more profitable
\end{itemize}

At this moment our \texttt{Naive.Trader} implementation will blindly place a buy order at the price of the last trade event. Whenever the \texttt{Naive.Trader} process will finish trade, a new \texttt{Naive.Trader} process will be started and it will end up placing a buy order at the same price as the price of the previous sell order. This will cost us double the fee without gaining any advantage and would cause further complications down the line, so we will introduce a \texttt{buy\_down\_interval} which will allow the \texttt{Naive.Trader} processes to place a buy order below the current trade event's price.

\begin{itemize}
\tightlist
\item
  Chapter 7 - Introduce a trader budget and calculating the quantity
\end{itemize}

Since the second chapter, our \texttt{Naive.Trader} processes are placing orders with a hardcoded quantity of 100. In this chapter, we will introduce a budget that will be evenly split between the \texttt{Naive.Trader} processes using chunks. We will utilize that budget to calculate quantity (to be able to do that we need to fetch further \texttt{step\_size} information from the Binance API).

\begin{itemize}
\tightlist
\item
  Chapter 8 - Add support for multiple transactions per order
\end{itemize}

Our \texttt{Naive.Trader} implementation assumes that our orders will be filled within a single transaction, but this isn't always the case. In this chapter, we will discuss how could we implement the support for multiple transactions per order and race conditions that could occur between the bot and the Binance API.

\begin{itemize}
\tightlist
\item
  Chapter 9 - Run multiple traders in parallel
\end{itemize}

With PubSub, supervision tree, buy down and budget in place we can progress with scaling the number of traders. This will require further improvements to our trading strategy like introducing a \texttt{rebuy\_interval}. At the end of this chapter, our trading strategy will be able to start and run multiple traders in parallel.

\begin{itemize}
\tightlist
\item
  Chapter 10 - Fine-tune trading strategy per symbol
\end{itemize}

Currently, the naive strategy works based on settings hardcoded in the \texttt{leader} module. To allow for fine-tuning the naive trading strategy per symbol we will introduce a new database together with the table that will store trading settings.

\begin{itemize}
\tightlist
\item
  Chapter 11 - Supervise and autostart streaming
\end{itemize}

In the last chapter, we introduced a new database inside the \texttt{naive} application to store default settings, in this chapter we will do the same for the \texttt{streamer} application. Inside the settings, there will be a \texttt{status} flag that will allow us to implement the autostarting functionality on initialization using Task abstraction.

\begin{itemize}
\tightlist
\item
  Chapter 12 - Start, stop, shutdown, and autostart trading
\end{itemize}

To follow up after autostarting streaming we will apply the same trick to the trading supervision tree using Task abstraction. We will need to introduce a new supervision level to achieve the correct supervision strategy.

\begin{itemize}
\tightlist
\item
  Chapter 13 - Abstract duplicated supervision code
\end{itemize}

As both the \texttt{naive} and the \texttt{streamer} applications contain almost the same copy-pasted code that allows us to start, stop and autostart workers. We will look into how could we abstract the common parts of that implementation into a single module. We will venture into utilizing the \texttt{\_\_using\_\_} macro to get rid of the boilerplate.

\begin{itemize}
\tightlist
\item
  Chapter 14 - Store trade events and orders inside the database
\end{itemize}

To be able to backtest the trading strategy, we need to have historical prices (trade events) and a list of orders that were placed stored in the database, which will be the focus of this chapter. At this moment, the latest prices (trade events) are broadcasted to PubSub topic and traders are subscribing to it. We will create a new application called \texttt{data\_warehouse} inside our umbrella that will be responsible for subscribing to the same PubSub topics and storing incoming prices (trade events) in the Postgres database. We will update the \texttt{Naive.Trader} module to broadcast orders as traders will place them.

Then we will move on to adding supervision similar to the one from the \texttt{naive} and the \texttt{streamer} applications but this time we will show how we could avoid using both common module and macros by utilizing the \texttt{Registry} module.

\begin{itemize}
\tightlist
\item
  Chapter 15 - Backtest trading strategy
\end{itemize}

In this chapter, we will be backtesting our trading strategy by developing a publisher inside the DataWarehouse application. It will stream trade events from the database to broadcast them to the \texttt{TRADE\_EVENTS:\#\{symbol\}} PubSub topic. It will use the same topic as data would be streamed directly from the Binance. From the trader's perspective, it won't any difference and will cause normal trading activity that will be stored inside the database to be analyzed later.

\begin{itemize}
\tightlist
\item
  Chapter 16 - End-to-end testing
\end{itemize}

We've reached the stage where we have a decent solution in place, and to ensure that it's still working correctly after any future refactoring, we will add tests. We will start with the ``integration''/``end-to-end''(E2E) test, which will confirm that the whole ``trading'' works. To perform tests at this level, we will need to orchestrate databases together with processes and broadcast trade events from within the test to cause our trading strategy to place orders. We will be able to confirm the right behaviour by checking the database after running the test.

\begin{itemize}
\tightlist
\item
  Chapter 17 - Mox rocks
\end{itemize}

In the previous chapter, we've implemented the end-to-end test that required a lot of prep work, and we were able to see the downsides of this type of tests clearly. This chapter will focus on implementing a more granular test that will utilize the \texttt{mox} package to mock out the dependencies of the \texttt{Naive.Trader}. We will look into how the Mox works and how we will need to modify our code to use it.

\begin{itemize}
\tightlist
\item
  Chapter 18 - Functional Elixir
\end{itemize}

In this chapter, we will venture into the functional world by looking at how could we improve our code to push side effects to the edge. We will revise the \texttt{Naive.Trader} code to abstract away our strategy code into a new module called \texttt{Naive.Strategy}. From this place, we will reorganise the code to maximise the amount of easily testable pure functions. Finally, we will explore hypothetical implementations that will allow us to inject data into function or even manage effects to aid testability. We will compare those to solutions built into Elixir like the \texttt{with} statement.

\begin{itemize}
\tightlist
\item
  Chapter 19 - Idiomatic OTP
\end{itemize}

In the last chapter, we were looking into how we could reorganise \emph{the code} to maximise the amount of pure code. In this chapter, we will look into different ways of implementing the OHLC(open-high-low-close) aggregator, considering similar optimisation but expanding to limit the number of processes to aid testability and maintainability.

\begin{itemize}
\tightlist
\item
  Chapter 20 - Idiomatic trading strategy
\end{itemize}

We will use the knowledge gained in the last chapter to revise our Naive trading strategy so we will minimise the number of processes required to trade. We will move the functionalities provided by the \texttt{Naive.Leader} and the \texttt{Naive.SymbolSupervisor} into our strategy, taking care to put as much of it as possible into the pure part. In the end, our \texttt{Naive.Trader} will be able to manage multiple positions(trade cycles), and the vast majority of code previously scattered across multiple modules/processes will become easily testable pure functions inside our \texttt{Naive.Strategy}.

\begin{itemize}
\tightlist
\item
  Chapter 21 - Layers of abstraction
\end{itemize}

In this chapter, I acknowledge that the Mox package was misused throughout the book. We will look into the idiomatic way of using it, its consequences, and why you should avoid it. On the other hand, we will check out the \texttt{Mimic} package, which does not impact our production system at all. Along the way, we will reconsider how to deal with logging and the usage of module attributes as ``dependency injection.''

\begin{itemize}
\tightlist
\item
  Chapter 22 - 80/20 win with pure logic
\end{itemize}

In the 20th chapter, we refactored most of the code inside the Naive strategy, promising ourselves that it would make testing and maintenance easy. In this chapter, we will test that, proving that we are now able to test the vast majority of the system using trivial, easy-to-understand input-output tests.

\begin{itemize}
\tightlist
\item
  Chapter 23 - Back to the Monolith
\end{itemize}

In this chapter, we will look back at the issues/complexity umbrella applications cause. We will port the whole application to a new Phoenix skeleton, using this opportunity to refactor/merge logic that was previously spread across multiple apps.

\section*{Contributing, Errata and Source code}\label{contributing-errata-and-source-code}
\addcontentsline{toc}{section}{Contributing, Errata and Source code}

The book is written using \href{http://rmarkdown.rstudio.com/}{R Markdown}(it's a very similar syntax to the GitHub markdown but supports many more features including code execution, etc.) and converted to final form (for example PDF) using the \href{https://www.bookdown.org/}{bookdown} app. This means that editing a chapter is as simple as editing the markdown source of that chapter.

There are two repositories related to this book(both hosted on Github):

\begin{itemize}
\tightlist
\item
  \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot}{source code of the book itself}
\item
  \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code}{code written across the book where the final code of each chapter has its own branch}
\end{itemize}

In regards to contributions - I would love to follow the standard process of forking, making changes, opening PR(please look is there a branch for the next version and point to it instead of \texttt{main}), merging, and releasing a new version of the book.

This books has also the \textbf{GitHub Discussions} enabled for both the \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot/discussions}{book's repo} as well as \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/discussions}{source code's repo}, please feel welcome to start any discussions related to book there.

\chapter{Stream live cryptocurrency prices from the Binance WSS}\label{stream-live-cryptocurrency-prices-from-the-binance-wss}

\section{Objectives}\label{objectives}

\begin{itemize}
\tightlist
\item
  create a new umbrella app
\item
  create a supervised application inside an umbrella
\item
  connect to Binance's WebSocket Stream using the WebSockex module
\item
  define a TradeEvent struct that will hold incoming data
\item
  decode incoming events using the Jason module
\end{itemize}

\section{Create a new umbrella app}\label{create-a-new-umbrella-app}

As we are starting from scratch, we need to create a new umbrella project:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{mix}\NormalTok{ new hedgehog }\AttributeTok{{-}{-}umbrella}
\end{Highlighting}
\end{Shaded}

\section{Create a supervised application inside an umbrella}\label{create-a-supervised-application-inside-an-umbrella}

We can now proceed with creating a new supervised application called \texttt{streamer} inside our umbrella:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ hedgehog/apps}
\ExtensionTok{mix}\NormalTok{ new streamer }\AttributeTok{{-}{-}sup}
\end{Highlighting}
\end{Shaded}

\section{Connect to Binance's WebSocket Stream using the WebSockex module}\label{connect-to-binances-websocket-stream-using-the-websockex-module}

To establish a connection to Binance API's stream, we will need to use a WebSocket client. The module that we will use is called \href{https://github.com/Azolo/websockex}{WebSockex}. Scrolling down to the \texttt{Installation} section inside the module's readme on Github, we are instructed what dependency we need to add to our project.

We will append \texttt{:websockex} to the \texttt{deps} function inside the \texttt{mix.exs} file of the \texttt{streamer} application:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:websockex}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 0.4"}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we added a dependency to our project, we need to fetch it using \texttt{mix\ deps.get}.

We can now progress with creating a module that will be responsible for streaming. We will create a new file called \texttt{binance.ex} inside the \texttt{apps/streamer/lib/streamer} directory.

From the readme of \href{https://github.com/Azolo/websockex}{WebSockex} module, we can see that to use it we need to create a module that will implement the \texttt{WebSockex} behavior:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# WebSockex\textquotesingle{}s readme}
\KeywordTok{defmodule} \ConstantTok{WebSocketExample} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{WebSockex}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{url, state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{WebSockex}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\NormalTok{url, }\ConstantTok{\_\_MODULE\_\_}\NormalTok{, state}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_frame}\FunctionTok{(\{}\NormalTok{type, msg}\FunctionTok{\}}\NormalTok{, state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{IO}\OperatorTok{.}\NormalTok{puts }\StringTok{"Received Message {-} Type: }\OtherTok{\#\{}\NormalTok{inspect type}\OtherTok{\}}\StringTok{ {-}{-} Message: }\OtherTok{\#\{}\NormalTok{inspect msg}\OtherTok{\}}\StringTok{"}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_cast}\FunctionTok{(\{}\VariableTok{:send}\NormalTok{, }\FunctionTok{\{}\NormalTok{type, msg}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ frame}\FunctionTok{\}}\NormalTok{, state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{IO}\OperatorTok{.}\NormalTok{puts }\StringTok{"Sending }\OtherTok{\#\{}\NormalTok{type}\OtherTok{\}}\StringTok{ frame with payload: }\OtherTok{\#\{}\NormalTok{msg}\OtherTok{\}}\StringTok{"}
    \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, frame, state}\FunctionTok{\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We will copy the whole code above across to our new \texttt{binance.ex} file.

\newpage

The first step will be to update the module name to match our file name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

In the spirit of keeping things tidy - we will now remove the \texttt{handle\_cast/2} function (the last function in our module) as we won't be sending any messages back to Binance via WebSocket (to place orders etc - Binance provides a REST API which we will use in the next chapter).

Next, let's look up what URL should we use to connect to Binance's API. Binance has a separate WSS (Web Socket Streams) documentation at \href{https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md}{Github}.

Scrolling down we can see the \texttt{General\ WSS\ information} section where 3 important pieces of information are listed:

\begin{itemize}
\tightlist
\item
  The base endpoint is: \texttt{wss://stream.binance.com:9443}
\item
  Raw streams are accessed at \texttt{/ws/\textless{}streamName\textgreater{}}
\item
  All symbols for streams are \emph{lowercase}
\end{itemize}

We can see that the full endpoint for raw streams(we will be using a ``raw'' stream) will be \texttt{wss://stream.binance.com:9443/ws/} with stream name at the end (together with lowercased symbol).

Note: In the context of Binance API, ``raw'' means that no aggregation was performed before broadcasting the data on WebSocket.

Let's introduce a module attribute that will hold the full raw stream endpoint which will be used across the module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
\OtherTok{@stream\_endpoint} \StringTok{"wss://stream.binance.com:9443/ws/"}
\end{Highlighting}
\end{Shaded}

Now back in \href{https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md}{Binance's WSS documentation} we need to search for ``Trade Streams''. ``trade'' in the context of this documentation means an exchange of assets(coins/tokens) by two sides (buyer and seller). Our future trading strategy will be interested in the ``latest price'' which is simply the last trade event's price.

We can see that docs are pointing to the following stream name:

\begin{verbatim}
Stream Name: <symbol>@trade
\end{verbatim}

Together, our full URL looks like: ``\url{wss://stream.binance.com:9443/ws/}@trade''.
To give a concrete example: the raw trade events stream URL for symbol XRPUSDT is:
``\url{wss://stream.binance.com:9443/ws/xrpusdt@trade}'' (remember that symbols need to be lowercased, otherwise no trade events will get streamed - there's \emph{no} error).

\newpage

Back to the IDE, we will now modify the \texttt{start\_link/2} function to use Binance API's URL:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{downcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \ConstantTok{WebSockex}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \StringTok{"}\OtherTok{\#\{@stream\_endpoint\}\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{@trade"}\NormalTok{,}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \ConstantTok{nil}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Instead of passing an URL, we modified the function to accept a \texttt{symbol}, downcase it and use it together with the module's \texttt{@stream\_endpoint} attribute to build a full URL.

At this moment streaming of trade events already works which we can test using \texttt{iex}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.Binance.start\_link}\KeywordTok{(}\StringTok{"xrpusdt"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.335.0\textgreater{}\}}
\ExtensionTok{Received}\NormalTok{ Message }\AttributeTok{{-}}\NormalTok{ Type: :text }\AttributeTok{{-}{-}}\NormalTok{ Message: }\StringTok{"\{}\DataTypeTok{\textbackslash{}"}\StringTok{e}\DataTypeTok{\textbackslash{}"}\StringTok{:}\DataTypeTok{\textbackslash{}"}\StringTok{trade}\DataTypeTok{\textbackslash{}"}\StringTok{, }\DataTypeTok{\textbackslash{}"}\StringTok{E}\DataTypeTok{\textbackslash{}"}\StringTok{:1603226394741,}
\StringTok{  }\DataTypeTok{\textbackslash{}"}\StringTok{s}\DataTypeTok{\textbackslash{}"}\StringTok{:}\DataTypeTok{\textbackslash{}"}\StringTok{XRPUSDT}\DataTypeTok{\textbackslash{}"}\StringTok{,}\DataTypeTok{\textbackslash{}"}\StringTok{t}\DataTypeTok{\textbackslash{}"}\StringTok{:74608889,}\DataTypeTok{\textbackslash{}"}\StringTok{p}\DataTypeTok{\textbackslash{}"}\StringTok{:}\DataTypeTok{\textbackslash{}"}\StringTok{0.24373000}\DataTypeTok{\textbackslash{}"}\StringTok{,}\DataTypeTok{\textbackslash{}"}\StringTok{q}\DataTypeTok{\textbackslash{}"}\StringTok{:}\DataTypeTok{\textbackslash{}"}\StringTok{200.00000000}\DataTypeTok{\textbackslash{}"}\StringTok{,}
\StringTok{  }\DataTypeTok{\textbackslash{}"}\StringTok{b}\DataTypeTok{\textbackslash{}"}\StringTok{:948244411,}\DataTypeTok{\textbackslash{}"}\StringTok{a}\DataTypeTok{\textbackslash{}"}\StringTok{:948244502,}\DataTypeTok{\textbackslash{}"}\StringTok{T}\DataTypeTok{\textbackslash{}"}\StringTok{:1603226394739,}\DataTypeTok{\textbackslash{}"}\StringTok{m}\DataTypeTok{\textbackslash{}"}\StringTok{:true,}\DataTypeTok{\textbackslash{}"}\StringTok{M}\DataTypeTok{\textbackslash{}"}\StringTok{:true\}"}
\end{Highlighting}
\end{Shaded}

We can see the messages logged above because we copied the sample implementation from \href{https://github.com/Azolo/websockex}{WebSockex's readme} where \texttt{handle\_frame/2} function uses \texttt{IO.puts/1} to print out all incoming data. The lesson here is that every incoming message from Binance will cause the \texttt{handle\_frame/2} callback to be called with the message and the process' state.

Just for reference, our module should look currently as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{WebSockex}

  \OtherTok{@stream\_endpoint} \StringTok{"wss://stream.binance.com:9443/ws/"}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{downcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \ConstantTok{WebSockex}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \StringTok{"}\OtherTok{\#\{@stream\_endpoint\}\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{@trade"}\NormalTok{,}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \ConstantTok{nil}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_frame}\FunctionTok{(\{}\NormalTok{type, msg}\FunctionTok{\}}\NormalTok{, state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{IO}\OperatorTok{.}\NormalTok{puts }\StringTok{"Received Message {-} Type: }\OtherTok{\#\{}\NormalTok{inspect type}\OtherTok{\}}\StringTok{ {-}{-} Message: }\OtherTok{\#\{}\NormalTok{inspect msg}\OtherTok{\}}\StringTok{"}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Decode incoming events using the Jason module}\label{decode-incoming-events-using-the-jason-module}

Currently, all incoming data from WebSocket is encoded as a JSON. To decode JSON we will use the \href{https://github.com/michalmuskala/jason}{jason} module.

Scrolling down to the \texttt{Installation} section inside the module's readme, we can see that we need to add it to the dependencies and we can start to use it right away.

Let's open the \texttt{mix.exs} file of the \texttt{streamer} application and append the \texttt{:jason} dependency to the list inside \texttt{deps} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:jason}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.2"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:websockex}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 0.4"}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As previously, don't forget to run \texttt{mix\ deps.get} to fetch the new dependency.

Looking through the documentation of the Jason module we can see \texttt{encode!/2} and \texttt{decode!/2} functions, both of them have exclamation marks which indicate that they will throw an error whenever they will be unable to successfully encode or decode the passed value.

This is less than perfect for our use case as we would like to handle those errors in our own way(technically we could just use try/rescue but as we will find out both \texttt{encode/2} and \texttt{decode/2} are available).

We will go a little bit off-topic but I would highly recommend those sorts of journeys around somebody's code. Let's look inside the \href{https://github.com/michalmuskala/jason/blob/master/lib/jason.ex}{Jason} module. Scrolling down in search of \texttt{decode/2} (without the exclamation mark) we can see it about line 54:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /lib/jason.ex}
  \KeywordTok{def}\NormalTok{ decode}\FunctionTok{(}\NormalTok{input, opts \textbackslash{}\textbackslash{} }\OtherTok{[]}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    input }\OperatorTok{=} \ConstantTok{IO}\OperatorTok{.}\NormalTok{iodata\_to\_binary}\FunctionTok{(}\NormalTok{input}\FunctionTok{)}
    \ConstantTok{Decoder}\OperatorTok{.}\NormalTok{parse}\FunctionTok{(}\NormalTok{input, format\_decode\_opts}\FunctionTok{(}\NormalTok{opts}\FunctionTok{))}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

It looks like it uses the \texttt{parse/2} function of a \texttt{Decoder} module, let's scroll back up and check where it's coming from. At line 6:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/jason.ex}
\ImportTok{alias} \ConstantTok{Jason}\OperatorTok{.}\FunctionTok{\{}\ConstantTok{Encode}\NormalTok{, }\ConstantTok{Decoder}\NormalTok{, }\ConstantTok{DecodeError}\NormalTok{, }\ConstantTok{EncodeError}\NormalTok{, }\ConstantTok{Formatter}\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

we can see that \texttt{Decoder} is an alias of the \href{https://github.com/michalmuskala/jason/blob/master/lib/decoder.ex}{\texttt{Jason.Decoder}}. Scrolling down to the \texttt{Jason.Decoder} module we will find a \texttt{parse/2} function about line 43:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /lib/decoder.ex}
  \KeywordTok{def}\NormalTok{ parse}\FunctionTok{(}\NormalTok{data, opts}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{data}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    key\_decode }\OperatorTok{=}\NormalTok{ key\_decode\_function}\FunctionTok{(}\NormalTok{opts}\FunctionTok{)}
\NormalTok{    string\_decode }\OperatorTok{=}\NormalTok{ string\_decode\_function}\FunctionTok{(}\NormalTok{opts}\FunctionTok{)}
    \ControlFlowTok{try} \KeywordTok{do}
\NormalTok{      value}\FunctionTok{(}\NormalTok{data, data, }\DecValTok{0}\NormalTok{, }\OtherTok{[@terminate]}\NormalTok{, key\_decode, string\_decode}\FunctionTok{)}
    \ControlFlowTok{catch}
      \FunctionTok{\{}\VariableTok{:position}\NormalTok{, position}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:error}\NormalTok{, \%}\ConstantTok{DecodeError}\FunctionTok{\{}\VariableTok{position:}\NormalTok{ position, }\VariableTok{data:}\NormalTok{ data}\FunctionTok{\}\}}
      \FunctionTok{\{}\VariableTok{:token}\NormalTok{, token, position}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:error}\NormalTok{, \%}\ConstantTok{DecodeError}\FunctionTok{\{}\VariableTok{token:}\NormalTok{ token, }\VariableTok{position:}\NormalTok{ position, }\VariableTok{data:}\NormalTok{ data}\FunctionTok{\}\}}
    \ControlFlowTok{else}
\NormalTok{      value }\OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, value}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Based on the result of decoding it will either return \texttt{\{:ok,\ value\}} or \texttt{\{:error,\ \%Decode.Error\{...\}\}} we can confirm that by digging through documentation of the module on the \href{https://hexdocs.pm/jason/Jason.html\#decode/2}{hexdocs}.

Once again, the point of this lengthy investigation was to show that Elixir code is readable and easy to understand so don't be thrown off when documentation is a little bit light, quite opposite, contribute to docs and code as you gain a better understanding of the codebase.

We can now get back to our \texttt{Streamer.Binance} module and modify the \texttt{handle\_frame/2} function to decode the incoming JSON message. Based on the result of \texttt{Jason.decode/2} we will either call the \texttt{process\_event/2} function or log an error. Here's the new version of the \texttt{handle\_frame/2} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
  \KeywordTok{def}\NormalTok{ handle\_frame}\FunctionTok{(\{}\NormalTok{\_type, msg}\FunctionTok{\}}\NormalTok{, state}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Jason}\OperatorTok{.}\NormalTok{decode}\FunctionTok{(}\NormalTok{msg}\FunctionTok{)} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, event}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}\NormalTok{ process\_event}\FunctionTok{(}\NormalTok{event}\FunctionTok{)}
      \FunctionTok{\{}\VariableTok{:error}\NormalTok{, \_}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}} \ConstantTok{Logger}\OperatorTok{.}\NormalTok{error}\FunctionTok{(}\StringTok{"Unable to parse msg: }\OtherTok{\#\{}\NormalTok{msg}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
    \KeywordTok{end}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Please make note that \texttt{type} is now prefixed with an underscore as we aren't using it at the moment.

The second important thing to note is that we are using \texttt{Logger} so it needs to be \texttt{require}d at the beginning of the module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
  \ImportTok{require} \ConstantTok{Logger}
\end{Highlighting}
\end{Shaded}

Before implementing the \texttt{process\_event/2} function we need to create a structure that will hold the incoming trade event's data.

Let's create a new directory called \texttt{binance} inside the \texttt{apps/streamer/lib/streamer/} and a new file called \texttt{trade\_event.ex} inside it.

Our new module will hold all the trade event's information but we will also use readable field names(you will see the incoming data below). We can start by writing a skeleton module code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/binance/trade\_event.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent} \KeywordTok{do}
  \KeywordTok{defstruct} \OtherTok{[]}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can refer to \href{https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md\#trade-streams}{Binance's docs} to get a list of fields:

\begin{verbatim}
{
  "e": "trade",     // Event type
  "E": 123456789,   // Event time
  "s": "BNBUSDT",   // Symbol
  "t": 12345,       // Trade ID
  "p": "0.001",     // Price
  "q": "100",       // Quantity
  "b": 88,          // Buyer order ID
  "a": 50,          // Seller order ID
  "T": 123456785,   // Trade time
  "m": true,        // Is the buyer the market maker?
  "M": true         // Ignore
}
\end{verbatim}

Let's copy them across and convert the comments to update the \texttt{defstruct} inside the\\
\texttt{Streamer.Binance.TradeEvent} module's struct to following:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/binance/trade\_event.ex}
  \KeywordTok{defstruct} \OtherTok{[}
    \VariableTok{:event\_type}\NormalTok{,}
    \VariableTok{:event\_time}\NormalTok{,}
    \VariableTok{:symbol}\NormalTok{,}
    \VariableTok{:trade\_id}\NormalTok{,}
    \VariableTok{:price}\NormalTok{,}
    \VariableTok{:quantity}\NormalTok{,}
    \VariableTok{:buyer\_order\_id}\NormalTok{,}
    \VariableTok{:seller\_order\_id}\NormalTok{,}
    \VariableTok{:trade\_time}\NormalTok{,}
    \VariableTok{:buyer\_market\_maker}
  \OtherTok{]}
\end{Highlighting}
\end{Shaded}

That's all for this struct, we can now get back to implementing the \texttt{process\_event/2} function inside the \texttt{Streamer.Binance} module. We will map every field of the response map to the \texttt{\%Streamer.Binance.TradeEvent} struct. A useful trick here would be to copy the list of fields once again from the struct and assign the incoming fields one by one.
Inside the header of the function, we will pattern match on event type(a field called ``e'' in the message) to confirm that indeed we received a trade event). In the end, the \texttt{process\_event/2} function should look as follows:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
  \KeywordTok{defp}\NormalTok{ process\_event}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\StringTok{"e"} \OperatorTok{=\textgreater{}} \StringTok{"trade"}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ event}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    trade\_event }\OperatorTok{=}\NormalTok{ \%}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}\FunctionTok{\{}
      \VariableTok{:event\_type} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"e"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:event\_time} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"E"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:symbol} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"s"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:trade\_id} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"t"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:price} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"p"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:quantity} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"q"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:buyer\_order\_id} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"b"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:seller\_order\_id} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"a"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:trade\_time} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"T"}\OtherTok{]}\NormalTok{,}
      \VariableTok{:buyer\_market\_maker} \OperatorTok{=\textgreater{}}\NormalTok{ event}\OtherTok{[}\StringTok{"m"}\OtherTok{]}
    \FunctionTok{\}}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{debug}\FunctionTok{(}
      \StringTok{"Trade event received "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{@}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{price}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We added the \texttt{Logger.debug/2} function to be able to see logs of incoming trade events.

\newpage

Lastly, before testing our implementation, let's add a nice interface to our \texttt{streamer} application that allows starting streaming:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer} \KeywordTok{do}
  \OtherTok{@moduledoc """}
\CommentTok{  Documentation for }\InformationTok{\textasciigrave{}Streamer\textasciigrave{}}\CommentTok{.}
\CommentTok{  }\OtherTok{"""}

  \KeywordTok{def}\NormalTok{ start\_streaming}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The final version of the \texttt{Streamer.Binance} module should look like \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/blob/chapter_01/apps/streamer/lib/streamer/binance.ex}{this}.

The last step will be to add the \texttt{Logger} configuration into the main \texttt{config/config.exs} file. We will set the \texttt{Logger} level to \texttt{:debug} for a moment to be able to see incoming trade events:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:logger}\NormalTok{,}
  \VariableTok{level:} \VariableTok{:debug}
\end{Highlighting}
\end{Shaded}

This finishes the implementation part of this chapter, we can now give our implementation a whirl using \texttt{iex}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"xrpusdt"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.251.0\textgreater{}\}}
\ExtensionTok{23:14:32.217} \PreprocessorTok{[}\SpecialStringTok{debug}\PreprocessorTok{]}\NormalTok{ Trade event received XRPUSDT@0.25604000}
\ExtensionTok{23:14:33.381} \PreprocessorTok{[}\SpecialStringTok{debug}\PreprocessorTok{]}\NormalTok{ Trade event received XRPUSDT@0.25604000}
\ExtensionTok{23:14:35.380} \PreprocessorTok{[}\SpecialStringTok{debug}\PreprocessorTok{]}\NormalTok{ Trade event received XRPUSDT@0.25605000}
\ExtensionTok{23:14:36.386} \PreprocessorTok{[}\SpecialStringTok{debug}\PreprocessorTok{]}\NormalTok{ Trade event received XRPUSDT@0.25606000}
\end{Highlighting}
\end{Shaded}

As we can see, the streamer is establishing a WebSocket connection with Binance's API and its receiving trade events. It decodes them from JSON to \texttt{\%Streamer.Binance.TradeEvent} struct and logs a compiled message. Also, our interface hides implementation details from the ``user'' of our application.

We will now flip the \texttt{Logger} level back to \texttt{info} so the output won't every incoming trade event:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:logger}\NormalTok{,}
  \VariableTok{level:} \VariableTok{:info}
\end{Highlighting}
\end{Shaded}

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_01}{GitHub}

\chapter{Create a naive trading strategy - a single trader process without supervision}\label{create-a-naive-trading-strategy---a-single-trader-process-without-supervision}

\section{Objectives}\label{objectives-1}

\begin{itemize}
\tightlist
\item
  create another supervised application inside the umbrella to store our trading strategy
\item
  define callbacks for events depending on the state of the trader
\item
  push events from the streamer app to the naive app
\end{itemize}

\section{Initialisation}\label{initialisation}

To develop our \emph{naive} strategy, we need to create a new supervised application inside our umbrella project:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ apps}
\ExtensionTok{mix}\NormalTok{ new naive }\AttributeTok{{-}{-}sup}
\end{Highlighting}
\end{Shaded}

We can now focus on creating a \texttt{trader} abstraction inside that newly created application. First we need to create a new file called \texttt{trader.ex} inside \texttt{apps/naive/lib/naive/}.

Let's start with a skeleton of a GenServer:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{GenServer}

  \ImportTok{require} \ConstantTok{Logger}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{args}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, args, }\VariableTok{name:} \VariableTok{:trader}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{args}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, args}\FunctionTok{\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Our module uses the \href{https://hexdocs.pm/elixir/master/GenServer.html\#content}{GenServer} behavior and to fulfill its ``contract'', we need to implement the \texttt{init/1} function. The \texttt{start\_link/1} function is a convention and it allows us to register the process with a name(it's a default function that the \texttt{Supervisor} will use when starting the Trader). We also add a \texttt{require\ Logger} as we will keep on logging across the module.

Next, let's model the state of our server:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:profit\_interval}\NormalTok{, }\VariableTok{:tick\_size}\OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}
      \VariableTok{:symbol}\NormalTok{,}
      \VariableTok{:buy\_order}\NormalTok{,}
      \VariableTok{:sell\_order}\NormalTok{,}
      \VariableTok{:profit\_interval}\NormalTok{,}
      \VariableTok{:tick\_size}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Our trader needs to know:

\begin{itemize}
\tightlist
\item
  what symbol does it need to trade (``symbol'' here is a pair of assets for example ``XRPUSDT'', which is XRP to/from USDT)
\item
  placed buy order (if any)
\item
  placed sell order (if any)
\item
  profit interval (what net profit \% we would like to achieve when buying and selling an asset - single trade cycle)
\item
  tick\_size (yes, I know, jargon warning. We can't ignore it here as it needs to be fetched from Binance and it's used to calculate a valid price. Tick size differs between symbols and it is the smallest acceptable price movement up or down. For example in the physical world tick size for USD is a single cent, you can't sell something for \$1.234, it's either \$1.23 or \$1.24 (a single cent difference between those is the tick size) - more info \href{https://www.investopedia.com/terms/t/tick.asp}{here}.
\end{itemize}

Our strategy won't work without symbol, profit\_interval nor tick\_size so we added them to the \texttt{@enforce\_keys} attribute. This will ensure that we won't create an invalid \texttt{\%State\{\}} without those values.

\newpage

As now we know that our GenServer will need to receive those details via args, we can update pattern matching in \texttt{start\_link/1} and \texttt{init/1} functions to confirm that passed values are indeed maps:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ args}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol, }\VariableTok{profit\_interval:}\NormalTok{ profit\_interval}\FunctionTok{\})} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we are already in the \texttt{init/1} function we will need to modify it to fetch the \texttt{tick\_size} for the passed symbol and initialize a fresh state:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol, }\VariableTok{profit\_interval:}\NormalTok{ profit\_interval}\FunctionTok{\})} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Initializing new trader for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

\NormalTok{    tick\_size }\OperatorTok{=}\NormalTok{ fetch\_tick\_size}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{,}
\NormalTok{     \%}\ConstantTok{State}\FunctionTok{\{}
       \VariableTok{symbol:}\NormalTok{ symbol,}
       \VariableTok{profit\_interval:}\NormalTok{ profit\_interval,}
       \VariableTok{tick\_size:}\NormalTok{ tick\_size}
     \FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We are uppercasing the symbol above as Binance's REST API only accepts uppercased symbols.

It's time to connect to Binance's REST API. The easiest way to do that will be to use the \href{https://github.com/dvcrn/binance.ex}{binance} module.

As previously, looking through the module's docs on Github, we can see the \texttt{Installation} section. We will follow the steps mentioned there, starting from adding \texttt{binance} to the deps in \texttt{/apps/naive/mix.exs}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/mix.ex}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:decimal}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:streamer}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Besides adding the \texttt{:binance} module, we also added \texttt{:decimal} and the \texttt{:streamer}. The \href{https://github.com/ericmj/decimal}{decimal} module will help us to calculate the buy and sell prices (without the decimal module we will face problems with the precision). Lastly, we need to include the \texttt{:streamer} application(created in the first chapter) as we will use the \texttt{\%Streamer.Binance.TradeEvent\{\}} struct inside the naive application.

We need to run \texttt{mix\ deps.get} to install our new deps.

We can now get back to the \texttt{trader} module and focus on fetching the tick size from Binance:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{defp}\NormalTok{ fetch\_tick\_size}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
    \OperatorTok{|\textgreater{}}\NormalTok{ elem}\FunctionTok{(}\DecValTok{1}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\VariableTok{:symbols}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]} \OperatorTok{==}\NormalTok{ symbol}\FunctionTok{))}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"filters"}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"PRICE\_FILTER"}\FunctionTok{))}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"tickSize"}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We are using \texttt{get\_exchange\_info/0} to fetch the list of symbols, which we will filter out to find the symbol that we are requested to trade. Tick size is defined as a \texttt{PRICE\_FILTER} filter. Here's the \href{https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md\#exchange-information}{link} to the documentation listing all keys in the result. In a nutshell, that's how the important parts of the result look like:

\begin{verbatim}
{:ok, %{
  ...
  symbols: [
    %{
      "symbol": "ETHUSDT",
      ...
      "filters": [
        ...
        %{"filterType: "PRICE_FILTER", "tickSize": tickSize, ...}
      ],
      ...
    }
  ]
}}
\end{verbatim}

\newpage

\section{How trading strategy will work?}\label{how-trading-strategy-will-work}

Our trader process has an internal state that will serve as an indicator of its step in the trade cycle. The following diagram shows 3 possible trader states that trader will progress through from left to right:

\begin{center}\includegraphics[width=1.4\linewidth,height=0.3\textheight]{images/chapter_02_01_trader_states} \end{center}

Our trader will be receiving trade events sequentially and take decisions
based on its own state and trade event's contents.

We will focus on a trader in 3 different states:

\begin{itemize}
\tightlist
\item
  a new trader without any orders
\item
  a trader with a buy order placed
\item
  a trader with a sell order placed.
\end{itemize}

\textbf{First state - A new trader}

The trader doesn't have any open orders which we can confirm by pattern matching on the \texttt{buy\_order} field from its state. From the incoming event, we can grab
the current price which we will use in the buy order that the trader will place.

\textbf{Second state - Buy order placed}

After placing a buy order, the trader's buy order will be pattern matched against
the incoming events' data to confirm the order got filled, otherwise ignoring it.
When a trade event matching the order id of the trader's buy order will arrive, it means that the buy order got filled(simplification - our order could be filled in two or more transactions but implementation in this chapter won't cater for this case, it will always assume that it got filled in a single transaction) and the trader can now place the sell order based on the expected profit and the buy\_price.

\textbf{Third state - Sell order placed}

Finally, in a very similar fashion to the previous state, the trader will be pattern matching to confirm that the incoming event has filled his sell order(matching order id), otherwise ignore it.
When a trade event matching the order id of trader's sell order will arrive, which means that the sell order got filled(simplification as described above) and the full trade cycle has ended and the trader can now exit.

\subsection{Implementation of the first scenario}\label{implementation-of-the-first-scenario}

Enough theory :) back to the editor, we will implement the first scenario. Before doing that let's alias Streamer's TradeEvent struct as we will rely on it heavily in pattern matching.

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}
\end{Highlighting}
\end{Shaded}

We are also aliasing the \texttt{\%Streamer.Binance.TradeEvent\{\}} struct as we will rely on it heavily in pattern matching.

To confirm that we are dealing with a ``new'' trader, we will pattern match on \texttt{buy\_order:\ nil} from its state:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_cast}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}\VariableTok{price:}\NormalTok{ price}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol, }\VariableTok{buy\_order:} \ConstantTok{nil}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    quantity }\OperatorTok{=} \StringTok{"100"} \CommentTok{\# \textless{}= Hardcoded until chapter 7}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Placing BUY order for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
      \ConstantTok{Binance}\OperatorTok{.}\NormalTok{order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"GTC"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ order}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

For the time being, we will keep the quantity hardcoded as this chapter will
get really long otherwise - don't worry, we will refactor this in one of the next chapters.

After confirming that we deal with the ``new'' trader(by pattern matching on the \texttt{buy\_order} field from the state), we can safely progress to placing a new buy order. We just need to remember to return the updated state as otherwise, the trader will go on a shopping spree, as every next incoming event will cause further buy orders(the above pattern match will continue to be successful).

\subsection{Implementation of the second scenario}\label{implementation-of-the-second-scenario}

With that out of the way, we can now move on to monitoring for an event that matches our buy order id and quantity to confirm that our buy order got filled:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_cast}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{buyer\_order\_id:}\NormalTok{ order\_id,}
          \VariableTok{quantity:}\NormalTok{ quantity}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{price:}\NormalTok{ buy\_price,}
            \VariableTok{order\_id:}\NormalTok{ order\_id,}
            \VariableTok{orig\_qty:}\NormalTok{ quantity}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{profit\_interval:}\NormalTok{ profit\_interval,}
          \VariableTok{tick\_size:}\NormalTok{ tick\_size}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    sell\_price }\OperatorTok{=}\NormalTok{ calculate\_sell\_price}\FunctionTok{(}\NormalTok{buy\_price, profit\_interval, tick\_size}\FunctionTok{)}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"Buy order filled, placing SELL order for "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{sell\_price}\OtherTok{\}}\StringTok{), quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
      \ConstantTok{Binance}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, sell\_price, }\StringTok{"GTC"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{sell\_order:}\NormalTok{ order}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We will implement calculating sell price in a separate function based on buy price, profit interval, and tick\_size.

Our pattern match will confirm that indeed our buy order got filled(order\_id and quantity matches) so we can now proceed with placing a sell order using calculated sell price and quantity retrieved from the buy order.
Again, don't forget to return the updated state as otherwise, the trader will keep on placing sell orders for every incoming event.

To calculate the sell price we will need to use precise math and that will require a custom module. We will use the \href{https://github.com/ericmj/decimal}{Decimal} module, so first, let's alias it at the top of the file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
\ImportTok{alias} \ConstantTok{Decimal}\NormalTok{, }\VariableTok{as:}\NormalTok{ D}
\end{Highlighting}
\end{Shaded}

Now to calculate the correct sell price, we can use the following formula which gets me pretty close to expected value:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{defp}\NormalTok{ calculate\_sell\_price}\FunctionTok{(}\NormalTok{buy\_price, profit\_interval, tick\_size}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    fee }\OperatorTok{=} \StringTok{"1.001"}

\NormalTok{    original\_price }\OperatorTok{=}\NormalTok{ D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}\NormalTok{buy\_price, fee}\FunctionTok{)}

\NormalTok{    net\_target\_price }\OperatorTok{=}
\NormalTok{      D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}
\NormalTok{        original\_price,}
\NormalTok{        D}\OperatorTok{.}\NormalTok{add}\FunctionTok{(}\StringTok{"1.0"}\NormalTok{, profit\_interval}\FunctionTok{)}
      \FunctionTok{)}

\NormalTok{    gross\_target\_price }\OperatorTok{=}\NormalTok{ D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}\NormalTok{net\_target\_price, fee}\FunctionTok{)}

\NormalTok{    D}\OperatorTok{.}\NormalTok{to\_string}\FunctionTok{(}
\NormalTok{      D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}
\NormalTok{        D}\OperatorTok{.}\NormalTok{div\_int}\FunctionTok{(}\NormalTok{gross\_target\_price, tick\_size}\FunctionTok{)}\NormalTok{,}
\NormalTok{        tick\_size}
      \FunctionTok{)}\NormalTok{,}
      \VariableTok{:normal}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

First, we will hardcode the fee to 0.1\% which we will refactor in one of the future chapters.

We started by calculating the \texttt{original\_price} which is the buy price together with the fee that we paid on top of it.

Next, we enlarge the originally paid price by profit interval to get \texttt{net\_target\_price}.

As we will be charged a fee for selling, we need to add the fee again on top of the net target sell price(we will call this amount the \texttt{gross\_target\_price}).

Next, we will use the tick size as Binance won't accept any prices that aren't divisible by the symbols' tick sizes so we need to ``normalize'' them on our side.

\subsection{Implementation of the third scenario}\label{implementation-of-the-third-scenario}

Getting back to handling incoming events, we can now add a clause for a trader that wants to confirm that his sell order was filled:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_cast}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{seller\_order\_id:}\NormalTok{ order\_id,}
          \VariableTok{quantity:}\NormalTok{ quantity}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{order\_id:}\NormalTok{ order\_id,}
            \VariableTok{orig\_qty:}\NormalTok{ quantity}
          \FunctionTok{\}}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trade finished, trader will now exit"}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:stop}\NormalTok{, }\VariableTok{:normal}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

When the sell order was successfully filled(confirmed by pattern matching above), there's nothing else to do for the trader, so it can return a tuple with \texttt{:stop} atom which will cause the trader process to terminate.

\subsection{Implementation fallback scenario}\label{implementation-fallback-scenario}

A final callback function that we will need to implement will just ignore all
incoming events as they were not matched by any of the previous pattern matches:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_cast}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{, state}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We need this callback for cases where our trader has an ``open'' order(not yet filled) and the incoming event has nothing to do with it, so it needs to be ignored.

\subsection{Updating the Naive interface}\label{updating-the-naive-interface}

Now we will update an interface of our \texttt{naive} application by modifying the Naive module to allow to send an event to the trader:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive.ex}
\KeywordTok{defmodule} \ConstantTok{Naive} \KeywordTok{do}
  \OtherTok{@moduledoc """}
\CommentTok{  Documentation for }\InformationTok{\textasciigrave{}Naive\textasciigrave{}}\CommentTok{.}
\CommentTok{  }\OtherTok{"""}
  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}

  \KeywordTok{def}\NormalTok{ send\_event}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ event}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{cast}\FunctionTok{(}\VariableTok{:trader}\NormalTok{, event}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We will use the fact that we have registered our trader process with a name to be able to cast a message to it.

\newpage

\subsection{Updating streamer app}\label{updating-streamer-app}

To glue our apps together for the time and keep things simple in this chapter we will modify the streamer process to simply call our new \texttt{Naive} interface directly by appending the following function call at the end of the \texttt{process\_event/1} function inside the \texttt{Streamer.Binance} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
  \KeywordTok{defp}\NormalTok{ process\_event}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\StringTok{"e"} \OperatorTok{=\textgreater{}} \StringTok{"trade"}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ event}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Naive}\OperatorTok{.}\NormalTok{send\_event}\FunctionTok{(}\NormalTok{trade\_event}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This creates a two-way link between the streamer and the naive app. In the next chapter, we will fix that as in the perfect world those apps shouldn't even be aware of existence of each other.

\subsection{Access details to Binance}\label{access-details-to-binance}

Inside the config of our umbrella project we create a new file \texttt{config/secrets.exs}. We will use this for our Binance account access details.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/secrets.exs}
\ImportTok{import} \ConstantTok{Config}

\NormalTok{config }\VariableTok{:binance}\NormalTok{,}
  \VariableTok{api\_key:} \StringTok{"YOUR{-}API{-}KEY{-}HERE"}\NormalTok{,}
  \VariableTok{secret\_key:} \StringTok{"YOUR{-}SECRET{-}KEY{-}HERE"}
\end{Highlighting}
\end{Shaded}

We don't want to check this file in, so we add it to our \texttt{.gitignore}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# .gitignore}
\ExtensionTok{config/secrets.exs}
\end{Highlighting}
\end{Shaded}

Finally, we update our main config file to include it using \href{https://hexdocs.pm/elixir/master/Config.html\#import_config/1}{import\_config}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}

\CommentTok{\# Import secrets file with Binance keys if it exists}
\ControlFlowTok{if} \ConstantTok{File}\OperatorTok{.}\NormalTok{exists?}\FunctionTok{(}\StringTok{"config/secrets.exs"}\FunctionTok{)} \KeywordTok{do}
\NormalTok{  import\_config}\FunctionTok{(}\StringTok{"secrets.exs"}\FunctionTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\emph{Important note}: To be able to run the below test and perform real trades, a Binance account is required with a balance of at least 20 USDT. In the 4th chapter, we will focus on creating a \texttt{BinanceMock} that will allow us to run our bot \emph{without} the requirement for a real Binance account. You don't need to test run it now if you don't need/want to have an account.

\subsection{Test run}\label{test-run}

Now it's time to give our implementation a run for its money. Once again, to be able to do that you will need to have at least 20 USDT tokens in your Binance's wallet and you will lose just under 0.5\% of your USDTs(as ``expected profit'' is below 0 to quickly showcase the full trade cycle) in the following test:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.Trader.start\_link}\KeywordTok{(}\ExtensionTok{\%\{symbol:} \StringTok{"XRPUSDT"}\NormalTok{, profit\_interval: }\StringTok{"{-}0.01"}\NormalTok{\}}\KeywordTok{)}
\ExtensionTok{13:45:30.648} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{ Initializing new trader for XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.355.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"xrpusdt"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.372.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}
\ExtensionTok{13:45:32.561} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{ Placing BUY order for XRPUSDT @ 0.25979000, quantity: 100}
\ExtensionTok{13:45:32.831} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{ Buy order filled, placing SELL order for XRPUSDT @ 0.2577, quantity: 100}
\ExtensionTok{13:45:33.094} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{ Trade finished, trader will now exit}
\end{Highlighting}
\end{Shaded}

After starting the IEx session, start the trader process with a map containing the symbol and profit interval. To be able to quickly test the full trade cycle we will pass a sub-zero profit interval instead of waiting for the price increase.

Next, we will start streaming on the same symbol, please be aware that this will cause an immediate reaction in the trader process.

We can see that our trader placed a buy order at 25.979c per XRP, it was filled in under 300ms, so then the trader placed a sell order at \textasciitilde25.77c
which was also filled in under 300ms. This way the trader finished the trade
cycle and the process can terminate.

That's it. \textbf{Congratulations!} You just made your first algorithmic trade and you should be proud of that! In the process of creating that algorithm, we touched on multiple topics including GenServer and depending on its state and external data (trade events) to perform different actions - this is a very common workflow that Elixir engineers are following and it's great to see it in action.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_02}{GitHub}

\chapter{Introduce PubSub as a communication method}\label{introduce-pubsub-as-a-communication-method}

\section{Objectives}\label{objectives-2}

\begin{itemize}
\tightlist
\item
  consider reasons why introducing a PubSub communication would be beneficial
\item
  implement the PubSub communication between the \texttt{Streamer.Binance} and the \texttt{Naive.Trader}(s)
\end{itemize}

\section{Design}\label{design}

First, let's look at the current situation:

\begin{center}\includegraphics[width=0.3\linewidth]{images/chapter_03_01_current_situation} \end{center}

We started with the Binance streamer calling the \texttt{send\_event/1} function on the \texttt{Naive} module. The \texttt{Naive} module then calls the trader process using the GenServer's \texttt{cast/2} function(via its registered name).

\newpage

The next step in the process of extending our trading strategy will be to scale it to run multiple \texttt{Naive.Trader} processes in parallel. To be able to do that we will need to remove the option to register the \texttt{trader} process with a name(as only one process can be registered under a single name).

\begin{center}\includegraphics[width=0.3\linewidth]{images/chapter_03_02_current_situation_failed} \end{center}

The second issue with that design was the fact that the \texttt{Streamer} needs to be aware of all processes that are interested in the streamed data and explicitly push that information to them.

To fix those issues we will invert the design and introduce a PubSub mechanism:

\begin{center}\includegraphics[width=0.25\linewidth]{images/chapter_03_03_phoenix_pubsub} \end{center}

The streamer will broadcast trade events to the PubSub topic and whatever is interested in that data, can subscribe to the topic and it will receive the broadcasted messages.
There's no coupling between the \texttt{Streamer} and \texttt{Naive} app anymore.

\newpage

We can now introduce multiple traders that will subscribe to the topic and they will receive messages from the PubSub:

\begin{center}\includegraphics[width=1\linewidth,height=0.35\textheight]{images/chapter_03_04_naive_trader_group} \end{center}

Going even further down the line we can picture that system could consist of other processes interested in the streamed data. An example of those could be a process that will save all streamed information to the database to be utilized in backtesting later on:

\begin{center}\includegraphics[width=1\linewidth,height=0.45\textheight]{images/chapter_03_05_other_services} \end{center}

\newpage

\section{Implementation}\label{implementation}

We will start by adding a \href{https://github.com/phoenixframework/phoenix_pubsub}{\texttt{Phoenix.PubSub}} library to both \texttt{Streamer} and \texttt{Naive} app(as both will be using it, \texttt{Streamer} app as a broadcaster and \texttt{Naive} app as a subscriber).

Scrolling down through its readme on GitHub we can see that we need to add \texttt{:phoenix\_pubsub} to list of dependencies:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/mix.exs \& /apps/naive/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:phoenix\_pubsub}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \OperatorTok{...}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Remember to place it so the list will keep alphabetical order. The second step in the readme says that we need to add PubSub as a child of our app. We need to decide where we will put it, \texttt{Streamer} sounds like a good starting point. We will modify the \texttt{/apps/streamer/lib/streamer/application.ex} module by appending the PubSub to it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}
        \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
        \VariableTok{name:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{, }\VariableTok{adapter\_name:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\ConstantTok{PG2}
      \FunctionTok{\}}
    \OtherTok{]}
    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We will add the \texttt{:adapter\_name} option to instruct PubSub to use \href{http://erlang.org/doc/man/pg.html}{\texttt{pg}} adapter, which will give us distributed process groups.

We will now modify the streamer to broadcast a message to PubSub topic instead of using the \texttt{Naive} module's function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
  \KeywordTok{defp}\NormalTok{ process\_event}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      trade\_event}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

Inside the trader on init we need to subscribe to the ``TRADE\_EVENTS'' PubSub channel:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}
    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Next, we need to convert all \texttt{handle\_cast} callbacks to \texttt{handle\_info} inside our \texttt{Trader} module as PubSub doesn't use \texttt{GenServer.cast/2} to send messages over to subscribers.

The final change will be to remove the \texttt{send\_event} function from the \texttt{Naive}
module as it's no longer required.

Our update is now finished so we can start an iex session to see how it works.

First, we will start a streamer process that will broadcast messages
to PubSub. Next, we will start trading on the same symbol. On init, the trader will subscribe to a PubSub channel and it will make a full trade cycle.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"xrpusdt"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.483.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.Trader.start\_link}\KeywordTok{(}\ExtensionTok{\%\{symbol:} \StringTok{"XRPUSDT"}\NormalTok{, profit\_interval: }\StringTok{"{-}0.01"}\NormalTok{\}}\KeywordTok{)}
\ExtensionTok{23:46:37.482} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.474.0\textgreater{}\}}
\ExtensionTok{23:46:55.179} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Placing BUY order for XRPUSDT @ 0.29462000, quantity: 100}
\ExtensionTok{23:46:55.783} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Buy order filled, placing SELL order for XRPUSDT @ 0.29225}\ErrorTok{)}\ExtensionTok{,}
\ExtensionTok{quantity:}\NormalTok{ 100.00000000}
\ExtensionTok{23:46:56.029} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trade finished, trader will now exit}
\end{Highlighting}
\end{Shaded}

This shows that the new trader process successfully subscribed to the PubSub, received the broadcasted messages, placed buy/sell orders, and terminated after the full trade cycle finished.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_03}{GitHub}

\chapter{Mock the Binance API}\label{mock-the-binance-api}

\section{Objectives}\label{objectives-3}

\begin{itemize}
\tightlist
\item
  design the binance mock application
\item
  create a new app
\item
  implement getting exchange info
\item
  implement placing buy and sell orders
\item
  implement callback for incoming trade events
\item
  upgrade trader and config
\item
  test the implementation
\end{itemize}

\section{Design}\label{design-1}

First, let's start with the current state:

\begin{center}\includegraphics[width=0.3\linewidth]{images/chapter_04_01_current_state} \end{center}

Currently, our trader is using the \texttt{Binance} module to place buy/sell
orders and get exchange info.
The \texttt{get\_exchange\_info/0} function doesn't require a Binance account as it's publicly available information so we can call the \texttt{Binance} lib directly from our module.
The remaining ones(buying/selling) require a \texttt{Binance} account and some coins/tokens inside its wallet. We need to mock those inside our module.

\newpage

We will update the trader to fetch the Binance's module name from the config:

\begin{center}\includegraphics[width=0.8\linewidth]{images/chapter_04_02_proposal} \end{center}

We will set up a config so it points to the Binance client to be used - either Binance or BinanceMock. Regards the BinanceMock itself it will have the same interface as the Binance module.
It will need to store both buy and sell orders and it will allow us to retrieve them. That will cover the REST functions but Binance also streams back trade events for those orders as they get filled, that's why BinanceMock will also need to broadcast fake events to the ``TRADE\_EVENTS:\#\{symbol\}'' PubSub topic so the trader will pick them up:

\begin{center}\includegraphics[width=0.8\linewidth]{images/chapter_04_03_proposal_pubsub} \end{center}

\newpage

When exactly should we broadcast those fake trade events? Well, the best thing
that we can do is make the \texttt{BinanceMock} process subscribe to the trade events stream and try to broadcast fake trade events whenever the price of orders would be matched:

\begin{center}\includegraphics[width=0.7\linewidth]{images/chapter_04_04_explenation} \end{center}

Starting from the arrow on the left, our naive strategy will place an order at the current price.
In this hypotetical scenario, the price raised for a moment after placing the buy order, so BinanceMock will keep on waiting until a trade event will get broadcasted from the PubSub with a price \emph{below} the buy order's price. At that moment BinanceMock will generate a fake trade event and broadcast it to the same PubSub topic.
The trader will get that event and assume that it came from the Binance and that the buy order got filled so it will place a sell order.
Similar to the buy order, BinanceMock will keep on waiting until a trade event will get broadcasted from the PubSub with the price \emph{above} the sell order's price. At that moment BinanceMock will generate a fake trade event and broadcast it to the same PubSub topic.

Enough theory for now, let's get our hands dirty with some coding.

\section{Create ``BinanceMock'' app}\label{create-binancemock-app}

We will start by creating a new supervised app called \texttt{BinanceMock}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps}
\ExtensionTok{$}\NormalTok{ mix new binance\_mock }\AttributeTok{{-}{-}sup}
\end{Highlighting}
\end{Shaded}

The next step will be to update the \texttt{BinanceMock} module to be a GenServer.

We will utilize:

\begin{itemize}
\tightlist
\item
  the \texttt{Decimal} module for comparing the prices
\item
  the \texttt{Logger} module to log
\end{itemize}

\newpage

As well as we will define internal \texttt{\%State\{\}} struct that will hold:

\begin{itemize}
\tightlist
\item
  map called \texttt{order\_books} for each traded symbol
\item
  list of symbols that mock subscribed to
\item
  last generated id - for consistent generating of unique ids for fake trade events
\end{itemize}

\texttt{order\_books} map will consist of \texttt{:"\#\{symbol\}} =\textgreater{} \texttt{\%OrderBook\{\}}. We will define the \texttt{\%OrderBook\{\}} struct as 3 lists \texttt{buy\_side}, \texttt{sell\_side} and \texttt{historical}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
\KeywordTok{defmodule} \ConstantTok{BinanceMock} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{GenServer}

  \ImportTok{alias} \ConstantTok{Decimal}\NormalTok{, }\VariableTok{as:}\NormalTok{ D}
  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}

  \ImportTok{require} \ConstantTok{Logger}

  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \KeywordTok{defstruct} \VariableTok{order\_books:}\NormalTok{ \%}\FunctionTok{\{\}}\NormalTok{, }\VariableTok{subscriptions:} \OtherTok{[]}\NormalTok{, }\VariableTok{fake\_order\_id:} \DecValTok{1}
  \KeywordTok{end}

  \KeywordTok{defmodule} \ConstantTok{OrderBook} \KeywordTok{do}
    \KeywordTok{defstruct} \VariableTok{buy\_side:} \OtherTok{[]}\NormalTok{, }\VariableTok{sell\_side:} \OtherTok{[]}\NormalTok{, }\VariableTok{historical:} \OtherTok{[]}
  \KeywordTok{end}  

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{\_args}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, }\ConstantTok{nil}\NormalTok{, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_args}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{State}\FunctionTok{\{\}\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Implement getting exchange info}\label{implement-getting-exchange-info}

As it was mentioned before, to retrieve exchange info we can just call Binance's function directly as its publicly available information:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ get\_exchange\_info }\KeywordTok{do}
    \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

\section{Implement placing buy and sell orders}\label{implement-placing-buy-and-sell-orders}

For buy and sell limit orders we will write a helper function as the logic is
the same for both order sides:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"GTC"}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    order\_limit}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"BUY"}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"GTC"}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    order\_limit}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"SELL"}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The ``order\_limit'' helper function will:

\begin{itemize}
\tightlist
\item
  generate a fake order based on symbol, quantity, price, and side
\item
  cast a message to the BinanceMock process to add the fake order
\item
  return with a tuple with \texttt{\%OrderResponse\{\}} struct to be consistent with the Binance module:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{defp}\NormalTok{ order\_limit}\FunctionTok{(}\NormalTok{symbol, quantity, price, side}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}
\NormalTok{      fake\_order }\OperatorTok{=}
\NormalTok{      generate\_fake\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        quantity,}
\NormalTok{        price,}
\NormalTok{        side}
      \FunctionTok{)}

    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{cast}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:add\_order}\NormalTok{, fake\_order}\FunctionTok{\}}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, convert\_order\_to\_order\_response}\FunctionTok{(}\NormalTok{fake\_order}\FunctionTok{)\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

We can now move on to implementing the \texttt{handle\_cast/2} callback to \texttt{:add\_order} to the order book for the symbol from the order.
It needs to subscribe to the \texttt{TRADE\_EVENTS:\#\{symbol\}} topic for the symbol from the order and add the order to the correct order book:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ handle\_cast}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:add\_order}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{order\_books:}\NormalTok{ order\_books,}
          \VariableTok{subscriptions:}\NormalTok{ subscriptions}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    new\_subscriptions }\OperatorTok{=}\NormalTok{ subscribe\_to\_topic}\FunctionTok{(}\NormalTok{symbol, subscriptions}\FunctionTok{)}
\NormalTok{    updated\_order\_books }\OperatorTok{=}\NormalTok{ add\_order}\FunctionTok{(}\NormalTok{order, order\_books}\FunctionTok{)}

    \FunctionTok{\{}
      \VariableTok{:noreply}\NormalTok{,}
\NormalTok{      \%}\FunctionTok{\{}
\NormalTok{        state}
        \OperatorTok{|} \VariableTok{order\_books:}\NormalTok{ updated\_order\_books,}
          \VariableTok{subscriptions:}\NormalTok{ new\_subscriptions}
      \FunctionTok{\}}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We will start with the implementation of the \texttt{subscribe\_to\_topic/2} function. We need to make sure that the symbol is uppercased as well as check have we already subscribed to that topic. Otherwise, we can safely use the PubSub module to subscribe to the \texttt{TRADE\_EVENTS:\#\{symbol\}} topic for this symbol.
We need to remember to append the symbol to the list of subscription and return the updated list:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{defp}\NormalTok{ subscribe\_to\_topic}\FunctionTok{(}\NormalTok{symbol, subscriptions}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
\NormalTok{    stream\_name }\OperatorTok{=} \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}

    \KeywordTok{case} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{member?}\FunctionTok{(}\NormalTok{subscriptions, symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{false} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{debug}\FunctionTok{(}\StringTok{"BinanceMock subscribing to }\OtherTok{\#\{}\NormalTok{stream\_name}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

        \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
          \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
\NormalTok{          stream\_name}
        \FunctionTok{)}

        \OtherTok{[}\NormalTok{symbol }\OperatorTok{|}\NormalTok{ subscriptions}\OtherTok{]}

\NormalTok{      \_ }\OperatorTok{{-}\textgreater{}}
\NormalTok{        subscriptions}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Next, time for implementation of the \texttt{add\_order} function. First, we need to get the order book for the symbol of the order. Depends on the side of the order we will update either the \texttt{buy\_side} or \texttt{sell\_side} list remembering that both sides are sorted. We are sorting them so we can easily grab all orders that should be filled whenever trade event arrived, this will become clearer as we will write a handle callback for incoming trade events:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{defp}\NormalTok{ add\_order}\FunctionTok{(}
\NormalTok{         \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ order,}
\NormalTok{         order\_books}
       \FunctionTok{)} \KeywordTok{do}
\NormalTok{    order\_book }\OperatorTok{=}
      \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}
\NormalTok{        order\_books,}
\NormalTok{        :}\StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{OrderBook}\FunctionTok{\{\}}
      \FunctionTok{)}

\NormalTok{    order\_book }\OperatorTok{=}
      \ControlFlowTok{if}\NormalTok{ order}\OperatorTok{.}\NormalTok{side }\OperatorTok{==} \StringTok{"SELL"} \KeywordTok{do}
        \ConstantTok{Map}\OperatorTok{.}\NormalTok{replace!}\FunctionTok{(}
\NormalTok{          order\_book,}
          \VariableTok{:sell\_side}\NormalTok{,}
          \OtherTok{[}\NormalTok{order }\OperatorTok{|}\NormalTok{ order\_book}\OperatorTok{.}\NormalTok{sell\_side}\OtherTok{]}
          \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{sort}\FunctionTok{(}\OperatorTok{\&}\NormalTok{D}\OperatorTok{.}\NormalTok{lt?}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{price, }\OperatorTok{\&}\DecValTok{2}\OperatorTok{.}\NormalTok{price}\FunctionTok{))}
        \FunctionTok{)}
      \ControlFlowTok{else}
        \ConstantTok{Map}\OperatorTok{.}\NormalTok{replace!}\FunctionTok{(}
\NormalTok{          order\_book,}
          \VariableTok{:buy\_side}\NormalTok{,}
          \OtherTok{[}\NormalTok{order }\OperatorTok{|}\NormalTok{ order\_book}\OperatorTok{.}\NormalTok{buy\_side}\OtherTok{]}
          \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{sort}\FunctionTok{(}\OperatorTok{\&}\NormalTok{D}\OperatorTok{.}\NormalTok{gt?}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{price, }\OperatorTok{\&}\DecValTok{2}\OperatorTok{.}\NormalTok{price}\FunctionTok{))}
        \FunctionTok{)}
      \KeywordTok{end}

    \ConstantTok{Map}\OperatorTok{.}\NormalTok{put}\FunctionTok{(}\NormalTok{order\_books, :}\StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{, order\_book}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we need to follow up and implement the functions that we referred to
previously - those are \texttt{generate\_fake\_order} and \texttt{convert\_order\_to\_order\_response}.

Starting with the \texttt{generate\_fake\_orders}, it's a function that takes a symbol, quantity, price, and side and based on those values returns a \texttt{Binance.Order} struct. To return the struct we will need to generate a unique id for each faked order - this is where \texttt{fake\_order\_id} will be used(callback implemented later). This way we will be able to run tests multiple times using the BinanceMock and always get the same ids:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{defp}\NormalTok{ generate\_fake\_order}\FunctionTok{(}\NormalTok{symbol, quantity, price, side}\FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}
\NormalTok{             is\_binary}\FunctionTok{(}\NormalTok{quantity}\FunctionTok{)} \KeywordTok{and}
\NormalTok{             is\_binary}\FunctionTok{(}\NormalTok{price}\FunctionTok{)} \KeywordTok{and}
             \FunctionTok{(}\NormalTok{side }\OperatorTok{==} \StringTok{"BUY"} \KeywordTok{or}\NormalTok{ side }\OperatorTok{==} \StringTok{"SELL"}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    current\_timestamp }\OperatorTok{=} \VariableTok{:os}\OperatorTok{.}\NormalTok{system\_time}\FunctionTok{(}\VariableTok{:millisecond}\FunctionTok{)}
\NormalTok{    order\_id }\OperatorTok{=} \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{call}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, }\VariableTok{:generate\_id}\FunctionTok{)}
\NormalTok{    client\_order\_id }\OperatorTok{=} \VariableTok{:crypto}\OperatorTok{.}\NormalTok{hash}\FunctionTok{(}\VariableTok{:md5}\NormalTok{, }\StringTok{"}\OtherTok{\#\{}\NormalTok{order\_id}\OtherTok{\}}\StringTok{"}\FunctionTok{)} \OperatorTok{|\textgreater{}} \ConstantTok{Base}\OperatorTok{.}\NormalTok{encode16}\FunctionTok{()}

    \ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
      \VariableTok{symbol:}\NormalTok{ symbol,}
      \VariableTok{order\_id:}\NormalTok{ order\_id,}
      \VariableTok{client\_order\_id:}\NormalTok{ client\_order\_id,}
      \VariableTok{price:}\NormalTok{ price,}
      \VariableTok{orig\_qty:}\NormalTok{ quantity,}
      \VariableTok{executed\_qty:} \StringTok{"0.00000000"}\NormalTok{,}
      \VariableTok{cummulative\_quote\_qty:} \StringTok{"0.00000000"}\NormalTok{,}
      \VariableTok{status:} \StringTok{"NEW"}\NormalTok{,}
      \VariableTok{time\_in\_force:} \StringTok{"GTC"}\NormalTok{,}
      \VariableTok{type:} \StringTok{"LIMIT"}\NormalTok{,}
      \VariableTok{side:}\NormalTok{ side,}
      \VariableTok{stop\_price:} \StringTok{"0.00000000"}\NormalTok{,}
      \VariableTok{iceberg\_qty:} \StringTok{"0.00000000"}\NormalTok{,}
      \VariableTok{time:}\NormalTok{ current\_timestamp,}
      \VariableTok{update\_time:}\NormalTok{ current\_timestamp,}
      \VariableTok{is\_working:} \ConstantTok{true}
    \FunctionTok{\})}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

We can now focus on converting the \texttt{Binance.Order} to the \texttt{Binance.OrderResponse} struct. As \texttt{Binance.Order} struct contains almost all of the same fields that the \texttt{Binance.OrderResponse} struct, we can use \texttt{struct} function without exclamation mark to ignore all additional fields. The only field that has a different name is \texttt{transact\_time} field which is called \texttt{time} in the \texttt{Binance.Order} struct - we can fix that separately:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{defp}\NormalTok{ convert\_order\_to\_order\_response}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\FunctionTok{\{}
\NormalTok{      struct}\FunctionTok{(}
        \ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\NormalTok{,}
\NormalTok{        order }\OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{to\_list}\FunctionTok{()}
      \FunctionTok{)}
      \OperatorTok{|} \VariableTok{transact\_time:}\NormalTok{ order}\OperatorTok{.}\NormalTok{time}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The last function to finish support for placing buy and sell orders is to add a callback that will iterate the fake order id and return it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \VariableTok{:generate\_id}\NormalTok{,}
\NormalTok{        \_from,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}\VariableTok{fake\_order\_id:}\NormalTok{ id}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, id }\OperatorTok{+} \DecValTok{1}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{fake\_order\_id:}\NormalTok{ id }\OperatorTok{+} \DecValTok{1}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Implement order retrival}\label{implement-order-retrival}

We can now move on to retrieving the orders. First, we need to add an interface function that will call our BinanceMock GenServer:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ get\_order}\FunctionTok{(}\NormalTok{symbol, time, order\_id}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{call}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:get\_order}\NormalTok{, symbol, time, order\_id}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

The callback itself is pretty straightforward. We will need to get an order book for the passed symbol. As we don't know the order's side, we will concat all 3 lists(buy\_side, sell\_side, and historical) and try to find an order that will
match passed symbol, time, and order\_id:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:get\_order}\NormalTok{, symbol, time, order\_id}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_from,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}\VariableTok{order\_books:}\NormalTok{ order\_books}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    order\_book }\OperatorTok{=}
      \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}
\NormalTok{        order\_books,}
\NormalTok{        :}\StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{OrderBook}\FunctionTok{\{\}}
      \FunctionTok{)}

\NormalTok{    result }\OperatorTok{=}
      \FunctionTok{(}\NormalTok{order\_book}\OperatorTok{.}\NormalTok{buy\_side }\OperatorTok{++}
\NormalTok{         order\_book}\OperatorTok{.}\NormalTok{sell\_side }\OperatorTok{++}
\NormalTok{         order\_book}\OperatorTok{.}\NormalTok{historical}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}
        \OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{symbol }\OperatorTok{==}\NormalTok{ symbol }\KeywordTok{and}
            \OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{time }\OperatorTok{==}\NormalTok{ time }\KeywordTok{and}
            \OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{order\_id }\OperatorTok{==}\NormalTok{ order\_id}\FunctionTok{)}
      \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, result}\FunctionTok{\}}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Implement callback for incoming trade events}\label{implement-callback-for-incoming-trade-events}

Finally, we need to handle incoming trade events(streamed from the PubSub topic). We need to implement a callback that will:

\begin{itemize}
\tightlist
\item
  get the order book for the symbol from the trade event
\item
  use the \texttt{take\_while/2} function on the buy orders with prices that are \emph{greater} than the current price - we can update their status to filled.
\item
  use the \texttt{take\_while/2} function again, this time to sell orders with prices \emph{less} than the current price, we will also update their statuses to filled.
\item
  concat both lists of filled orders, convert them to trade events, and broadcast them to the PubSub's TRADE\_EVENTS topic.
\item
  remove the filled orders from buy and sell lists and put them into the historical list.
\end{itemize}

Here we can clearly see the benefit of sorting the lists, we can use functions like \texttt{take\_while/2} and \texttt{drop/2} instead of \texttt{filter/2}
and \texttt{reject/2}(later ones will go through whole lists which could become a bottleneck when multiple open orders would be active):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event,}
\NormalTok{        \%}\FunctionTok{\{}\VariableTok{order\_books:}\NormalTok{ order\_books}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    order\_book }\OperatorTok{=}
      \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}
\NormalTok{        order\_books,}
\NormalTok{        :}\StringTok{"}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{OrderBook}\FunctionTok{\{\}}
      \FunctionTok{)}

\NormalTok{    filled\_buy\_orders }\OperatorTok{=}
\NormalTok{      order\_book}\OperatorTok{.}\NormalTok{buy\_side}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{take\_while}\FunctionTok{(}\OperatorTok{\&}\NormalTok{D}\OperatorTok{.}\NormalTok{lt?}\FunctionTok{(}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{price, }\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{price}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\ConstantTok{Map}\OperatorTok{.}\NormalTok{replace!}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\VariableTok{:status}\NormalTok{, }\StringTok{"FILLED"}\FunctionTok{))}

\NormalTok{    filled\_sell\_orders }\OperatorTok{=}
\NormalTok{      order\_book}\OperatorTok{.}\NormalTok{sell\_side}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{take\_while}\FunctionTok{(}\OperatorTok{\&}\NormalTok{D}\OperatorTok{.}\NormalTok{gt?}\FunctionTok{(}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{price, }\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{price}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\ConstantTok{Map}\OperatorTok{.}\NormalTok{replace!}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\VariableTok{:status}\NormalTok{, }\StringTok{"FILLED"}\FunctionTok{))}

    \FunctionTok{(}\NormalTok{filled\_buy\_orders }\OperatorTok{++}\NormalTok{ filled\_sell\_orders}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{convert\_order\_to\_event}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, trade\_event}\OperatorTok{.}\NormalTok{event\_time}\FunctionTok{))}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{each}\FunctionTok{(}\OperatorTok{\&}\NormalTok{broadcast\_trade\_event}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}

\NormalTok{    remaining\_buy\_orders }\OperatorTok{=}
\NormalTok{      order\_book}\OperatorTok{.}\NormalTok{buy\_side}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{drop}\FunctionTok{(}\NormalTok{length}\FunctionTok{(}\NormalTok{filled\_buy\_orders}\FunctionTok{))}

\NormalTok{    remaining\_sell\_orders }\OperatorTok{=}
\NormalTok{      order\_book}\OperatorTok{.}\NormalTok{sell\_side}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{drop}\FunctionTok{(}\NormalTok{length}\FunctionTok{(}\NormalTok{filled\_sell\_orders}\FunctionTok{))}

\NormalTok{    order\_books }\OperatorTok{=}
      \ConstantTok{Map}\OperatorTok{.}\NormalTok{replace!}\FunctionTok{(}
\NormalTok{        order\_books,}
\NormalTok{        :}\StringTok{"}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{        \%}\FunctionTok{\{}
          \VariableTok{buy\_side:}\NormalTok{ remaining\_buy\_orders,}
          \VariableTok{sell\_side:}\NormalTok{ remaining\_sell\_orders,}
          \VariableTok{historical:}
\NormalTok{            filled\_buy\_orders }\OperatorTok{++}
\NormalTok{              filled\_sell\_orders }\OperatorTok{++}
\NormalTok{              order\_book}\OperatorTok{.}\NormalTok{historical}
        \FunctionTok{\}}
      \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{order\_books:}\NormalTok{ order\_books}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Inside the callback we referred to two new functions that we will implement now(\texttt{convert\_order\_to\_event} and \texttt{broadcast\_trade\_event}).

Starting with the \texttt{convert\_order\_to\_event} function, it will simply return a new \texttt{Streamer.Binance.TradeEvent} struct filled with data. An interesting thing to observe here is that again all values are predictable and function will return the same values for the same input - this will become beneficial for backtesting over and over again and comparing the behavior between runs:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{defp}\NormalTok{ convert\_order\_to\_event}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order, time}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
      \VariableTok{event\_type:}\NormalTok{ order}\OperatorTok{.}\NormalTok{type,}
      \VariableTok{event\_time:}\NormalTok{ time }\OperatorTok{{-}} \DecValTok{1}\NormalTok{,}
      \VariableTok{symbol:}\NormalTok{ order}\OperatorTok{.}\NormalTok{symbol,}
      \VariableTok{trade\_id:} \ConstantTok{Integer}\OperatorTok{.}\NormalTok{floor\_div}\FunctionTok{(}\NormalTok{time, }\DecValTok{1000}\FunctionTok{)}\NormalTok{,}
      \VariableTok{price:}\NormalTok{ order}\OperatorTok{.}\NormalTok{price,}
      \VariableTok{quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{orig\_qty,}
      \VariableTok{buyer\_order\_id:}\NormalTok{ order}\OperatorTok{.}\NormalTok{order\_id,}
      \VariableTok{seller\_order\_id:}\NormalTok{ order}\OperatorTok{.}\NormalTok{order\_id,}
      \VariableTok{trade\_time:}\NormalTok{ time }\OperatorTok{{-}} \DecValTok{1}\NormalTok{,}
      \VariableTok{buyer\_market\_maker:} \ConstantTok{false}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Broadcasting trade events to PubSub will be the last function that will finish
the implementation of \texttt{BinanceMock} for now. It's safe to assume that the incoming
symbol will be uppercased as it comes from the exchange (the symbol is part of the topic name which is case-sensitive):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{defp}\NormalTok{ broadcast\_trade\_event}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      trade\_event}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That finishes the \texttt{BinanceMock} implementation. Now, we need to add it to
the children list of the application so it starts automatically:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock/application.ex}
\OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{BinanceMock}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}
    \OtherTok{]}
    \OperatorTok{...}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Upgrade trader and config}\label{upgrade-trader-and-config}

We can move on to the \texttt{Naive.Trader} module where we will add an attribute that will point to the Binance client dictated by config:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OtherTok{@binance\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

We need to replace all direct calls to the \texttt{Binance} module for calls to the \texttt{@binance\_client} attribute inside the \texttt{Naive.Trader}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}

\OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_buy}\FunctionTok{(}
\OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_sell}
\OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

As the \texttt{Naive.Trader} is now relying on the config to specify which Binance client should they use, we need to add it to the config:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}

\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock}
\end{Highlighting}
\end{Shaded}

The last modification to our system will be to modify the \texttt{mix.exs} of the \texttt{binance\_mock} app to list all deps required for it to work:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/mix.exs}
\OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:decimal}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:phoenix\_pubsub}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:streamer}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We also add \texttt{:binance\_mock} to the list of deps of the \texttt{naive} app(as the Naive app will use either \texttt{Binance} or \texttt{BinanceMock} to ``trade''):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/mix.exs}
\OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:binance\_mock}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}
      \OperatorTok{...}
    \OtherTok{]}
  \KeywordTok{end}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

\section{Test the implementation}\label{test-the-implementation}

We can now see the BinanceMock in action. First, we will start an iex session and double-check that the BinanceMock process is alive.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Process.whereis}\KeywordTok{(}\ExtensionTok{BinanceMock}\KeywordTok{)}
\CommentTok{\#PID\textless{}0.320.0\textgreater{} \# \textless{}{-} confirms that BinanceMock process is alive}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"xrpusdt"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.332.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.Trader.start\_link}\KeywordTok{(}
\ExtensionTok{\%\{symbol:} \StringTok{"XRPUSDT"}\NormalTok{, profit\_interval: }\StringTok{"{-}0.001"}\NormalTok{\}}
\KeywordTok{)}
\ExtensionTok{00:19:39.232} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.318.0\textgreater{}\}}
\ExtensionTok{00:19:40.826} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Placing BUY order for XRPUSDT @ 0.29520000, quantity: 100}
\ExtensionTok{00:19:44.569} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Buy order filled, placing SELL order for XRPUSDT @ 0.29549}\ErrorTok{)}\ExtensionTok{,}
\ExtensionTok{quantity:}\NormalTok{ 100.0}
\ExtensionTok{00:20:09.391} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trade finished, trader will now exit}
\end{Highlighting}
\end{Shaded}

As config already points to it so we can continue as previously by starting the streaming and trading on the symbol. The trader is using the \texttt{BinanceMock} and it looks like everything works as it would be dealing with a real exchange.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_04}{GitHub}

\chapter{Enable parallel trading on multiple symbols}\label{enable-parallel-trading-on-multiple-symbols}

\section{Objectives}\label{objectives-4}

\begin{itemize}
\tightlist
\item
  design supervision tree that will allow trading using multiple traders in parallel per symbol
\item
  update application supervisor
\item
  implement \texttt{Naive.Server}
\item
  implement \texttt{Naive.SymbolSupervisor}
\end{itemize}

\section{Introduction - architectural design}\label{introduction---architectural-design}

In the second chapter, we implemented a basic trader which goes through the trading cycle. Inside the iEx session, we were starting the \texttt{Naive.Trader} process using the \texttt{start\_link/1} function:

\begin{center}\includegraphics[width=0.25\linewidth]{images/chapter_05_01_current_state} \end{center}

The \texttt{GenServer.start\_link/3} creates a link between IEx's process and new \texttt{Naive.Trader} process. Whenever a trader process terminates(either finishes the trading cycle or there was an error), a new one won't get started as there's no supervision at all.

We can do much better than that with a little bit of help from Elixir and OTP.

\newpage

Let's introduce a supervisor above our trader process. It will start a new trader process whenever the previous one finished/crashed:

\begin{center}\includegraphics[width=0.25\linewidth]{images/chapter_05_02_supervise_the_trader} \end{center}

This looks much better but there are few problems with it. So, when the trader will start to place orders it will be in \emph{some} state(it will hold buy/sell orders) that the supervisor won't be aware of. In case of trader crashing, the supervisor will start a new trader \emph{without} any knowledge of possibly placed orders or any other information from the state(it will be started with a ``fresh'' state).

To fix that we need to keep a copy of the trader's state outside of the trader process - that's why we will introduce a new server called \texttt{Naive.Leader} that will keep track of traders' data:

\begin{center}\includegraphics[width=0.7\linewidth]{images/chapter_05_03_leader_added} \end{center}

The \texttt{Naive.Leader} will become the interface to start new \emph{traders}. It will call the \texttt{start\_child/1} function of the Supervisor, then consequently \texttt{DynamicTraderSupervisor} will call the \texttt{start\_link/1} function of our \texttt{Naive.Trader} module.

We can also see that our \texttt{Naive.Trader}'s are now started with the \texttt{temporary\ restart} option. Setting this option will disallow the Supervisor from restarting the traders on its own. The responsibility of restarting traders will now be shifted to the leader. The leader will monitor the traders and restart them to a correct state when any crashes.

As trader state will get updated, it will notify the leader about its new state to be stored. This way whenever a trader process would crash, the leader will be able to start a new trader process with the last known state.

This setup will also allow us to start and supervise multiple traders for a single symbol which our naive strategy will require in the future(next chapter).

\newpage

For each symbol that we will be trading on we need the above trio of services(Leader + DynamicTraderSupervisor + Trader), to effectively initialize(and supervise) them we will add an \texttt{Naive.SymbolSupervisor} that will start both \texttt{Naive.Leader} and \texttt{Naive.Dynamic}:

\begin{center}\includegraphics[width=0.4\linewidth]{images/chapter_05_04_symbol_sup} \end{center}

We will need multiple symbol supervisors, one for each symbol that we would like to trade on. As with traders, they will be dynamically started on demand, this should give us a hint that we need another dynamic supervisor that will supervise symbol supervisors and will be the direct child of our \texttt{Naive.Supervisor}(\texttt{Naive.Application} module):

\begin{center}\includegraphics[width=0.7\linewidth]{images/chapter_05_05_full} \end{center}

You could ask yourself why we don't need some additional server to track which symbols are traded at the moment (in the same way as \texttt{Naive.Leader} tracks \texttt{Naive.Trader}s). The answer is that we don't need to track them as we register all \texttt{Naive.SymbolSupervisor}s with a name containing a symbol that they trade on. This way we will always be able to refer to them by registered name instead of PIDs/refs.

Here's what happens starting from the top of the graph:

\begin{itemize}
\tightlist
\item
  the \texttt{Naive.Application} is our top-level application's supervisor for the \texttt{naive} app, it was auto-generated as a part of the \texttt{naive} app
\item
  it has a single child \texttt{Naive.DynamicSymbolSupervisor}, which has strategy one\_for\_one and all of its children are \texttt{Naive.SymbolSupervisor}s
\item
  \texttt{Naive.SymbolSupervisor} process will start two further children: the \texttt{Naive.Leader} and \texttt{DynamicTraderSupervisor}, both created on init
\item
  the \texttt{Naive.Leader} will ask \texttt{DynamicTraderSupervisor} to start the \texttt{Naive.Trader} child process(es)
\end{itemize}

This can be a little bit confusing at the moment but it will get a lot easier
as we will write the code. Let's get to it!

\subsection{Update application supervisor}\label{update-application-supervisor}

Let's start by adding a \texttt{Naive.DynamicSymbolSupervisor} and a server to the children list of the \texttt{Naive.Application} supervisor:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}
        \ConstantTok{DynamicSupervisor}\NormalTok{,}
        \VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{,}
        \VariableTok{name:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}
      \FunctionTok{\}}
    \OtherTok{]}

    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Add interface method}\label{add-interface-method}

We will now add an interface method to the \texttt{Naive} module that will instruct\\
\texttt{Naive.DynamicSymbolSupervisor} to start \texttt{Naive.SymbolSupervisor}(to be implemented next) as its child:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive.ex}
  \KeywordTok{def}\NormalTok{ start\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_pid}\FunctionTok{\}} \OperatorTok{=}
      \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{,}
        \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\NormalTok{, symbol}\FunctionTok{\}}
      \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{\texorpdfstring{Implement \texttt{Naive.SymbolSupervisor}}{Implement Naive.SymbolSupervisor}}\label{implement-naive.symbolsupervisor}

Next, time for the \texttt{Naive.SymbolSupervisor}, the first step will be to create a file called \texttt{symbol\_supervisor.ex} inside \texttt{apps/naive/lib/naive} directory. There's no point in using the \href{https://hexdocs.pm/elixir/master/DynamicSupervisor.html}{DynamicSupervisor}, as we know the children that we would like to start automatically on init. This is a full implementation of the supervisor and it's a simple as just listing child processes inside the init function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/symbol\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Supervisor}

  \ImportTok{require} \ConstantTok{Logger}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
\NormalTok{      symbol,}
      \VariableTok{name:}\NormalTok{ :}\StringTok{"}\OtherTok{\#\{}\ConstantTok{\_\_MODULE\_\_}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting new supervision tree to trade on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}
      \OtherTok{[}
        \FunctionTok{\{}
          \ConstantTok{DynamicSupervisor}\NormalTok{,}
          \VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{,}
          \VariableTok{name:}\NormalTok{ :}\StringTok{"Naive.DynamicTraderSupervisor{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
        \FunctionTok{\}}\NormalTok{,}
        \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\NormalTok{, symbol}\FunctionTok{\}}
      \OtherTok{]}\NormalTok{,}
      \VariableTok{strategy:} \VariableTok{:one\_for\_all}
    \FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

It's advised to keep supervisor processes slim.

We registered the \texttt{Naive.SymbolSupervisor} processes with names, which will help us understand the supervision tree inside the observer GUI(it will also allow us to stop those supervisors in the future).

\newpage

As mentioned previously whenever either the \texttt{Naive.Leader} or \texttt{Naive.DynamicSymbolSupervisor-\#\{symbol\}} would crash we would like to kill the other child process as we won't be able to recover the state - it's just easier to init both again.

\section{\texorpdfstring{Implement \texttt{Naive.Leader}}{Implement Naive.Leader}}\label{implement-naive.leader}

It's time for the \texttt{Naive.Leader} module, again, the first step will be to create a file called the \texttt{leader.ex} inside \texttt{apps/naive/lib/naive} directory. At this moment it will be a skeleton GenServer implementation just to get the code to compile:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{GenServer}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
\NormalTok{      symbol,}
      \VariableTok{name:}\NormalTok{ :}\StringTok{"}\OtherTok{\#\{}\ConstantTok{\_\_MODULE\_\_}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment we have half of the supervision tree working so we can give it
a spin in iex. Using the observer we will be able to see all processes created when the \texttt{start\_trading/1} function gets called:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ :observer.start}\KeywordTok{()}
\end{Highlighting}
\end{Shaded}

\newpage

The above function will open a new window looking as follows:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_05_06_new_observer} \end{center}

To clearly see the supervision tree we will click on the ``Applications'' tab at the top - the following tree of processes will be shown on the left:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_05_07_observer_app_list} \end{center}

If any other process tree is visible, go to the list on the left and select the \texttt{naive} application.

The \texttt{Naive.Supervisor} is our \texttt{Naive.Application} module(you can confirm that by checking the \texttt{name} option send to the \texttt{start\_link} function inside the module). It starts the \texttt{Naive.DynamicSymbolSupervisor}.

We can now call the \texttt{Naive.start\_trading/1} function couple time to see how the tree will look like with additional processes(go back to the \texttt{iex} session):

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"adausdt"}\KeywordTok{)}
\ExtensionTok{23:14:40.974} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on ADAUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.340.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"xrpusdt"}\KeywordTok{)}
\ExtensionTok{23:15:12.117} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.345.0\textgreater{}\}}
\end{Highlighting}
\end{Shaded}

We can see that two new branches were created:

\begin{itemize}
\tightlist
\item
  \texttt{SymbolSupervisor-ADAUSDT}
\item
  \texttt{SymbolSupervisor-XRPUSDT}
\end{itemize}

Each of them contains a \texttt{Naive.Leader} and \texttt{DynamicTraderSupervisor}.

\subsection{\texorpdfstring{Updating the \texttt{leader} module}{Updating the leader module}}\label{updating-the-leader-module}

Let's jump back to extending a leader implementation to get those traders running.

We will introduce a leader's state that will consist of a symbol, setting, and a list of traders' data. Trader data will hold PID, ref, and state of the trader:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}

  \ImportTok{require} \ConstantTok{Logger}

  \OtherTok{@binance\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}

  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \KeywordTok{defstruct} \VariableTok{symbol:} \ConstantTok{nil}\NormalTok{,}
              \VariableTok{settings:} \ConstantTok{nil}\NormalTok{,}
              \VariableTok{traders:} \OtherTok{[]}
  \KeywordTok{end}

  \KeywordTok{defmodule} \ConstantTok{TraderData} \KeywordTok{do}
    \KeywordTok{defstruct} \VariableTok{pid:} \ConstantTok{nil}\NormalTok{,}
              \VariableTok{ref:} \ConstantTok{nil}\NormalTok{,}
              \VariableTok{state:} \ConstantTok{nil}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We will use a \texttt{handle\_continue} callback which was introduced in Erlang 21 to
initialize the leader asynchronously. To do that we will return a tuple starting with a \texttt{:continue} atom from inside the init function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{,}
\NormalTok{      \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{symbol:}\NormalTok{ symbol}
      \FunctionTok{\}}\NormalTok{, }\FunctionTok{\{}\VariableTok{:continue}\NormalTok{, }\VariableTok{:start\_traders}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The \texttt{Naive.Leader} will fetch symbol settings and based on them, it will build the state for traders so they don't need to fetch the same settings again. It will also start as many traders there were set under chunks key in setting:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# below init()}
  \KeywordTok{def}\NormalTok{ handle\_continue}\FunctionTok{(}\VariableTok{:start\_traders}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    settings }\OperatorTok{=}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
\NormalTok{    trader\_state }\OperatorTok{=}\NormalTok{ fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)}
\NormalTok{    traders }\OperatorTok{=} \KeywordTok{for}\NormalTok{ \_i }\OperatorTok{\textless{}{-}} \DecValTok{1}\OperatorTok{..}\NormalTok{settings}\OperatorTok{.}\NormalTok{chunks,}
              \VariableTok{do:}\NormalTok{ start\_new\_trader}\FunctionTok{(}\NormalTok{trader\_state}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{settings:}\NormalTok{ settings, }\VariableTok{traders:}\NormalTok{ traders}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Fetching symbol settings will be hardcoded for time being to keep this chapter focused. We will also move the code responsible for fetching tick
size from the \texttt{Naive.Trader} to the \texttt{Naive.Leader} and hardcode the rest of the values:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    tick\_size }\OperatorTok{=}\NormalTok{ fetch\_tick\_size}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

\NormalTok{    \%}\FunctionTok{\{}
      \VariableTok{symbol:}\NormalTok{ symbol,}
      \VariableTok{chunks:} \DecValTok{1}\NormalTok{,}
      \CommentTok{\# {-}0.12\% for quick testing}
      \VariableTok{profit\_interval:} \StringTok{"{-}0.0012"}\NormalTok{,}
      \VariableTok{tick\_size:}\NormalTok{ tick\_size}
    \FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ fetch\_tick\_size}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
    \OperatorTok{|\textgreater{}}\NormalTok{ elem}\FunctionTok{(}\DecValTok{1}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\VariableTok{:symbols}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]} \OperatorTok{==}\NormalTok{ symbol}\FunctionTok{))}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"filters"}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"PRICE\_FILTER"}\FunctionTok{))}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"tickSize"}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

Additionally, we need to create a helper method that we used inside the \texttt{handle\_continue/2} callback called \texttt{fresh\_trader\_state/1}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# place this one above the \textasciigrave{}fetch\_symbol\_settings\textasciigrave{} function}
  \KeywordTok{defp}\NormalTok{ fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    struct}\FunctionTok{(}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\NormalTok{, settings}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Starting a new trader isn't any different from the code that we already wrote to start a new \texttt{Naive.SymbolSupervisor}. We need to call the \texttt{DynamicSupervisor.start\_child/2} function and start to monitor the process:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{defp}\NormalTok{ start\_new\_trader}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, pid}\FunctionTok{\}} \OperatorTok{=}
      \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
\NormalTok{        :}\StringTok{"Naive.DynamicTraderSupervisor{-}}\OtherTok{\#\{}\NormalTok{state}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
        \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}\NormalTok{, state}\FunctionTok{\}}
      \FunctionTok{)}

\NormalTok{    ref }\OperatorTok{=} \ConstantTok{Process}\OperatorTok{.}\NormalTok{monitor}\FunctionTok{(}\NormalTok{pid}\FunctionTok{)}

\NormalTok{    \%}\ConstantTok{TraderData}\FunctionTok{\{}\VariableTok{pid:}\NormalTok{ pid, }\VariableTok{ref:}\NormalTok{ ref, }\VariableTok{state:}\NormalTok{ state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Updating the \texttt{Naive.Trader} module}{Updating the Naive.Trader module}}\label{updating-the-naive.trader-module}

Now we can update the \texttt{Naive.Trader}, first, we will set restart to be temporary to avoid restarting it by the \texttt{Naive.DynamicTraderSupervisor}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{GenServer}\NormalTok{, }\VariableTok{restart:} \VariableTok{:temporary}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Next, we will update the \texttt{start\_link/1} and \texttt{init/1} functions to take the state instead of building it from args:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{\%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, state}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\%}\ConstantTok{State}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Initializing new trader for symbol(}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{)"}\FunctionTok{)}

    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Next, we need to update two \texttt{handle\_info/2} callbacks that change the state of the \texttt{Naive.Trader} process(when placing buy order and when placing sell order). They will need to notify the \texttt{Naive.Leader} that the state is changed before returning it:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
        \OperatorTok{...}
      \FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Placing buy order (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{@}\OtherTok{\#\{}\NormalTok{price}\OtherTok{\}}\StringTok{)"}\FunctionTok{)}
    \OperatorTok{...}
\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ order}\FunctionTok{\}}
    \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
        \OperatorTok{...}
      \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Buy order filled, placing sell order ..."}\FunctionTok{)}  
    \OperatorTok{...}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{sell\_order:}\NormalTok{ order}\FunctionTok{\}}
    \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Finalizing \texttt{Naive.Leader} implementation}{Finalizing Naive.Leader implementation}}\label{finalizing-naive.leader-implementation}

Now we need to get back to the \texttt{Naive.Leader} where we will implement the notifying logic. We will start with the notify function that will just call the \texttt{Naive.Leader} process:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# below init}

  \KeywordTok{def}\NormalTok{ notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, trader\_state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{call}\FunctionTok{(}
\NormalTok{      :}\StringTok{"}\OtherTok{\#\{}\ConstantTok{\_\_MODULE\_\_}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{trader\_state}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:update\_trader\_state}\NormalTok{, trader\_state}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now, it's time for a callback function that will handle the trader state update. As this is a \texttt{handle\_call/3} callback we have access to the trader PID which sent the notification message. We will try to find that trader in the list of traders. If that's successful we will update the cached state for that
trader locally:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# below handle\_continue}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
    \FunctionTok{\{}\VariableTok{:update\_trader\_state}\NormalTok{, new\_trader\_state}\FunctionTok{\}}\NormalTok{,}
    \FunctionTok{\{}\NormalTok{trader\_pid, \_}\FunctionTok{\}}\NormalTok{,}
\NormalTok{    \%}\FunctionTok{\{}\VariableTok{traders:}\NormalTok{ traders}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
  \FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find\_index}\FunctionTok{(}\NormalTok{traders, }\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{pid }\OperatorTok{==}\NormalTok{ trader\_pid}\FunctionTok{))} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}
          \StringTok{"Tried to update the state of trader that leader is not aware of"}
        \FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}}
      
\NormalTok{      index }\OperatorTok{{-}\textgreater{}}
\NormalTok{        old\_trader\_data }\OperatorTok{=} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{at}\FunctionTok{(}\NormalTok{traders, index}\FunctionTok{)}
\NormalTok{        new\_trader\_data }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{old\_trader\_data }\OperatorTok{|} \VariableTok{:state} \OperatorTok{=\textgreater{}}\NormalTok{ new\_trader\_state}\FunctionTok{\}}

        \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{:traders} \OperatorTok{=\textgreater{}}
          \ConstantTok{List}\OperatorTok{.}\NormalTok{replace\_at}\FunctionTok{(}\NormalTok{traders, index, new\_trader\_data}\FunctionTok{)\}\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Another callback functions that we will need to provide are two \texttt{handle\_info/2} functions that will handle the trade finished scenario as well as crashed trader.

\newpage

First, trade finished scenario. As previously, we will try to find the trader data in the traders list. If that's successful, we will start a new trader with a fresh state. We will also overwrite existing trader data locally(as PID, ref, and state changed):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# below state updated handle\_call callback}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:DOWN}\NormalTok{, \_ref, }\VariableTok{:process}\NormalTok{, trader\_pid, }\VariableTok{:normal}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\FunctionTok{\{}\VariableTok{traders:}\NormalTok{ traders, }\VariableTok{symbol:}\NormalTok{ symbol, }\VariableTok{settings:}\NormalTok{ settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ trader finished trade {-} restarting"}\FunctionTok{)}

    \KeywordTok{case} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find\_index}\FunctionTok{(}\NormalTok{traders, }\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{pid }\OperatorTok{==}\NormalTok{ trader\_pid}\FunctionTok{))} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}
          \StringTok{"Tried to restart finished }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ "} \OperatorTok{\textless{}\textgreater{}}
            \StringTok{"trader that leader is not aware of"}
        \FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}

\NormalTok{      index }\OperatorTok{{-}\textgreater{}}
\NormalTok{        new\_trader\_data }\OperatorTok{=}\NormalTok{ start\_new\_trader}\FunctionTok{(}\NormalTok{fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{))}
\NormalTok{        new\_traders }\OperatorTok{=} \ConstantTok{List}\OperatorTok{.}\NormalTok{replace\_at}\FunctionTok{(}\NormalTok{traders, index, new\_trader\_data}\FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{traders:}\NormalTok{ new\_traders}\FunctionTok{\}\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Here we will assume that whenever the reason that the \texttt{Naive.Trader} process died is \texttt{:normal} that means that we stopped it after trade cycle finished.

The final callback that we need to provide will handle the scenario where the trader crashed. We would like to find the cached state of the crashed trader and start a new one with the same state and then update the local cache as PID and ref will change for that trader:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# below trade finished handle\_info callback}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:DOWN}\NormalTok{, \_ref, }\VariableTok{:process}\NormalTok{, trader\_pid, reason}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\FunctionTok{\{}\VariableTok{traders:}\NormalTok{ traders, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{error}\FunctionTok{(}\StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ trader died {-} reason }\OtherTok{\#\{}\NormalTok{reason}\OtherTok{\}}\StringTok{ {-} trying to restart"}\FunctionTok{)}

    \KeywordTok{case} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find\_index}\FunctionTok{(}\NormalTok{traders, }\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{pid }\OperatorTok{==}\NormalTok{ trader\_pid}\FunctionTok{))} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}
          \StringTok{"Tried to restart }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ trader "} \OperatorTok{\textless{}\textgreater{}}
            \StringTok{"but failed to find its cached state"}
        \FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}

\NormalTok{      index }\OperatorTok{{-}\textgreater{}}
\NormalTok{        trader\_data }\OperatorTok{=} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{at}\FunctionTok{(}\NormalTok{traders, index}\FunctionTok{)}
\NormalTok{        new\_trader\_data }\OperatorTok{=}\NormalTok{ start\_new\_trader}\FunctionTok{(}\NormalTok{trader\_data}\OperatorTok{.}\NormalTok{state}\FunctionTok{)}
\NormalTok{        new\_traders }\OperatorTok{=} \ConstantTok{List}\OperatorTok{.}\NormalTok{replace\_at}\FunctionTok{(}\NormalTok{traders, index, new\_trader\_data}\FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{traders:}\NormalTok{ new\_traders}\FunctionTok{\}\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{IEx testing}\label{iex-testing}

That finishes the implementation part, let's jump into the IEx session to see how it works.

We will start the observer first, then we will start trading on any valid symbol.

When our trader will start, you should be able to right-click and select ``Kill process''(leave the reason as kill) and click ``OK''. At that moment you should see that the PID of the trader changed and we can also see a log message from the leader.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ :observer.start}\KeywordTok{()}             
\ExtensionTok{:ok}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"xrpusdt"}\KeywordTok{)}

\ExtensionTok{00:04:35.041} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.455.0\textgreater{}\}}
\ExtensionTok{00:04:37.697} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for XRPUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}
\ExtensionTok{00:08:01.476} \PreprocessorTok{[}\SpecialStringTok{error}\PreprocessorTok{]}\NormalTok{ XRPUSDT trader died }\AttributeTok{{-}}\NormalTok{ trying to restart}
\ExtensionTok{00:08:01.476} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for XRPUSDT}
\end{Highlighting}
\end{Shaded}

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_05}{GitHub}

\chapter{\texorpdfstring{Introduce a \texttt{buy\_down\_interval} to make a single trader more profitable}{Introduce a buy\_down\_interval to make a single trader more profitable}}\label{introduce-a-buy_down_interval-to-make-a-single-trader-more-profitable}

\section{Objectives}\label{objectives-5}

\begin{itemize}
\tightlist
\item
  present reasons why to introduce \texttt{buy\_down\_interval}
\item
  add \texttt{buy\_down\ interval} to \texttt{Naive.Trader}'s state and calculate buy price
\item
  add \texttt{buy\_down\ interval} to \texttt{Naive.Trader}'s state compiled by the \texttt{Naive.Leader}
\item
  manually test the implementation inside iex
\end{itemize}

\section{Why we need to buy below the current price? Feature overview}\label{why-we-need-to-buy-below-the-current-price-feature-overview}

\begin{center}\includegraphics[width=0.5\linewidth]{images/chapter_06_01_current_buy_price} \end{center}

The \texttt{Naive.Trader} process(marked in above diagram with blue color) at the arrival of the first trade event, immediately places a buy order at the current price. At the moment when the buy order gets filled, it places the sell order which later also gets filled.

The Trader A exits and a new trader B is started which again immediately places a buy order \emph{at the same price} as the previous trader just sold. When this gets filled sell order gets placed and the loop continues on and on.

We can see that there's a problem here as we just paid a fee twice(once for selling by the Trader A and once for buying by the Trader B) without really gaining anything(the Trader A could just hold the currency and could simply cash in on double profit in this specific situation).

\newpage

The solution is to be more clever about our buy order's price. The idea is simple, instead of placing a new buy order at the current price(price from the last TradeEvent), we will introduce a \texttt{buy\_down\_interval}:

\begin{center}\includegraphics[width=0.5\linewidth]{images/chapter_06_02_rebuy_expl} \end{center}

So every new \texttt{Naive.Trader} process as it receives the first trade event, the trader will take its price and will calculate a decreased price by using the \texttt{buy\_down\_interval} value(for example 0.005 would be 0.5\%) and place a buy order at that calculated price.

When looking at the chart above we can figure out that \texttt{buy\_down\_interval} should never be smaller than double the fee(at the moment of writing transaction fee is 0.1\%) that you are paying per transaction.

\section{\texorpdfstring{\texttt{Naive.Trader} implementation}{Naive.Trader implementation}}\label{naive.trader-implementation}

Let's open the \texttt{Naive.Trader} module's file(\texttt{/apps/naive/lib/naive/trader.ex}) and add \texttt{buy\_down\_interval} to its state:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}
  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}
      \VariableTok{:symbol}\NormalTok{,}
      \VariableTok{:buy\_down\_interval}\NormalTok{, }\CommentTok{\# \textless{}= add this line}
      \VariableTok{:profit\_interval}\NormalTok{,}
      \VariableTok{:tick\_size}
    \OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}
      \VariableTok{:symbol}\NormalTok{,}
      \VariableTok{:buy\_order}\NormalTok{,}
      \VariableTok{:sell\_order}\NormalTok{,}
      \VariableTok{:buy\_down\_interval}\NormalTok{, }\CommentTok{\# \textless{}= add this line}
      \VariableTok{:profit\_interval}\NormalTok{,}
      \VariableTok{:tick\_size}
    \OtherTok{]}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Next, we need to update the initial \texttt{handle\_info/2} callback which places the buy order. We need to retrieve the \texttt{buy\_down\_interval} and the \texttt{tick\_size} from the \texttt{state} of the trader to be able to calculate the buy price. We will put the logic to calculate that price in a separate function at the end of the file:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}\VariableTok{price:}\NormalTok{ price}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{buy\_order:} \ConstantTok{nil}\NormalTok{,}
          \VariableTok{buy\_down\_interval:}\NormalTok{ buy\_down\_interval, }\CommentTok{\# \textless{}= add this line}
          \VariableTok{tick\_size:}\NormalTok{ tick\_size                  }\CommentTok{\# \textless{}= add this line          }
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    price }\OperatorTok{=}\NormalTok{ calculate\_buy\_price}\FunctionTok{(}\NormalTok{price, buy\_down\_interval, tick\_size}\FunctionTok{)}
    \CommentTok{\# \^{} add above call}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

To calculate the buy price we will use a very similar method to the one used
before to calculate the sell price. First, we will need to cast all variables
into the \texttt{Decimal} structs and then, we will simply subtract the \texttt{buy\_down\_interval} of the price from the price. The number that we will end up with won't necessarily be a legal price as every price needs to be divisible by the \texttt{tick\_size} which we will assure in the last calculation:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ calculate\_buy\_price}\FunctionTok{(}\NormalTok{current\_price, buy\_down\_interval, tick\_size}\FunctionTok{)} \KeywordTok{do}
    \CommentTok{\# not necessarily legal price}
\NormalTok{    exact\_buy\_price }\OperatorTok{=}
\NormalTok{      D}\OperatorTok{.}\NormalTok{sub}\FunctionTok{(}
\NormalTok{        current\_price,}
\NormalTok{        D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}\NormalTok{current\_price, buy\_down\_interval}\FunctionTok{)}
      \FunctionTok{)}

\NormalTok{    D}\OperatorTok{.}\NormalTok{to\_string}\FunctionTok{(}
\NormalTok{      D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}
\NormalTok{        D}\OperatorTok{.}\NormalTok{div\_int}\FunctionTok{(}\NormalTok{exact\_buy\_price, tick\_size}\FunctionTok{)}\NormalTok{,}
\NormalTok{        tick\_size}
      \FunctionTok{)}\NormalTok{,}
      \VariableTok{:normal}
    \FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\section{\texorpdfstring{\texttt{Naive.Leader} implementation}{Naive.Leader implementation}}\label{naive.leader-implementation}

Next, we need to update the \texttt{Naive.Leader} as it needs to add \texttt{buy\_down\_interval} to the \texttt{Naive.Trader}'s state:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}

\NormalTok{    \%}\FunctionTok{\{}
      \VariableTok{symbol:}\NormalTok{ symbol,}
      \VariableTok{chunks:} \DecValTok{1}\NormalTok{,}
      \CommentTok{\# 0.01\% for quick testing}
      \VariableTok{buy\_down\_interval:} \StringTok{"0.0001"}\NormalTok{, }\CommentTok{\# \textless{}= add this line}
      \CommentTok{\# {-}0.12\% for quick testing}
      \VariableTok{profit\_interval:} \StringTok{"{-}0.0012"}\NormalTok{,}
      \VariableTok{tick\_size:}\NormalTok{ tick\_size}
    \FunctionTok{\}}
  \KeywordTok{end}  
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{IEx testing}\label{iex-testing-1}

That finishes the \texttt{buy\_down\_interval} implementation, we will jump into the IEx session to see how it works, but before that, for a moment we will change the logging level to \texttt{debug} to see current prices:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# config/config.exs}
\OperatorTok{...}
\NormalTok{config }\VariableTok{:logger}\NormalTok{,}
  \VariableTok{level:} \VariableTok{:debug} \CommentTok{\# \textless{}= updated for our manual test}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

After starting the streaming we should start seeing log messages with current prices. As we updated our implementation we should place our buy order below the current price as it's visible below:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"FLMUSDT"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.313.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"FLMUSDT"}\KeywordTok{)}
\ExtensionTok{21:16:14.829} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on FLMUSDT}
\ExtensionTok{...}
\ExtensionTok{21:16:16.755} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for FLMUSDT}
\ExtensionTok{...}
\ExtensionTok{21:16:20.000} \PreprocessorTok{[}\SpecialStringTok{debug}\PreprocessorTok{]}\NormalTok{ Trade event received FLMUSDT@0.15180000}
\ExtensionTok{21:16:20.009} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Placing BUY order for FLMUSDT @ 0.1517, quantity: 100}
\end{Highlighting}
\end{Shaded}

As we can see our \texttt{Naive.Trader} process placed a buy order below the current price (based on the most recent trade event received)

{[}Note{]} Please remember to revert the change to logger level as otherwise there's too much noise in the logs.

{[}Note 2{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_06}{GitHub}

\chapter{Introduce a trader budget and calculating the quantity}\label{introduce-a-trader-budget-and-calculating-the-quantity}

\section{Objectives}\label{objectives-6}

\begin{itemize}
\tightlist
\item
  fetch step\_size
\item
  append budget and step\_size to the \texttt{Trader}'s state compiled by the \texttt{Leader}
\item
  append budget and step\_size to the \texttt{Trader}'s state
\item
  calculate quantity
\end{itemize}

\section{\texorpdfstring{Fetch \texttt{step\_size}}{Fetch step\_size}}\label{fetch-step_size}

In the 2nd chapter we hardcoded \texttt{quantity} to 100, it's time to refactor that. We will need \texttt{step\_size} information from the Binance which we are
already retrieving together with \texttt{tick\_size} in the \texttt{exchangeInfo} call(but not getting it out from the response). So we will rename the \texttt{fetch\_tick\_size/1} function to \texttt{fetch\_symbol\_filters/1} which will allow us to return multiple filters(\texttt{tick\_size} and \texttt{step\_size}) from that function.

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol\_filters }\OperatorTok{=}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \CommentTok{\# \textless{}= updated fetch\_tick\_size}
    
    \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}
\NormalTok{      \%}\FunctionTok{\{}
        \VariableTok{symbol:}\NormalTok{ symbol,}
        \VariableTok{chunks:} \DecValTok{1}\NormalTok{,}
        \VariableTok{budget:} \DecValTok{20}\NormalTok{,}
        \CommentTok{\# {-}0.01\% for quick testing}
        \VariableTok{buy\_down\_interval:} \StringTok{"0.0001"}\NormalTok{,}
        \CommentTok{\# {-}0.12\% for quick testing}
        \VariableTok{profit\_interval:} \StringTok{"{-}0.0012"}
      \FunctionTok{\}}\NormalTok{,}
\NormalTok{      symbol\_filters}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}  \CommentTok{\# \textless{}= updated fetch\_tick\_size}
\NormalTok{    symbol\_filters }\OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
      \OperatorTok{|\textgreater{}}\NormalTok{ elem}\FunctionTok{(}\DecValTok{1}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\VariableTok{:symbols}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]} \OperatorTok{==}\NormalTok{ symbol}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"filters"}\FunctionTok{)}

\NormalTok{    tick\_size }\OperatorTok{=}
\NormalTok{      symbol\_filters}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"PRICE\_FILTER"}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"tickSize"}\FunctionTok{)}

\NormalTok{    step\_size }\OperatorTok{=}
\NormalTok{      symbol\_filters}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"LOT\_SIZE"}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"stepSize"}\FunctionTok{)}

\NormalTok{    \%}\FunctionTok{\{}
      \VariableTok{tick\_size:}\NormalTok{ tick\_size,}
      \VariableTok{step\_size:}\NormalTok{ step\_size}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Instead of reassigning the filters one by one into the settings, we will merge them together(\#1). Additionally, we will introduce a \texttt{budget}(\#2) which will be shared across all traders of the symbol. Also, we don't need to assign \texttt{tick\_size} here as it's part of the settings that are merged.

\newpage

\section{\texorpdfstring{Append \texttt{budget} and \texttt{step\_size} to the \texttt{Trader}'s state inside the \texttt{Leader}}{Append budget and step\_size to the Trader's state inside the Leader}}\label{append-budget-and-step_size-to-the-traders-state-inside-the-leader}

The \texttt{budget} needs to be added to the \texttt{\%State\{\}}(\texttt{step\_size} will be automatically passed on by \texttt{struct/2}) of the trader inside \texttt{fresh\_trader\_state/1}(where we initialize the state of traders). Before we will assign it we need to divide it by the number of chunks as each trader gets only a chunk of the budget:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{defp}\NormalTok{ fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\FunctionTok{\{}
\NormalTok{      struct}\FunctionTok{(}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\NormalTok{, settings}\FunctionTok{)}
      \OperatorTok{|} \VariableTok{budget:}\NormalTok{ D}\OperatorTok{.}\NormalTok{div}\FunctionTok{(}\NormalTok{settings}\OperatorTok{.}\NormalTok{budget, settings}\OperatorTok{.}\NormalTok{chunks}\FunctionTok{)}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

In the code above we are using the \texttt{Decimal} module(aliased as \texttt{D}) to calculate the budget - we need to alias it at the top of \texttt{Naive.Leader}'s file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{GenServer}

  \ImportTok{alias} \ConstantTok{Decimal}\NormalTok{, }\VariableTok{as:}\NormalTok{ D }\CommentTok{\# \textless{}= add this line}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\section{\texorpdfstring{Append \texttt{budget} and \texttt{step\_size} to the \texttt{Trader}'s state}{Append budget and step\_size to the Trader's state}}\label{append-budget-and-step_size-to-the-traders-state}

We need to add both \texttt{budget} and \texttt{step\_size} to the \texttt{Naive.Trader}'s state struct:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}
  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}
      \VariableTok{:symbol}\NormalTok{,}
      \VariableTok{:budget}\NormalTok{, }\CommentTok{\# \textless{}= add this line}
      \VariableTok{:buy\_down\_interval}\NormalTok{,}
      \VariableTok{:profit\_interval}\NormalTok{,}
      \VariableTok{:tick\_size}\NormalTok{,}
      \VariableTok{:step\_size} \CommentTok{\# \textless{}= add this line and comma above}
    \OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}
      \VariableTok{:symbol}\NormalTok{,}
      \VariableTok{:budget}\NormalTok{, }\CommentTok{\# \textless{}= add this line}
      \VariableTok{:buy\_order}\NormalTok{,}
      \VariableTok{:sell\_order}\NormalTok{,}
      \VariableTok{:buy\_down\_interval}\NormalTok{,}
      \VariableTok{:profit\_interval}\NormalTok{,}
      \VariableTok{:tick\_size}\NormalTok{,}
      \VariableTok{:step\_size} \CommentTok{\# \textless{}= add this line and comma above}
    \OtherTok{]}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\section{Calculate quantity}\label{calculate-quantity}

Jumping back to the \texttt{handle\_info/2} where the \texttt{Naive.Trader} places a buy order, we need to pattern match on the \texttt{step\_size} and \texttt{budget} then we will be able to swap hardcoded quantity with the result of calling the \texttt{calculate\_quantity/3} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}\VariableTok{price:}\NormalTok{ price}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{budget:}\NormalTok{ budget, }\CommentTok{\# \textless{}= add this line}
          \VariableTok{buy\_order:} \ConstantTok{nil}\NormalTok{,}
          \VariableTok{buy\_down\_interval:}\NormalTok{ buy\_down\_interval,}
          \VariableTok{tick\_size:}\NormalTok{ tick\_size,}
          \VariableTok{step\_size:}\NormalTok{ step\_size }\CommentTok{\# \textless{}= add this line}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    quantity }\OperatorTok{=}\NormalTok{ calculate\_quantity}\FunctionTok{(}\NormalTok{budget, price, step\_size}\FunctionTok{)}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

To calculate quantity we will just divide the \texttt{budget} by the \texttt{price} with a caveat that it's possible (as with calculating the price) that it's not a legal quantity value as it needs to be divisible by \texttt{step\_size}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \CommentTok{\# add below at the bottom of the file}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ calculate\_quantity}\FunctionTok{(}\NormalTok{budget, price, step\_size}\FunctionTok{)} \KeywordTok{do}
    \CommentTok{\# not necessarily legal quantity}
\NormalTok{    exact\_target\_quantity }\OperatorTok{=}\NormalTok{ D}\OperatorTok{.}\NormalTok{div}\FunctionTok{(}\NormalTok{budget, price}\FunctionTok{)}

\NormalTok{    D}\OperatorTok{.}\NormalTok{to\_string}\FunctionTok{(}
\NormalTok{      D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}
\NormalTok{        D}\OperatorTok{.}\NormalTok{div\_int}\FunctionTok{(}\NormalTok{exact\_target\_quantity, step\_size}\FunctionTok{)}\NormalTok{,}
\NormalTok{        step\_size}
      \FunctionTok{)}\NormalTok{,}
      \VariableTok{:normal}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{IEx testing}\label{iex-testing-2}

That finishes the \texttt{quantity}(and \texttt{budget}) implementation, we will jump into the IEx session to see how it works.

First, start the streaming and trading on the same symbol and a moment later you should see a variable amount of quantity that more or less uses the full allowed budget:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.313.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{21:16:14.829} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on XRPUSDT}
\ExtensionTok{21:16:16.755} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for XRPUSDT}
\ExtensionTok{21:16:20.009} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Placing BUY order for XRPUSDT @ 0.29506, quantity: 67.7}
\ExtensionTok{21:16:23.456} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Buy order filled, placing SELL order for XRPUSDT @ 0.29529,}
\ExtensionTok{quantity:}\NormalTok{ 67.7}
\end{Highlighting}
\end{Shaded}

As we can see our \texttt{Naive.Trader} process is now buying and selling based on passed budget.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_07}{GitHub}

\chapter{Add support for multiple transactions per order}\label{add-support-for-multiple-transactions-per-order}

\section{Objectives}\label{objectives-7}

\begin{itemize}
\tightlist
\item
  describe the issue with the current implementation
\item
  improve buy order filled callback
\item
  implement buy order ``filled'' callback
\item
  improve sell order callback
\end{itemize}

\section{The issue with the current implementation}\label{the-issue-with-the-current-implementation}

Currently, \texttt{Naive.Trader} process is placing a buy order and it's assuming that it will be filled by a \emph{single} opposite sell order(we are pattern matching on quantity to confirm that):

\begin{center}\includegraphics[width=0.8\linewidth]{images/chapter_08_01_single_transaction} \end{center}

Here we can see our buy order for 1000 units(on the left) and other trader's sell order(on the right) for 1000 units. This(order fully filled in a single transaction) is a case most of the time but it's not ALWAYS the case.

\newpage

Sometimes our order will be filled by two or more transactions:

\begin{center}\includegraphics[width=0.8\linewidth]{images/chapter_08_02_multiple_transactions_per_order} \end{center}

The easiest and the safest way to check has this event filled our order fully is to fetch our order again from Binance at the moment when trade event filling our order arrives.

The problem with this approach is that sometimes we will run into a race condition:

\begin{center}\includegraphics[width=1\linewidth,height=0.55\textheight]{images/chapter_08_03_race_condition_timeline} \end{center}

From the left, first, we are sending a buy order for quantity 1000 to the Binance. It hangs for a while until it gets filled by 2 transactions that happened very quickly. Quickly enough for us to receive both messages almost in the same moment.

When our bot will handle the first one it will fetch the buy order which is already filled. It will cause the trader to place a sell order but then there's another trade event waiting in the message box. It will be handled by another callback that will again fetch the order and place another sell order to be placed and that's obviously not correct.

What we need to do is to update the status of the buy order after the first fetch(if it's filled) so when the second trade event arrives we will ignore it(this will require an additional callback).

The same issue will appear when placing a sell order and dealing with multiple simultaneous transactions.

\section{Improve buy order filled callback}\label{improve-buy-order-filled-callback}

First, we need to modify the callback which monitors incoming trade events for ones filling its buy order and then places sell order. We need to remove pattern matching assuming that a single trade event will fill our buy order - we need to drop quantity check as well as add:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{buyer\_order\_id:}\NormalTok{ order\_id }\CommentTok{\# \textless{}= quantity got removed from here}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{buy\_order:}
\NormalTok{            \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
              \VariableTok{price:}\NormalTok{ buy\_price,}
              \VariableTok{order\_id:}\NormalTok{ order\_id,}
              \VariableTok{orig\_qty:}\NormalTok{ quantity,}
              \VariableTok{transact\_time:}\NormalTok{ timestamp }\CommentTok{\# \textless{}= timestamp added to query order}
            \FunctionTok{\}} \OperatorTok{=}\NormalTok{ buy\_order, }\CommentTok{\# \textless{}= buy order to update it}
          \VariableTok{profit\_interval:}\NormalTok{ profit\_interval,}
          \VariableTok{tick\_size:}\NormalTok{ tick\_size}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

\newpage

Now we can fetch our buy order to check is it already filled. We will get the \texttt{Binance.Order} struct instead of the \texttt{Binance.OrderResponse} that we normally deal with. At this moment we will simply update our \texttt{Binance.OrderResponse} struct from the state:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \CommentTok{\# inside the same callback}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
      \OperatorTok{...}
      \FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_buy\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}
    
\NormalTok{    buy\_order }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{buy\_order }\OperatorTok{|} \VariableTok{status:}\NormalTok{ current\_buy\_order}\OperatorTok{.}\NormalTok{status}\FunctionTok{\}}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The rest of the logic inside this callback will depend on the \texttt{status} of the buy order. If our buy order is ``filled'' we would like to follow the existing logic but also update the \texttt{buy\_order} field inside the state of the trader process. On the other hand, if our order is not yet filled the only thing to do is to update the \texttt{buy\_order} field inside the state of the Trader process.

Here's an updated body below the above changes(few variables got renamed for clarity as we are now fetching the order):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \CommentTok{\# inside the same callback}
\NormalTok{  buy\_order }\OperatorTok{=} \OperatorTok{....}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_state}\FunctionTok{\}} \OperatorTok{=}
      \ControlFlowTok{if}\NormalTok{ buy\_order}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"FILLED"} \KeywordTok{do}
\NormalTok{        sell\_price }\OperatorTok{=}\NormalTok{ calculate\_sell\_price}\FunctionTok{(}\NormalTok{buy\_price, profit\_interval, tick\_size}\FunctionTok{)}

        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
          \StringTok{"Buy order filled, placing SELL order for "} \OperatorTok{\textless{}\textgreater{}}
            \StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{sell\_price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}
        \FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
          \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, sell\_price, }\StringTok{"GTC"}\FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ buy\_order, }\VariableTok{sell\_order:}\NormalTok{ order}\FunctionTok{\}\}}
      \ControlFlowTok{else}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Buy order partially filled"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ buy\_order}\FunctionTok{\}\}}
      \KeywordTok{end}

    \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we are branching our logic and both paths are updating the state, we will return it together with an \texttt{:ok} atom to be able to pattern match it and assign it as a new state.

\section{Implement buy order ``filled'' callback}\label{implement-buy-order-filled-callback}

The above callback covers the case where we will get multiple transactions filling our buy order. We aren't yet covering for the race condition described at the beginning of this chapter. When another trade event matching \texttt{buyer\_order\_id} would arrive, the above callback would be used and another sell order would be placed. To avoid that we need to add a new callback \emph{ABOVE} the one that we just edited that will match \texttt{buyer\_order\_id} together with ``filled'' \texttt{status} and it will simply ignore that trade event as we know that sell event needed to be placed by previous trade event:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \CommentTok{\# place this callback ABOVE callback from previous section}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{buyer\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{order\_id:}\NormalTok{ order\_id, }\CommentTok{\# \textless{}= confirms that it\textquotesingle{}s event for buy order}
            \VariableTok{status:} \StringTok{"FILLED"} \CommentTok{\# \textless{}= confirms buy order filled}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \CommentTok{\# \textless{}= confirms sell order placed}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Improve sell order callback}\label{improve-sell-order-callback}

Let's move on to the callback where the trader receives a trade event matching the sell order's id (about line 135 inside the \texttt{Naive.Trader} module).

\newpage

We need to modify the header of our callback in the following ways:

\begin{itemize}
\tightlist
\item
  drop both pattern matches on \texttt{quantity} as we already know that trade event could partially fill our order (\#1)
\item
  get \texttt{symbol} out of state (\#2)
\item
  get \texttt{transact\_time} out of the \texttt{sell\_order} (used to fetch \texttt{get\_order}) (\#3)
\item
  assign \texttt{sell\_order} to a variable (\#4)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{seller\_order\_id:}\NormalTok{ order\_id }\CommentTok{\# \textasciigrave{}quantity\textasciigrave{} check removed below (\#1)}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{symbol:}\NormalTok{ symbol, }\FunctionTok{(}\CommentTok{\#2)}
          \VariableTok{sell\_order:}
\NormalTok{            \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
              \VariableTok{order\_id:}\NormalTok{ order\_id,}
              \VariableTok{transact\_time:}\NormalTok{ timestamp }\CommentTok{\# \textasciigrave{}transact\_time\textasciigrave{} to \textasciigrave{}get\_order\textasciigrave{} (\#3)}
            \FunctionTok{\}} \OperatorTok{=}\NormalTok{ sell\_order }\CommentTok{\# to update order (\#4)}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

Moving to the body of the function, we need to:

\begin{itemize}
\item
  fetch current state of our sell order
\item
  update \texttt{status} of our \texttt{sell\_order} from Trader's state
\item
  branch out the logic based on \texttt{status} of the \texttt{sell\_order}:

  \begin{itemize}
  \tightlist
  \item
    log and return the \texttt{:stop} atom to stop the GenServer
  \end{itemize}

  or

  \begin{itemize}
  \tightlist
  \item
    update the state with new \texttt{sell\_order} and continue
  \end{itemize}
\end{itemize}

Here's the full body of our callback:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/lib/naive/trader.ex}
    \CommentTok{\# inside the callabck}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_sell\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}

\NormalTok{    sell\_order }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{sell\_order }\OperatorTok{|} \VariableTok{status:}\NormalTok{ current\_sell\_order}\OperatorTok{.}\NormalTok{status}\FunctionTok{\}}

    \ControlFlowTok{if}\NormalTok{ sell\_order}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"FILLED"} \KeywordTok{do}
      \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trade finished, trader will now exit"}\FunctionTok{)}
      \FunctionTok{\{}\VariableTok{:stop}\NormalTok{, }\VariableTok{:normal}\NormalTok{, state}\FunctionTok{\}}
    \ControlFlowTok{else}
      \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Sell order partially filled"}\FunctionTok{)}
\NormalTok{      new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{sell\_order:}\NormalTok{ sell\_order}\FunctionTok{\}}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
      \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
    \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Test the implementation}\label{test-the-implementation-1}

Testing this feature is a bit tricky as it requires trading on real Binance exchange(as our BinanceMock always fills orders with a single transaction) as well as race condition to happen :) Not that easy but even without race condition we should still test that code works as expected with BinanceMock:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{23:27:35.977} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.331.0\textgreater{}\}}
\ExtensionTok{23:27:39.073} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for XRPUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.345.0\textgreater{}\}}
\ExtensionTok{23:31:57.044} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader for XRPUSDT}
\ExtensionTok{23:31:57.888} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Placing BUY order for XRPUSDT @ 0.28031, quantity: 71.3}
\ExtensionTok{23:32:01.023} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Buy order filled, placing SELL order for XRPUSDT @ 0.28053,}
\ExtensionTok{quantity:}\NormalTok{ 71.30000000}
\ExtensionTok{23:33:08.865} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trade finished, trader will now exit}
\ExtensionTok{23:33:08.865} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  XRPUSDT Trader finished }\AttributeTok{{-}}\NormalTok{ restarting}
\end{Highlighting}
\end{Shaded}

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_08}{GitHub}

\chapter{Run multiple traders in parallel}\label{run-multiple-traders-in-parallel}

\section{Objectives}\label{objectives-8}

\begin{itemize}
\tightlist
\item
  describe and design the required functionality
\item
  implement rebuy in the \texttt{Naive.Trader}
\item
  implement rebuy in the \texttt{Naive.Leader}
\item
  improve logs by assigning ids to traders
\end{itemize}

\section{Describe and design the required functionality}\label{describe-and-design-the-required-functionality}

At this moment, inside the \texttt{Naive.Leader} we have a silly code that starts all of the traders at the same moment:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/lib/naive/leader.ex}
    \OperatorTok{...}
\NormalTok{    traders }\OperatorTok{=}
      \KeywordTok{for}\NormalTok{ \_i }\OperatorTok{\textless{}{-}} \DecValTok{1}\OperatorTok{..}\NormalTok{settings}\OperatorTok{.}\NormalTok{chunks,}
          \VariableTok{do:}\NormalTok{ start\_new\_trader}\FunctionTok{(}\NormalTok{trader\_state}\FunctionTok{)}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

All the changes we made in this episode will enable us to fix this.

\newpage

Let's say that we placed a buy order that got filled and the price has fallen before reaching the sell level. We can see here that we missed a nice opportunity to buy more as price drops and make money as it climbs back:

\begin{center}\includegraphics[height=0.2\textheight]{images/chapter_09_01_single_trader} \end{center}

We will implement an additional trade event callback inside the \texttt{Naive.Trader} that will keep checking the price after the buy order has been filled. Whenever a price drops below the \texttt{buy\_order}'s \texttt{price} by \texttt{rebuy\_interval} we will notify the \texttt{Naive.Leader} to start the new \texttt{Naive.Trader} process:

\begin{center}\includegraphics[height=0.2\textheight]{images/chapter_09_02_multi_traders} \end{center}

The \texttt{Naive.Leader} keeps track of how many \texttt{Naive.Trader}s are running and needs to honor the number of \texttt{chunks} set up in the settings (one chunk == one trader).

To stop the \texttt{Naive.Trader}s from continuously notifying about a drop in the price we will also introduce a boolean flag that will track has the \texttt{Naive.Leader} been already notified.

\section{\texorpdfstring{Implement rebuy inside \texttt{Naive.Trader}}{Implement rebuy inside Naive.Trader}}\label{implement-rebuy-inside-naive.trader}

We will start by adding the \texttt{rebuy\_interval} and the \texttt{rebuy\_notified} to the trader's state:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}
  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}
      \VariableTok{:symbol}\NormalTok{,}
      \VariableTok{:budget}\NormalTok{,}
      \VariableTok{:buy\_down\_interval}\NormalTok{,}
      \VariableTok{:profit\_interval}\NormalTok{,}
      \VariableTok{:rebuy\_interval}\NormalTok{, }\CommentTok{\# \textless{}= add this field}
      \VariableTok{:rebuy\_notified}\NormalTok{, }\CommentTok{\# \textless{}= add this field}
      \VariableTok{:tick\_size}\NormalTok{,}
      \VariableTok{:step\_size}
    \OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}
      \VariableTok{:symbol}\NormalTok{,}
      \VariableTok{:budget}\NormalTok{,}
      \VariableTok{:buy\_order}\NormalTok{,}
      \VariableTok{:sell\_order}\NormalTok{,}
      \VariableTok{:buy\_down\_interval}\NormalTok{,}
      \VariableTok{:profit\_interval}\NormalTok{,}
      \VariableTok{:rebuy\_interval}\NormalTok{, }\CommentTok{\# \textless{}= add this field}
      \VariableTok{:rebuy\_notified}\NormalTok{, }\CommentTok{\# \textless{}= add this field}
      \VariableTok{:tick\_size}\NormalTok{,}
      \VariableTok{:step\_size}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Rebuy logic should be placed almost as the last callback just before the one that ignores all events. We will need to retrieve the current \texttt{price} and \texttt{buy\_price} and confirm that we didn't notify the leader yet(\texttt{rebuy\_notified} flag):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OperatorTok{...}
  \CommentTok{\# sell filled callback here}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{price:}\NormalTok{ current\_price}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{price:}\NormalTok{ buy\_price}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{rebuy\_interval:}\NormalTok{ rebuy\_interval,}
          \VariableTok{rebuy\_notified:} \ConstantTok{false}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}

  \KeywordTok{end}
  \CommentTok{\# catch all callback here}
\end{Highlighting}
\end{Shaded}

We need to calculate is the current price below the rebuy interval. If yes we will notify the leader and update the boolean flag. We will abstract calculation to separate function(for readability) that we will write below:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/lib/naive/trader.ex}
    \CommentTok{\# body of the above callback}
    \ControlFlowTok{if}\NormalTok{ trigger\_rebuy?}\FunctionTok{(}\NormalTok{buy\_price, current\_price, rebuy\_interval}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Rebuy triggered for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ trader"}\FunctionTok{)}
\NormalTok{      new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{rebuy\_notified:} \ConstantTok{true}\FunctionTok{\}}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:rebuy\_triggered}\NormalTok{, new\_state}\FunctionTok{)}
      \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
    \ControlFlowTok{else}
      \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}
    \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As mentioned before, we will set the \texttt{rebuy\_notified} boolean flag to true and notify the leader using the \texttt{notify} function with the dedicated atom.

At the bottom of the module we need to add the \texttt{trigger\_rebuy?} helper function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \CommentTok{\# bottom of the module}
  \KeywordTok{defp}\NormalTok{ trigger\_rebuy?}\FunctionTok{(}\NormalTok{buy\_price, current\_price, rebuy\_interval}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    rebuy\_price }\OperatorTok{=}
\NormalTok{      D}\OperatorTok{.}\NormalTok{sub}\FunctionTok{(}
\NormalTok{        buy\_price,}
\NormalTok{        D}\OperatorTok{.}\NormalTok{mult}\FunctionTok{(}\NormalTok{buy\_price, rebuy\_interval}\FunctionTok{)}
      \FunctionTok{)}

\NormalTok{    D}\OperatorTok{.}\NormalTok{lt?}\FunctionTok{(}\NormalTok{current\_price, rebuy\_price}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{\texorpdfstring{Implement rebuy in the \texttt{Naive.Leader}}{Implement rebuy in the Naive.Leader}}\label{implement-rebuy-in-the-naive.leader}

Moving on to the \texttt{Naive.Leader} module, we can get update starting of the traders automatically by the leader to starting just one inside \texttt{handle\_continue}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{def}\NormalTok{ handle\_continue}\FunctionTok{(}\VariableTok{:start\_traders}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    traders }\OperatorTok{=} \OtherTok{[}\NormalTok{start\_new\_trader}\FunctionTok{(}\NormalTok{trader\_state}\FunctionTok{)}\OtherTok{]} \CommentTok{\# \textless{}= updated part}

    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We will need to add a new clause of the \texttt{notify} function that will handle the rebuy scenario:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# add below current \textasciigrave{}notify\textasciigrave{} function}
  \KeywordTok{def}\NormalTok{ notify}\FunctionTok{(}\VariableTok{:rebuy\_triggered}\NormalTok{, trader\_state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{call}\FunctionTok{(}
\NormalTok{      :}\StringTok{"}\OtherTok{\#\{}\ConstantTok{\_\_MODULE\_\_}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{trader\_state}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:rebuy\_triggered}\NormalTok{, trader\_state}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We need to add a new \texttt{handle\_call} function that will start new traders only when there are still chunks available(enforce the maximum number of parallel traders) - let's start with a header:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \CommentTok{\# place this one after :update\_trader\_state handle\_call}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:rebuy\_triggered}\NormalTok{, new\_trader\_state}\FunctionTok{\}}\NormalTok{,}
        \FunctionTok{\{}\NormalTok{trader\_pid, \_}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\FunctionTok{\{}\VariableTok{traders:}\NormalTok{ traders, }\VariableTok{symbol:}\NormalTok{ symbol, }\VariableTok{settings:}\NormalTok{ settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}

  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

There are few important details to make note of:

\begin{itemize}
\tightlist
\item
  we need the trader's PID to be able to find it details inside the list of traders
\item
  we need settings to confirm the number of chunks to be able to limit the maximum number of parallel traders
\end{itemize}

Moving on to the body of our callback. As with other ones, we will check can we find a trader inside the list of traders, and based on that we will either start another one(if we didn't reach the limit of chunks) or ignore it:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/lib/naive/leader.ex}
    \CommentTok{\# body of our callback}
    \KeywordTok{case} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find\_index}\FunctionTok{(}\NormalTok{traders, }\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{pid }\OperatorTok{==}\NormalTok{ trader\_pid}\FunctionTok{))} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Rebuy triggered by trader that leader is not aware of"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}}

\NormalTok{      index }\OperatorTok{{-}\textgreater{}}
\NormalTok{        old\_trader\_data }\OperatorTok{=} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{at}\FunctionTok{(}\NormalTok{traders, index}\FunctionTok{)}
\NormalTok{        new\_trader\_data }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{old\_trader\_data }\OperatorTok{|} \VariableTok{:state} \OperatorTok{=\textgreater{}}\NormalTok{ new\_trader\_state}\FunctionTok{\}}
\NormalTok{        updated\_traders }\OperatorTok{=} \ConstantTok{List}\OperatorTok{.}\NormalTok{replace\_at}\FunctionTok{(}\NormalTok{traders, index, new\_trader\_data}\FunctionTok{)}

\NormalTok{        updated\_traders }\OperatorTok{=}
          \ControlFlowTok{if}\NormalTok{ settings}\OperatorTok{.}\NormalTok{chunks }\OperatorTok{==}\NormalTok{ length}\FunctionTok{(}\NormalTok{traders}\FunctionTok{)} \KeywordTok{do}
            \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"All traders already started for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
\NormalTok{            updated\_traders}
          \ControlFlowTok{else}
            \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting new trader for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
            \OtherTok{[}\NormalTok{start\_new\_trader}\FunctionTok{(}\NormalTok{fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{))} \OperatorTok{|}\NormalTok{ updated\_traders}\OtherTok{]}
          \KeywordTok{end}

        \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{:traders} \OperatorTok{=\textgreater{}}\NormalTok{ updated\_traders}\FunctionTok{\}\}}
    \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

In the above code, we need to remember to update the state of the trader that triggered the rebuy inside the \texttt{traders} list as well as add the state of a new trader to that list.

As with other setting we will hardcode the \texttt{rebuy\_interval}(inside the \texttt{fetch\_symbol\_settings} function) and assign them to
trader's state(inside the \texttt{fresh\_trader\_state} function):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{defp}\NormalTok{ fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\FunctionTok{\{}
\NormalTok{      struct}\FunctionTok{(}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\NormalTok{, settings}\FunctionTok{)}
      \OperatorTok{|} \VariableTok{budget:}\NormalTok{ D}\OperatorTok{.}\NormalTok{div}\FunctionTok{(}\NormalTok{settings}\OperatorTok{.}\NormalTok{budget, settings}\OperatorTok{.}\NormalTok{chunks}\FunctionTok{)}\NormalTok{,}
        \VariableTok{rebuy\_notified:} \ConstantTok{false} \CommentTok{\# \textless{}= add this line}
    \FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}

    \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}
\NormalTok{      \%}\FunctionTok{\{}
        \OperatorTok{...}
        \VariableTok{chunks:} \DecValTok{5}\NormalTok{, }\CommentTok{\# \textless{}= update to 5 parallel traders max}
        \VariableTok{budget:} \DecValTok{100}\NormalTok{, }\CommentTok{\# \textless{}= update this line}
        \OperatorTok{...}
        \VariableTok{profit\_interval:} \StringTok{"{-}0.0012"}\NormalTok{,}
        \VariableTok{rebuy\_interval:} \StringTok{"0.001"} \CommentTok{\# \textless{}= add this line}
      \FunctionTok{\}}\NormalTok{,}
\NormalTok{      symbol\_filters}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We also update the \texttt{chunks} and the \texttt{budget} to allow our strategy to start up to 5 parallel traders with a budget of 20 USDT each(100/5) as Binance has minimal order requirement at about \$15(when using the \texttt{BinanceMock} this doesn't really matter).

\section{Improve logs by assigning ids to traders}\label{improve-logs-by-assigning-ids-to-traders}

The final change will be to add an \texttt{id} to the trader's state so we can use it inside log messages to give us meaningful data about what's going on(otherwise we won't be able to tell which message was logged by which trader).

First, let's add the \texttt{id} into the \texttt{Naive.Leader}'s fresh\_trader\_state as it will be defined per trader:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \KeywordTok{defp}\NormalTok{ fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\FunctionTok{\{}
\NormalTok{      struct}\FunctionTok{(}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\NormalTok{, settings}\FunctionTok{)}
      \OperatorTok{|} \VariableTok{id:} \VariableTok{:os}\OperatorTok{.}\NormalTok{system\_time}\FunctionTok{(}\VariableTok{:millisecond}\FunctionTok{)}\NormalTok{, }\CommentTok{\# \textless{}= add this line}
        \VariableTok{budget:}\NormalTok{ D}\OperatorTok{.}\NormalTok{div}\FunctionTok{(}\NormalTok{settings}\OperatorTok{.}\NormalTok{budget, settings}\OperatorTok{.}\NormalTok{chunks}\FunctionTok{)}\NormalTok{,}
        \VariableTok{rebuy\_notified:} \ConstantTok{false}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we can move on to the \texttt{Naive.Trader} and add it to the \texttt{\%State\{\}} struct as well as we will modify every callback to include that id inside log messages:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}
      \VariableTok{:id}\NormalTok{,}
      \OperatorTok{...}
    \OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}
      \VariableTok{:id}\NormalTok{,}
      \OperatorTok{...}
    \OtherTok{]}
  \KeywordTok{end}

  \OperatorTok{...}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\%}\ConstantTok{State}\FunctionTok{\{}\VariableTok{id:}\NormalTok{ id, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Initializing new trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}\VariableTok{price:}\NormalTok{ price}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \OperatorTok{...}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"The trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) is placing a BUY order "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}

    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{buyer\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \OperatorTok{...}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
          \StringTok{"The trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) is placing a SELL order for "} \OperatorTok{\textless{}\textgreater{}}
            \StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{sell\_price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{."}
        \FunctionTok{)}
        \OperatorTok{...}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ BUY order got partially filled"}\FunctionTok{)}
        \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{seller\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \OperatorTok{...}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
      \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) finished trade cycle for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
      \OperatorTok{...}
      \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ SELL order got partially filled"}\FunctionTok{)}
      \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{price:}\NormalTok{ current\_price}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \OperatorTok{...}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
      \OperatorTok{...}
      \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Rebuy triggered for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ by the trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{)"}\FunctionTok{)}
      \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That finishes the implementation part - we should now be able to test the implementation and see a dynamically growing number of traders for our strategy based on price movement.

\section{Test the implementation}\label{test-the-implementation-2}

Let's start an iEx session and open the \texttt{:observer}(inside go to ``Applications'' tab and click on \texttt{naive} from the list of the left) so we will be able to see how the number of traders is growing as well as PIDs are changing which means that they are finishing the full trades:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ :observer.start}\KeywordTok{()}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"HNTUSDT"}\KeywordTok{)}
\ExtensionTok{10:22:05.018} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754009963}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.175,}
\ExtensionTok{quantity:}\NormalTok{ 2.446}
\ExtensionTok{10:22:11.665} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for HNTUSDT by the trader}\ErrorTok{(}\ExtensionTok{1616754009963}\KeywordTok{)}
\ExtensionTok{10:22:11.665} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new trader for HNTUSDT}
\ExtensionTok{10:22:11.665} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754131665}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:22:11.665} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754009963}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a SELL order for HNTUSDT @ 8.181,}
\ExtensionTok{quantity:}\NormalTok{ 2.446.}
\ExtensionTok{10:22:11.665} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754131665}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.157,}
\ExtensionTok{quantity:}\NormalTok{ 2.451}
\ExtensionTok{10:22:58.339} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1616754009963}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for HNTUSDT}
\ExtensionTok{10:22:58.339} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  HNTUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{10:22:58.339} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754178339}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:22:58.339} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754178339}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.212,}
\ExtensionTok{quantity:}\NormalTok{ 2.435}
\ExtensionTok{10:23:13.232} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for HNTUSDT by the trader}\ErrorTok{(}\ExtensionTok{1616754178339}\KeywordTok{)}
\ExtensionTok{10:23:13.232} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new trader for HNTUSDT}
\ExtensionTok{10:23:13.232} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754193232}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:23:13.232} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754178339}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a SELL order for HNTUSDT @ 8.218,}
\ExtensionTok{quantity:}\NormalTok{ 2.435.}
\ExtensionTok{10:23:31.120} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754193232}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.194,}
\ExtensionTok{quantity:}\NormalTok{ 2.44}
\ExtensionTok{10:23:31.121} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1616754178339}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for HNTUSDT}
\ExtensionTok{10:23:31.122} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  HNTUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{10:23:31.122} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754211122}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:24:31.891} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754211122}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.198,}
\ExtensionTok{quantity:}\NormalTok{ 2.439}
\ExtensionTok{10:25:24.155} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754211122}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a SELL order for HNTUSDT @ 8.204,}
\ExtensionTok{quantity:}\NormalTok{ 2.439.}
\ExtensionTok{10:25:24.155} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754193232}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a SELL order for HNTUSDT @ 8.2,}
\ExtensionTok{quantity:}\NormalTok{ 2.44.}
\ExtensionTok{10:25:24.155} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for HNTUSDT by the trader}\ErrorTok{(}\ExtensionTok{1616754211122}\KeywordTok{)}
\ExtensionTok{10:25:24.155} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new trader for HNTUSDT}
\ExtensionTok{10:25:24.156} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754324155}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:25:24.156} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for HNTUSDT by the trader}\ErrorTok{(}\ExtensionTok{1616754193232}\KeywordTok{)}
\ExtensionTok{10:25:24.156} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754324155}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.183,}
\ExtensionTok{quantity:}\NormalTok{ 2.444}
\ExtensionTok{10:25:24.156} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new trader for HNTUSDT}
\ExtensionTok{10:25:24.156} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754324156}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT }
\ExtensionTok{10:25:24.156} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754324156}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.176,}
\ExtensionTok{quantity:}\NormalTok{ 2.446}
\ExtensionTok{10:25:24.156} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754324155}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a SELL order for HNTUSDT @ 8.189,}
\ExtensionTok{quantity:}\NormalTok{ 2.444.}
\ExtensionTok{10:25:37.527} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1616754324155}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for HNTUSDT}
\ExtensionTok{10:25:37.528} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  HNTUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{10:25:37.528} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754337528}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:25:37.528} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754337528}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.192,}
\ExtensionTok{quantity:}\NormalTok{ 2.441}
\ExtensionTok{10:25:37.530} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1616754211122}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for HNTUSDT}
\ExtensionTok{10:25:37.530} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1616754193232}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for HNTUSDT}
\ExtensionTok{10:25:37.530} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  HNTUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{10:25:37.530} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754337530}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:25:37.530} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  HNTUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{10:25:37.530} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1616754337530}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{10:25:40.015} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for HNTUSDT by the trader}\ErrorTok{(}\ExtensionTok{1616754337528}\KeywordTok{)}
\ExtensionTok{10:25:40.015} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1616754337530}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for HNTUSDT @ 8.179,}
\ExtensionTok{quantity:}\NormalTok{ 2.445}
\ExtensionTok{10:25:40.015} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  All traders already started for HNTUSDT}
\end{Highlighting}
\end{Shaded}

And our observer shows the following:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_09_supervision_tree} \end{center}

We can clearly see that our strategy dynamically scaled from 1 to 5 parallel traders and they were going through different trading steps without any problems - I think that's really cool to see and it wasn't difficult to achieve in Elixir.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_09}{GitHub}

\chapter{Fine-tune trading strategy per symbol}\label{fine-tune-trading-strategy-per-symbol}

\section{Objectives}\label{objectives-9}

\begin{itemize}
\tightlist
\item
  describe and design the required functionality
\item
  add docker to project
\item
  set up \texttt{ecto} inside the \texttt{naive} app
\item
  create and migrate the DB
\item
  seed symbols' settings
\item
  update the \texttt{Naive.Leader} to fetch settings
\end{itemize}

\section{Describe and design the required functionality}\label{describe-and-design-the-required-functionality-1}

At this moment the settings of our naive strategy are hardcoded inside the \texttt{Naive.Leader}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol\_filters }\OperatorTok{=}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}
\NormalTok{      \%}\FunctionTok{\{}
        \VariableTok{symbol:}\NormalTok{ symbol,              }\CommentTok{\# \textless{}=}
        \VariableTok{chunks:} \DecValTok{5}\NormalTok{,                   }\CommentTok{\# \textless{}=}
        \VariableTok{budget:} \DecValTok{100}\NormalTok{,                 }\CommentTok{\# \textless{}=}
        \CommentTok{\# {-}0.01\% for quick testing   \# \textless{}=}
        \VariableTok{buy\_down\_interval:} \StringTok{"0.0001"}\NormalTok{, }\CommentTok{\# \textless{}= all of those settings}
        \CommentTok{\# {-}0.12\% for quick testing   \# \textless{}=}
        \VariableTok{profit\_interval:} \StringTok{"{-}0.0012"}\NormalTok{,  }\CommentTok{\# \textless{}=}
        \VariableTok{rebuy\_interval:} \StringTok{"0.001"}      \CommentTok{\# \textless{}=}
      \FunctionTok{\}}\NormalTok{,}
\NormalTok{      symbol\_filters}
    \FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The problem about those is that they are hardcoded and there's no flexibility to define them per symbol at the moment.

In this chapter, we will move them out from this file into the Postgres database.

\section{Add docker to project}\label{add-docker-to-project}

The requirements for this section are \texttt{docker} and \texttt{docker-compose} installed in your system.

Inside the main directory of our project create a new file called \texttt{docker-compose.yml} and fill it with the below details:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /docker{-}compose.yml}
\FunctionTok{version}\KeywordTok{:}\AttributeTok{ }\StringTok{"3.2"}
\FunctionTok{services}\KeywordTok{:}
\AttributeTok{  }\FunctionTok{db}\KeywordTok{:}
\AttributeTok{    }\FunctionTok{image}\KeywordTok{:}\AttributeTok{ postgres:latest}
\AttributeTok{    }\FunctionTok{restart}\KeywordTok{:}\AttributeTok{ always}
\AttributeTok{    }\FunctionTok{environment}\KeywordTok{:}
\AttributeTok{      }\FunctionTok{POSTGRES\_PASSWORD}\KeywordTok{:}\AttributeTok{ }\StringTok{"hedgehogSecretPassword"}
\AttributeTok{    }\FunctionTok{ports}\KeywordTok{:}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ 5432:5432}
\AttributeTok{    }\FunctionTok{volumes}\KeywordTok{:}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ ../postgres{-}data:/var/lib/postgresql/data}
\end{Highlighting}
\end{Shaded}

If you are new to docker here's the gist of what the above will do:

\begin{itemize}
\tightlist
\item
  it will start a single service called ``db''
\item
  ``db'' service will use the \texttt{latest} version of the \texttt{postgres} (image) inside the docker container (\texttt{latest} version as tagged per \url{https://hub.docker.com/_/postgres/})
\item
  we map TCP port 5432 in the container to port 5432 on the Docker host(format container\_port:hosts\_port)
\item
  we set up environmental variable inside the docker container that will be used by the Postgres app as a password for the default (\texttt{postgres}) user
\item
  \texttt{volumes} option maps the directory from inside of the container to the host. This way we will keep the state of the database between restarts.
\end{itemize}

\newpage

We can now start the service using \texttt{docker-compose}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ docker{-}compose up }\AttributeTok{{-}d}
\ExtensionTok{Creating}\NormalTok{ hedgehog\_db\_1 ... done}
\end{Highlighting}
\end{Shaded}

To validate that it works we can run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ docker ps }\AttributeTok{{-}a}
\ExtensionTok{CONTAINER}\NormalTok{ ID   IMAGE             COMMAND                  CREATED         STATUS}
\ExtensionTok{PORTS}\NormalTok{                    NAMES}
\ExtensionTok{98558827b80b}\NormalTok{   postgres:latest   }\StringTok{"docker{-}entrypoint.sh"}\NormalTok{   4 seconds ago   Up 4 seconds}
\ExtensionTok{0.0.0.0:5432{-}}\OperatorTok{\textgreater{}}\NormalTok{5432/tcp   hedgehog\_db\_1}
\end{Highlighting}
\end{Shaded}

\section{\texorpdfstring{Set up \texttt{ecto} inside the \texttt{naive} app}{Set up ecto inside the naive app}}\label{set-up-ecto-inside-the-naive-app}

Let's start by adding database access to the \texttt{naive} application. The first step is to add the \href{https://github.com/elixir-ecto/ecto}{Ecto} module together with the \href{https://github.com/elixir-ecto/postgrex}{Postgrex} ecto's driver package to the \texttt{deps} function inside the \texttt{mix.exs} file. As we are going to use Enums inside Postgres, we need to add the \href{https://github.com/gjaldon/ecto_enum}{EctoEnum} module as well:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:binance\_mock}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:decimal}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:ecto\_sql}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 3.0"}\FunctionTok{\}}\NormalTok{,     }\CommentTok{\# \textless{}= New line}
      \FunctionTok{\{}\VariableTok{:ecto\_enum}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.4"}\FunctionTok{\}}\NormalTok{,    }\CommentTok{\# \textless{}= New line}
      \FunctionTok{\{}\VariableTok{:phoenix\_pubsub}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:postgrex}\NormalTok{, }\StringTok{"\textgreater{}= 0.0.0"}\FunctionTok{\}}\NormalTok{,   }\CommentTok{\# \textless{}= New line}
      \FunctionTok{\{}\VariableTok{:streamer}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Remember about installing those deps using:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix deps.get}
\end{Highlighting}
\end{Shaded}

We can now use the ecto generator to add an the ecto repository to the Naive application:

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{$}\NormalTok{ cd apps}\SpecialCharTok{/}\NormalTok{naive}
\SpecialCharTok{$}\NormalTok{ mix ecto.gen.repo }\SpecialCharTok{{-}}\NormalTok{r Naive.Repo}
\SpecialCharTok{*}\NormalTok{ creating lib}\SpecialCharTok{/}\NormalTok{naive}
\SpecialCharTok{*}\NormalTok{ creating lib}\SpecialCharTok{/}\NormalTok{naive}\SpecialCharTok{/}\NormalTok{repo.ex}
\SpecialCharTok{*}\NormalTok{ updating ..}\SpecialCharTok{/}\NormalTok{..}\SpecialCharTok{/}\NormalTok{config}\SpecialCharTok{/}\NormalTok{config.exs}
\NormalTok{Don}\StringTok{\textquotesingle{}t forget to add your new repo to your supervision tree}
\StringTok{(typically in lib/naive/application.ex):}

\StringTok{    \{Naive.Repo, []\}}

\StringTok{And to add it to the list of Ecto repositories in your}
\StringTok{configuration files (so Ecto tasks work as expected):}

\StringTok{    config :naive,}
\StringTok{      ecto\_repos: [Naive.Repo]}
\end{Highlighting}
\end{Shaded}

Back to the IDE, the generator updated our \texttt{config/config.exs} file with the default access details to the database, we need to modify them to point to our Postgres docker instance as well as add a list of ecto repositories for our naive app (as per instruction above):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,                }\CommentTok{\# \textless{}= added line}
  \VariableTok{ecto\_repos:} \OtherTok{[}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\OtherTok{]}\NormalTok{,   }\CommentTok{\# \textless{}= added line}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock} \CommentTok{\# \textless{}= merged from existing config}

\NormalTok{config }\VariableTok{:naive}\NormalTok{, }\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
  \VariableTok{database:} \StringTok{"naive"}\NormalTok{,                  }\CommentTok{\# \textless{}= updated}
  \VariableTok{username:} \StringTok{"postgres"}\NormalTok{,               }\CommentTok{\# \textless{}= updated}
  \VariableTok{password:} \StringTok{"hedgehogSecretPassword"}\NormalTok{, }\CommentTok{\# \textless{}= updated}
  \VariableTok{hostname:} \StringTok{"localhost"}
\end{Highlighting}
\end{Shaded}

Here we can use \texttt{localhost} as inside the \texttt{docker-compose.yml} file we defined port forwarding from the container to the host(Postgres is available at localhost:5432). We also merged the existing \texttt{binance\_client} setting together with the new \texttt{ecto\_repos} setting.

The last step to be able to communicate with the database using \texttt{Ecto} will be to add the \texttt{Naive.Repo} module(created by generator) to the children list of the \texttt{Naive.Application}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/application.ex}
\OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= added line}
      \FunctionTok{\{}
        \ConstantTok{DynamicSupervisor}\NormalTok{,}
        \VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{, }\VariableTok{name:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}
      \FunctionTok{\}}
    \OtherTok{]}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\section{Create and migrate the DB}\label{create-and-migrate-the-db}

We can now create a new naive database using the \texttt{mix} tool, after that we will be able to generate a migration file that will create the \texttt{settings} table:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix ecto.create }\AttributeTok{{-}r}\NormalTok{ Naive.Repo}
\ExtensionTok{The}\NormalTok{ database for Naive.Repo has been created}
\ExtensionTok{$}\NormalTok{ cd apps/naive}
\ExtensionTok{$}\NormalTok{ mix ecto.gen.migration create\_settings}
\ExtensionTok{*}\NormalTok{ creating priv/repo/migrations}
\ExtensionTok{*}\NormalTok{ creating priv/repo/migrations/20210202223209\_create\_settings.exs}
\end{Highlighting}
\end{Shaded}

We can now copy the current hardcoded settings from the \texttt{Naive.Leader} module and use them as a column list of our new \texttt{settings} table. All of the below alterations need to be done inside the \texttt{change} function of our migration file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/repo/migrations/20210202223209\_create\_settings.exs}
\OperatorTok{...}
  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
\NormalTok{    create table}\FunctionTok{(}\VariableTok{:settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:text}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:chunks}\NormalTok{, }\VariableTok{:integer}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:budget}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:buy\_down\_interval}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:profit\_interval}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:rebuy\_interval}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment we just copied the settings and converted them to columns using the \texttt{add} function. We need now to take care of the \texttt{id} column. We need to pass \texttt{primary\_key:\ false} to the \texttt{create\ table} macro to stop it from creating the default integer-based \texttt{id} column. Instead of that we will define the \texttt{id} column ourselves with \texttt{:uuid} type and pass a flag that will indicate that it's the primary key of the \texttt{settings} table:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/repo/migrations/20210202223209\_create\_settings.exs}
\OperatorTok{...}
\NormalTok{    create table}\FunctionTok{(}\VariableTok{:settings}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:id}\NormalTok{, }\VariableTok{:uuid}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{true}\FunctionTok{)}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

We will also add create and update timestamps that come as a bundle when using the \texttt{timestamps()} function inside the \texttt{create\ table} macro:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/repo/migrations/20210202223209\_create\_settings.exs}
\OperatorTok{...}
\NormalTok{    create table}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
      \OperatorTok{...}

\NormalTok{      timestamps}\FunctionTok{()} \CommentTok{\# \textless{}= both create and update timestamps}
    \KeywordTok{end}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We will add a unique index on the symbol column to avoid any possible duplicates:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/repo/migrations/20210202223209\_create\_settings.exs}
\OperatorTok{...}
\NormalTok{    create table}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
      \OperatorTok{...}
    \KeywordTok{end}

\NormalTok{    create}\FunctionTok{(}\NormalTok{unique\_index}\FunctionTok{(}\VariableTok{:settings}\NormalTok{, }\OtherTok{[}\VariableTok{:symbol}\OtherTok{]}\FunctionTok{))}
  \KeywordTok{end}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We will now add the \texttt{status} field which will be an Enum. It will be defined inside a separate file and \texttt{alias}'ed from our migration, this way we will be able to use it from within the migration and the inside the \texttt{lib} code. First, we will apply changes to our migration and then we will move on to creating the Enum module.
Here's the full implementation of migration for reference:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/repo/migrations/20210202223209\_create\_settings.exs}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateSettings} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}

  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradingStatusEnum}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{TradingStatusEnum}\OperatorTok{.}\NormalTok{create\_type}\FunctionTok{()}

\NormalTok{    create table}\FunctionTok{(}\VariableTok{:settings}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:id}\NormalTok{, }\VariableTok{:uuid}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{true}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:text}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:chunks}\NormalTok{, }\VariableTok{:integer}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:budget}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:buy\_down\_interval}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:profit\_interval}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:rebuy\_interval}\NormalTok{, }\VariableTok{:decimal}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{TradingStatusEnum}\OperatorTok{.}\NormalTok{type}\FunctionTok{()}\NormalTok{, }\VariableTok{default:} \StringTok{"off"}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}

\NormalTok{      timestamps}\FunctionTok{()}
    \KeywordTok{end}

\NormalTok{    create}\FunctionTok{(}\NormalTok{unique\_index}\FunctionTok{(}\VariableTok{:settings}\NormalTok{, }\OtherTok{[}\VariableTok{:symbol}\OtherTok{]}\FunctionTok{))}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That finishes our work on the migration file. We will now focus on \texttt{TradingStatusEnum} implementation. First, we need to create a \texttt{schema} directory inside the \texttt{apps/naive/lib/naive} directory and file called \texttt{trading\_status\_enum.ex} and place below logic (defining the enum) in it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/schema/trading\_status\_enum.ex}
\ImportTok{import} \ConstantTok{EctoEnum}

\NormalTok{defenum}\FunctionTok{(}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradingStatusEnum}\NormalTok{, }\VariableTok{:trading\_status}\NormalTok{, }\OtherTok{[}\VariableTok{:on}\NormalTok{, }\VariableTok{:off}\OtherTok{]}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

We used the \texttt{defenum} macro from the \texttt{ecto\_enum} module to define our enum. It's interesting to point out that we didn't need to define a new module as \texttt{defenum} macro takes care of that for us.

Let's run the migration to create the table, unique index, and the enum:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix ecto.migrate}
\ExtensionTok{00:51:16.757} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  == Running 20210202223209 Naive.Repo.Migrations.CreateSettings.change/0}
\ExtensionTok{forward}
\ExtensionTok{00:51:16.759} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  execute }\StringTok{"CREATE TYPE public.trading\_status AS ENUM (\textquotesingle{}on\textquotesingle{}, \textquotesingle{}off\textquotesingle{})"}
\ExtensionTok{00:51:16.760} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  create table settings}
\ExtensionTok{00:51:16.820} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  create index settings\_symbol\_index}
\ExtensionTok{00:51:16.829} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  == Migrated 20210202223209 in 0.0s}
\end{Highlighting}
\end{Shaded}

We can now create a schema file for the \texttt{settings} table so inside the \texttt{/apps/naive/lib/naive/schema} create a file called \texttt{settings.ex}. We will start with a skeleton implementation of schema file together with the copied list of columns from the migration and convert to \texttt{ecto}'s types using it's \href{https://hexdocs.pm/ecto/Ecto.Schema.html\#module-primitive-types}{docs}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/schema/settings.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Schema}

  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradingStatusEnum}

  \OtherTok{@primary\_key} \FunctionTok{\{}\VariableTok{:id}\NormalTok{, }\VariableTok{:binary\_id}\NormalTok{, }\VariableTok{autogenerate:} \ConstantTok{true}\FunctionTok{\}}

\NormalTok{  schema }\StringTok{"settings"} \KeywordTok{do}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:chunks}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:budget}\NormalTok{, }\VariableTok{:decimal}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:buy\_down\_interval}\NormalTok{, }\VariableTok{:decimal}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:profit\_interval}\NormalTok{, }\VariableTok{:decimal}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:rebuy\_interval}\NormalTok{, }\VariableTok{:decimal}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{TradingStatusEnum}\FunctionTok{)}

\NormalTok{    timestamps}\FunctionTok{()}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Seed symbols' settings}\label{seed-symbols-settings}

So we have all the pieces of implementation to be able to create DB, migrate the \texttt{settings} table, and query it using Ecto. To be able to drop the hardcoded settings from the \texttt{Naive.Leader} we will need to fill our database with the ``default'' setting for each symbol. To achieve that we will define default settings inside the \texttt{config/config.exs} file and we will create a seed script that will fetch all pairs from Binance and insert a new config row inside DB for each one.

Let's start by adding those default values to the config file(we will merge them into the structure defining \texttt{binance\_client} and \texttt{ecto\_repos}):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# config/config.exs}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{ecto\_repos:} \OtherTok{[}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\OtherTok{]}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock}\NormalTok{,}
  \VariableTok{trading:}\NormalTok{ \%}\FunctionTok{\{}
    \VariableTok{defaults:}\NormalTok{ \%}\FunctionTok{\{}
      \VariableTok{chunks:} \DecValTok{5}\NormalTok{,}
      \VariableTok{budget:} \DecValTok{1000}\NormalTok{,}
      \VariableTok{buy\_down\_interval:} \StringTok{"0.0001"}\NormalTok{,}
      \VariableTok{profit\_interval:} \StringTok{"{-}0.0012"}\NormalTok{,}
      \VariableTok{rebuy\_interval:} \StringTok{"0.001"}
    \FunctionTok{\}}
  \FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\newpage

Moving on to the seeding script, we need to create a new file called \texttt{seed\_settings.exs} inside the\\
\texttt{/apps/naive/lib/naive/priv/} directory. Let's start by aliasing the required modules and requiring the \texttt{Logger}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/seed\_settings.exs}
\ImportTok{require} \ConstantTok{Logger}

\ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}
\ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}
\end{Highlighting}
\end{Shaded}

Next, we will get the Binance client from the config:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/seed\_settings.exs}
\OperatorTok{...}
\NormalTok{binance\_client }\OperatorTok{=} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Now, it's time to fetch all the symbols(pairs) that Binance supports:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/seed\_settings.exs}
\OperatorTok{...}
\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Fetching exchange info from Binance to create trading settings"}\FunctionTok{)}

\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbols:}\NormalTok{ symbols}\FunctionTok{\}\}} \OperatorTok{=}\NormalTok{ binance\_client}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
\end{Highlighting}
\end{Shaded}

Now we need to fetch default trading settings from the config file as well as the current timestamp:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/seed\_settings.exs}
\OperatorTok{...}
\NormalTok{\%}\FunctionTok{\{}
  \VariableTok{chunks:}\NormalTok{ chunks,}
  \VariableTok{budget:}\NormalTok{ budget,}
  \VariableTok{buy\_down\_interval:}\NormalTok{ buy\_down\_interval,}
  \VariableTok{profit\_interval:}\NormalTok{ profit\_interval,}
  \VariableTok{rebuy\_interval:}\NormalTok{ rebuy\_interval}
\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:trading}\FunctionTok{)}\OperatorTok{.}\NormalTok{defaults}

\NormalTok{timestamp }\OperatorTok{=} \ConstantTok{NaiveDateTime}\OperatorTok{.}\NormalTok{utc\_now}\FunctionTok{()}
  \OperatorTok{|\textgreater{}} \ConstantTok{NaiveDateTime}\OperatorTok{.}\NormalTok{truncate}\FunctionTok{(}\VariableTok{:second}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

We will use the default settings for all rows to be able to insert data into the database. Normally we wouldn't need to set \texttt{inserted\_at} and \texttt{updated\_at} fields as Ecto would generate those values for us when using \texttt{Repo.insert/2} but we won't be able to use this functionality as it takes a \emph{single} record at the time. We will be using \texttt{Repo.insert\_all/3} which is a bit more low-level function without those nice features like filling timestamps(sadly). Just to be crystal clear - \texttt{Repo.insert/2} takes \emph{at least a couple of seconds}(on my machine) for 1000+ symbols currently supported by Binance, on the other hand \texttt{Repo.insert\_all/3}, will insert all of them in a couple of hundred milliseconds.

As our structs will differ by only the \texttt{symbol} column we can first create a full struct that will serve as a template:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/seed\_settings.exs}
\OperatorTok{...}
\NormalTok{base\_settings }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}
  \VariableTok{symbol:} \StringTok{""}\NormalTok{,}
  \VariableTok{chunks:}\NormalTok{ chunks,}
  \VariableTok{budget:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{budget}\FunctionTok{)}\NormalTok{,}
  \VariableTok{buy\_down\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{buy\_down\_interval}\FunctionTok{)}\NormalTok{,}
  \VariableTok{profit\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{profit\_interval}\FunctionTok{)}\NormalTok{,}
  \VariableTok{rebuy\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{rebuy\_interval}\FunctionTok{)}\NormalTok{,}
  \VariableTok{status:} \StringTok{"off"}\NormalTok{,}
  \VariableTok{inserted\_at:}\NormalTok{ timestamp,}
  \VariableTok{updated\_at:}\NormalTok{ timestamp}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

We will now map each of the retrieved symbols and inject them to the \texttt{base\_settings} structs and pushing all of those to the \texttt{Repo.insert\_all/3} function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/seed\_settings.exs}
\OperatorTok{...}
\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserting default settings for symbols"}\FunctionTok{)}

\NormalTok{maps }\OperatorTok{=}\NormalTok{ symbols}
  \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\NormalTok{base\_settings }\OperatorTok{|} \VariableTok{symbol:} \OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]}\FunctionTok{\}))}

\FunctionTok{\{}\NormalTok{count, }\ConstantTok{nil}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert\_all}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, maps}\FunctionTok{)}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserted settings for }\OtherTok{\#\{}\NormalTok{count}\OtherTok{\}}\StringTok{ symbols"}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\section{\texorpdfstring{Update the \texttt{Naive.Leader} to fetch settings}{Update the Naive.Leader to fetch settings}}\label{update-the-naive.leader-to-fetch-settings}

The final step will be to update the \texttt{Naive.Leader} to fetch the settings from the database. At the top of the module add the following:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Now we need to modify the \texttt{fetch\_symbol\_settings/1} to fetch settings from DB instead of the hardcoded map. We will use \texttt{Repo.get\_by!/3} as we are unable to trade without settings. The second trick used here is \texttt{Map.from\_struct/1} that is required here as otherwise result would become the \texttt{Naive.Schema.Settings} struct(this would cause problems further down the line as we are iterating on the returned map and would get the \texttt{protocol\ Enumerable\ not\ implemented\ for\ \%Naive.Schema.Settings} error):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol\_filters }\OperatorTok{=}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
\NormalTok{    settings }\OperatorTok{=} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{get\_by!}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)}

    \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}
\NormalTok{      symbol\_filters,}
\NormalTok{      settings }\OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}
    \FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We can now run the seeding script to fill our database with the default settings:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps/naive}
\ExtensionTok{$}\NormalTok{ mix run priv/seed\_settings.exs}
\ExtensionTok{18:52:29.341} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Fetching exchange info from Binance to create trading settings}
\ExtensionTok{18:52:31.571} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Inserting default settings for symbols}
\ExtensionTok{18:52:31.645} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Inserted settings for 1276 symbols}
\end{Highlighting}
\end{Shaded}

We can verify that records were indeed inserted into the database by connecting to it using the \texttt{psql} application:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ psql }\AttributeTok{{-}Upostgres} \AttributeTok{{-}hlocalhost}
\ExtensionTok{Password}\NormalTok{ for user postgres: }\CommentTok{\# \textless{}= use \textquotesingle{}postgres\textquotesingle{} password here}
\ExtensionTok{...}
\VariableTok{postgres}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}c}\NormalTok{ naive}
\ExtensionTok{You}\NormalTok{ are now connected to database }\StringTok{"naive"}\NormalTok{ as user }\StringTok{"postgres"}\NormalTok{.}
\VariableTok{naive}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}x}
\ExtensionTok{Expanded}\NormalTok{ display is on.}
\VariableTok{naive}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{SELECT} \PreprocessorTok{*}\NormalTok{ FROM settings}\KeywordTok{;}
\ExtensionTok{{-}[}\NormalTok{ RECORD 1 ]{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\FunctionTok{id}                \KeywordTok{|} \ExtensionTok{159c8f32{-}d571{-}47b2{-}b9d7{-}38bb42868043}
\ExtensionTok{symbol}            \KeywordTok{|} \ExtensionTok{ETHUSDT}
\ExtensionTok{chunks}            \KeywordTok{|} \ExtensionTok{5}
\ExtensionTok{budget}            \KeywordTok{|} \ExtensionTok{1000}
\ExtensionTok{buy\_down\_interval} \KeywordTok{|} \ExtensionTok{0.0001}
\ExtensionTok{profit\_interval}   \KeywordTok{|} \ExtensionTok{{-}0.0012}
\ExtensionTok{rebuy\_interval}    \KeywordTok{|} \ExtensionTok{0.001}
\ExtensionTok{status}            \KeywordTok{|} \ExtensionTok{off}
\ExtensionTok{inserted\_at}       \KeywordTok{|} \ExtensionTok{2021{-}02{-}02}\NormalTok{ 18:52:31}
\ExtensionTok{updated\_at}        \KeywordTok{|} \ExtensionTok{2021{-}02{-}02}\NormalTok{ 18:52:31}

\CommentTok{\# press arrows to scroll, otherwise press \textasciigrave{}q\textasciigrave{}}

\VariableTok{naive}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{SELECT}\NormalTok{ COUNT}\ErrorTok{(}\ExtensionTok{*}\KeywordTok{)} \ExtensionTok{FROM}\NormalTok{ settings}\KeywordTok{;}
\ExtensionTok{{-}[}\NormalTok{ RECORD 1 ]}
\ExtensionTok{count} \KeywordTok{|} \ExtensionTok{1276}

\VariableTok{naive}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}q} \CommentTok{\# \textless{}= to close the \textasciigrave{}psql\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

That confirms that there are 1276 settings inside the database that will allow us to continue trading which we can check by running our app inside the IEx(from the main project's directory):

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{19:20:02.936} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.378.0\textgreater{}\}}
\ExtensionTok{19:20:04.584} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1612293637000}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ NEOUSDT}
\end{Highlighting}
\end{Shaded}

The above log messages confirm that the \texttt{Naive.Leader} was able to fetch settings from the database that were later put into the \texttt{Naive.Trader}'s state and passed to it.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_10}{GitHub}

\chapter{Supervise and autostart streaming}\label{supervise-and-autostart-streaming}

\section{Objectives}\label{objectives-10}

\begin{itemize}
\tightlist
\item
  describe and design the required functionality
\item
  register the \texttt{Streamer.Binance} processes with names
\item
  set up \texttt{ecto} inside the \texttt{streamer} app
\item
  create and migrate the db
\item
  seed default settings
\item
  implement the supervision tree and start streaming functionality
\item
  implement the stop functionality
\item
  implement the autostart streaming functionality
\item
  test the implementation
\end{itemize}

\section{Describe and design the required functionality}\label{describe-and-design-the-required-functionality-2}

At this moment there's no supervision around the streamer processes, whenever an error would occur inside the \texttt{Streamer.Binance} process, it will die and never come back up.

That's less than perfect, but we can use supervisors to the rescue.

We will create a new \texttt{Streamer.DynamicStreamerSupervisor} module inside our \texttt{streamer} application that will supervise the \texttt{Streamer.Binance} processes.

Next, we will consider a list of functionalities that we would like it to provide:

\begin{itemize}
\tightlist
\item
  start streaming. This will require a new \texttt{Streamer.Binance} process started under the\\
  \texttt{Streamer.DynamicStreamerSupervisor}. We will put logic responsible for starting that process inside the \texttt{Streamer.DynamicStreamerSupervisor} module.
\item
  stop streaming. To be able to stop the \texttt{Streamer.Binance} process streaming on a specific symbol, we will need to know that process' PID based only on symbol string(ie. ``ETHUSDT''). To make that possible, we will need to register every \texttt{Streamer.Binance} process with a name that we will be able to ``reverse-engineer'' based only on symbol string for example: \texttt{:"\#\{\_\_MODULE\_\_\}-\#\{symbol\}"}
\item
  autostart streaming. At the start of streaming on a symbol, we should persist that action as a symbol's streaming setting inside the database. We will need to generate a new Ecto.Repo, configure, create and migrate DB (just like in the last chapter for the \texttt{naive} app) to be able to retrieve that list. We will write a logic that will fetch settings of the symbols, autostart the ones that are enabled and place all that logic inside the \texttt{Streamer.DynamicStreamerSupervisor} module. We will introduce a \href{https://hexdocs.pm/elixir/master/Task.html}{Task} child process that will utilize the logic from the \texttt{Streamer.DynamicStreamerSupervisor} to fetch those enabled symbols and start \texttt{Streamer.Binance} processes on startup - we will describe all of this separately in its section in this chapter.
\end{itemize}

\section{\texorpdfstring{Register the \texttt{Streamer.Binance} processes with names}{Register the Streamer.Binance processes with names}}\label{register-the-streamer.binance-processes-with-names}

To be able to perform start/stop streaming on a symbol we will first need to be able to figure out the PID of the \texttt{Streamer.Binance} process that is streaming that symbol.

The first change that we need to apply will be to register \texttt{Streamer.Binance} processes with names by passing the 4th argument to the \texttt{WebSockex.start\_link/4} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"Binance streamer is connecting to websocket "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"stream for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ trade events"}
    \FunctionTok{)}

    \ConstantTok{WebSockex}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \StringTok{"}\OtherTok{\#\{@stream\_endpoint\}\#\{}\ConstantTok{String}\OperatorTok{.}\NormalTok{downcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}\OtherTok{\}}\StringTok{@trade"}\NormalTok{, }\CommentTok{\# \textless{}= lowercase symbol}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \ConstantTok{nil}\NormalTok{,}
      \VariableTok{name:}\NormalTok{ :}\StringTok{"}\OtherTok{\#\{}\ConstantTok{\_\_MODULE\_\_}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"} \CommentTok{\# \textless{}= uppercase symbol}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Few things worth mention here:

\begin{itemize}
\tightlist
\item
  we are getting the uppercase symbol but inside the URL we need to use a lowercase symbol so we will introduce a new separate variable to be used in the URL
\item
  we are registering the process using the uppercase symbol so the name will remain consistent with the \texttt{naive} application's processes
\item
  to register process we are sending keyword list as the 4th argument to custom \texttt{start\_link/4} function of \texttt{WebSockex} module (\href{https://github.com/Azolo/websockex/blob/master/lib/websockex.ex\#L376}{link to source} - again, no need to be afraid of reading the source code in Elixir, that's the beauty of it)
\end{itemize}

\section{\texorpdfstring{Set up \texttt{ecto} inside the \texttt{streamer} app}{Set up ecto inside the streamer app}}\label{set-up-ecto-inside-the-streamer-app}

In the same fashion as in the last chapter, we will need to set up the database inside the \texttt{streamer} app. We will use the same Postgres server(docker container) that we've set up inside docker in the last chapter, just a separate database, so there's no need to update the \texttt{docker-compose.yml} file.

As previously the first step will be to add the \texttt{ecto} modules and Postgres related packages into \texttt{deps} inside the \texttt{mix.exs} file of the \texttt{streamer} app. Additionally, we will add the \texttt{binance} module that we will use to fetch all symbols supported by the exchange(to generate default settings as we've done for the \texttt{naive} application. We are unable to use the \texttt{BinanceMock} as this will cause the circular dependency {[}Binance Mock depends on the streamer app{]}):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/mix.exs}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,    }\CommentTok{\# \textless{}= used to retrieve symbols list(exchangeInfo)}
      \FunctionTok{\{}\VariableTok{:ecto\_sql}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 3.0"}\FunctionTok{\}}\NormalTok{,   }\CommentTok{\# \textless{}= added dependency}
      \FunctionTok{\{}\VariableTok{:ecto\_enum}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.4"}\FunctionTok{\}}\NormalTok{,  }\CommentTok{\# \textless{}= added dependency}
      \FunctionTok{\{}\VariableTok{:jason}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.2"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:phoenix\_pubsub}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:postgrex}\NormalTok{, }\StringTok{"\textgreater{}= 0.0.0"}\FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= added dependency}
      \FunctionTok{\{}\VariableTok{:websockex}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 0.4"}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Run \texttt{mix\ deps.get} to install new dependencies.

We can now use \texttt{ecto} generator to add an \texttt{ecto} repository to the Streamer application:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps/streamer}
\ExtensionTok{$}\NormalTok{ mix ecto.gen.repo }\AttributeTok{{-}r}\NormalTok{ Streamer.Repo}
\ExtensionTok{*}\NormalTok{ creating lib/streamer}
\ExtensionTok{*}\NormalTok{ creating lib/streamer/repo.ex}
\ExtensionTok{*}\NormalTok{ updating ../../config/config.exs}
\ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

Update the config to match access details to Postgres' docker instance:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:streamer}\NormalTok{,             }\CommentTok{\# \textless{}= added line }
  \VariableTok{ecto\_repos:} \OtherTok{[}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\OtherTok{]} \CommentTok{\# \textless{}= added line}

\NormalTok{config }\VariableTok{:streamer}\NormalTok{, }\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
  \VariableTok{database:} \StringTok{"streamer"}\NormalTok{,               }\CommentTok{\# \textless{}= database updated }
  \VariableTok{username:} \StringTok{"postgres"}\NormalTok{,               }\CommentTok{\# \textless{}= username updated}
  \VariableTok{password:} \StringTok{"hedgehogSecretPassword"}\NormalTok{, }\CommentTok{\# \textless{}= password updated}
  \VariableTok{hostname:} \StringTok{"localhost"}
\end{Highlighting}
\end{Shaded}

The last step will be to update the \texttt{children} list of the \texttt{Streamer.Application} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/application.ex}
\OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= repo added}
      \FunctionTok{\{}
        \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
        \VariableTok{name:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{, }\VariableTok{adapter\_name:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\ConstantTok{PG2}
      \FunctionTok{\}}
    \OtherTok{]}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\section{Create and migrate the db}\label{create-and-migrate-the-db-1}

We can now create a new streamer database using the \texttt{mix} tool, after that we will be able to generate a migration file that will create the \texttt{settings} table:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix ecto.create }\AttributeTok{{-}r}\NormalTok{ Streamer.Repo}
\ExtensionTok{The}\NormalTok{ database for Streamer.Repo has been created}
\ExtensionTok{$}\NormalTok{ cd apps/streamer}
\ExtensionTok{$}\NormalTok{ mix ecto.gen.migration create\_settings}
\ExtensionTok{*}\NormalTok{ creating priv/repo/migrations}
\ExtensionTok{*}\NormalTok{ creating priv/repo/migrations/20210203184805\_create\_settings.exs}
\end{Highlighting}
\end{Shaded}

We can safely start just with \texttt{id}, \texttt{symbol} and \texttt{status} columns, where the last one will follow the same enum idea from the previous chapter:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/priv/repo/migrations/20210203184805\_create\_settings.exs}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateSettings} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}

  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{StreamingStatusEnum}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{StreamingStatusEnum}\OperatorTok{.}\NormalTok{create\_type}\FunctionTok{()}

\NormalTok{    create table}\FunctionTok{(}\VariableTok{:settings}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:id}\NormalTok{, }\VariableTok{:uuid}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{true}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:text}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{StreamingStatusEnum}\OperatorTok{.}\NormalTok{type}\FunctionTok{()}\NormalTok{, }\VariableTok{default:} \StringTok{"off"}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
      
\NormalTok{      timestamps}\FunctionTok{()}
    \KeywordTok{end}

\NormalTok{    create}\FunctionTok{(}\NormalTok{unique\_index}\FunctionTok{(}\VariableTok{:settings}\NormalTok{, }\OtherTok{[}\VariableTok{:symbol}\OtherTok{]}\FunctionTok{))}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That finishes our work on the migration file, we need to add the \texttt{StreamingStatusEnum} in the same way as in the last chapter (create a \texttt{schema} directory inside the \texttt{apps/streamer/lib/streamer} directory and a new file called \texttt{streaming\_status\_enum.ex} and place below logic (defining the enum) in it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/schema/streaming\_status\_enum.ex}
\ImportTok{import} \ConstantTok{EctoEnum}

\NormalTok{defenum}\FunctionTok{(}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{StreamingStatusEnum}\NormalTok{, }\VariableTok{:streaming\_status}\NormalTok{, }\OtherTok{[}\VariableTok{:on}\NormalTok{, }\VariableTok{:off}\OtherTok{]}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Let's run the migration to create the table, unique index, and the enum:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix ecto.migrate}
\ExtensionTok{21:31:56.850} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  == Running 20210203184805}
\ExtensionTok{Streamer.Repo.Migrations.CreateSettings.change/0}\NormalTok{ forward}
\ExtensionTok{21:31:56.850} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  execute }\StringTok{"CREATE TYPE public.streaming\_status AS ENUM (\textquotesingle{}on\textquotesingle{}, \textquotesingle{}off\textquotesingle{})"}
\ExtensionTok{21:31:56.851} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  create table settings}
\ExtensionTok{21:31:56.912} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  create index settings\_symbol\_index}
\ExtensionTok{21:31:56.932} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  == Migrated 20210203184805 in 0.0s}
\end{Highlighting}
\end{Shaded}

We can now create a schema file for the \texttt{settings} table. Inside the\\
\texttt{/apps/streamer/lib/streamer/schema} directory create a file called \texttt{settings.ex}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/schema/settings.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Schema}

  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{StreamingStatusEnum}

  \OtherTok{@primary\_key} \FunctionTok{\{}\VariableTok{:id}\NormalTok{, }\VariableTok{:binary\_id}\NormalTok{, }\VariableTok{autogenerate:} \ConstantTok{true}\FunctionTok{\}}

\NormalTok{  schema }\StringTok{"settings"} \KeywordTok{do}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{StreamingStatusEnum}\FunctionTok{)}

\NormalTok{    timestamps}\FunctionTok{()}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We are now ready to query the table but first, we need to insert the default settings into the database.

\section{Seed default settings}\label{seed-default-settings}

As with the settings inside the \texttt{naive} application, we will fetch all symbols from binance and bulk insert them into the database.

First let's create a new file called \texttt{seed\_settings.exs} inside the \texttt{apps/streamer/priv} directory. As this file is nearly the same as the one from the last chapter I will skip the lengthy explanation - this is the script:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/priv/seed\_settings.exs}
\ImportTok{require} \ConstantTok{Logger}

\ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}
\ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Fetching exchange info from Binance to create streaming settings"}\FunctionTok{)}

\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbols:}\NormalTok{ symbols}\FunctionTok{\}\}} \OperatorTok{=} \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}

\NormalTok{timestamp }\OperatorTok{=} \ConstantTok{NaiveDateTime}\OperatorTok{.}\NormalTok{utc\_now}\FunctionTok{()}
  \OperatorTok{|\textgreater{}} \ConstantTok{NaiveDateTime}\OperatorTok{.}\NormalTok{truncate}\FunctionTok{(}\VariableTok{:second}\FunctionTok{)}

\NormalTok{base\_settings }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}
  \VariableTok{symbol:} \StringTok{""}\NormalTok{,}
  \VariableTok{status:} \StringTok{"off"}\NormalTok{,}
  \VariableTok{inserted\_at:}\NormalTok{ timestamp,}
  \VariableTok{updated\_at:}\NormalTok{ timestamp}
\FunctionTok{\}}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserting default settings for symbols"}\FunctionTok{)}

\NormalTok{maps }\OperatorTok{=}\NormalTok{ symbols}
  \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\NormalTok{base\_settings }\OperatorTok{|} \VariableTok{symbol:} \OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]}\FunctionTok{\}))}

\FunctionTok{\{}\NormalTok{count, }\ConstantTok{nil}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert\_all}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, maps}\FunctionTok{)}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserted settings for }\OtherTok{\#\{}\NormalTok{count}\OtherTok{\}}\StringTok{ symbols"}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Don't forget to run the seeding script before progressing forward:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps/streamer}
\ExtensionTok{$}\NormalTok{ mix run priv/seed\_settings.exs}
\ExtensionTok{22:03:46.675} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Fetching exchange info from Binance to create streaming settings}
\ExtensionTok{22:03:51.386} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Inserting default settings for symbols}
\ExtensionTok{22:03:51.448} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Inserted settings for 1277 symbols}
\end{Highlighting}
\end{Shaded}

\section{Implement the supervision tree and start streaming functionality}\label{implement-the-supervision-tree-and-start-streaming-functionality}

Let's start by creating a new file called \texttt{dynamic\_streamer\_supervisor.ex} inside the\\
\texttt{/apps/streamer/lib/streamer} directory. Let's start with a default implementation from the \href{https://hexdocs.pm/elixir/master/DynamicSupervisor.html\#module-module-based-supervisors}{docs} (updated with correct module and process names):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/dynamic\_streamer\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{DynamicSupervisor}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, init\_arg, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Next, we will add the \texttt{start\_streaming/1} function at the bottom of the\\
\texttt{Streamer.DynamicStreamerSupervisor} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/dynamic\_streamer\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start\_streaming}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting streaming on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_streaming\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_pid}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ start\_streamer}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Streaming on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already started"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_streaming\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, pid}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

To unpack above - we are checking is there a streamer process already running for the passed symbol and based on the result of that check, we either start the new streaming process(and update the symbol's settings) or just update the symbol's settings.

Inside the \texttt{start\_streaming/1} function, we are using 3 helper functions that we need to add at the bottom of the file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/dynamic\_streamer\_supervisor.ex}
  \KeywordTok{defp}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Process}\OperatorTok{.}\NormalTok{whereis}\FunctionTok{(}\NormalTok{:}\StringTok{"Elixir.Streamer.Binance{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ update\_streaming\_status}\FunctionTok{(}\NormalTok{symbol, status}\FunctionTok{)}
       \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{get\_by}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Changeset}\OperatorTok{.}\NormalTok{change}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\VariableTok{status:}\NormalTok{ status}\FunctionTok{\})}
    \OperatorTok{|\textgreater{}} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{update}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ start\_streamer}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\NormalTok{, symbol}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above functions are quite self-explanatory, \texttt{get\_pid/1} is a convenience wrapper,\\
\texttt{update\_streaming\_status/2} will update the status field for the passed symbol, \texttt{start\_streamer/1} will instruct the \texttt{Streamer.DynamicStreamerSupervisor} to start a new \texttt{Streamer.Binance} process with symbol passed as the first argument.

The last step to get the above function to work(and future ones in this module) would be to add a \texttt{require}, an \texttt{import}, and a few \texttt{alias}es at the top of the module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/dynamic\_streamer\_supervisor.ex}
  \ImportTok{require} \ConstantTok{Logger}

  \ImportTok{import} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Query}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{from:} \DecValTok{2}\OtherTok{]}

  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}
  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}
\end{Highlighting}
\end{Shaded}

\newpage

As we added a new \texttt{start\_streaming/1} logic inside the \texttt{Streamer.DynamicStreamerSupervisor}, we need to replace the \texttt{start\_streaming/1} implementation inside the \texttt{Streamer} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer.ex}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}

  \KeywordTok{def}\NormalTok{ start\_streaming}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicStreamerSupervisor}\OperatorTok{.}\NormalTok{start\_streaming}\FunctionTok{()}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we don't need to put any logic inside the \texttt{Streamer.start\_streaming/1} function, we can just delegate the call straight to the \texttt{Streamer.DynamicStreamerSupervisor} module.

The last step will be to append the \texttt{Streamer.DynamicStreamSupervisor} to the \texttt{children} list of the \texttt{Streamer.Application}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

At this moment our supervision tree already works and all streamer processes are being monitored by the \texttt{Streamer.DynamicStreamerSupervisor}:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_11_03_first_sup_tree} \end{center}

\section{Implement the stop functionality}\label{implement-the-stop-functionality}

As we can see, we are now registering the \texttt{Streamer.Binance} processes with names that contain their symbols. We will be able to retrieve PIDs of those registered processes just by simply passing the symbol string(ie. ``ETHUSDT'') into \texttt{get\_pid/1}, which will allow us to then request termination of those processes by the \texttt{Streamer.DynamicStreamerSupervisor}.

Let's write a \texttt{stop\_streaming/1} logic inside the \texttt{Streamer.DynamicStreamerSupervisor} module(put it above first private function):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/dynamic\_streamer\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ stop\_streaming}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Streaming on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_streaming\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Stopping streaming on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

        \VariableTok{:ok} \OperatorTok{=}
          \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{terminate\_child}\FunctionTok{(}
            \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}\NormalTok{,}
\NormalTok{            pid}
          \FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_streaming\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\texttt{stop\_streaming/1} looks very similar to \texttt{start\_streaming/1}, we are checking is there already a \texttt{Streamer.Binance} process registered for that symbol, and we either ask the\\
\texttt{Streamer.DynamicStreamerSupervisor} to terminate it for us (using the\\
\texttt{DynamicSupervisor.terminate\_child/2} function + update the status) or just update the status to be \texttt{off}.

We need to update the \texttt{Streamer} module to provide the interface to stop streaming on a symbol:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ stop\_streaming}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicStreamerSupervisor}\OperatorTok{.}\NormalTok{stop\_streaming}\FunctionTok{()}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\section{Implement the autostart streaming functionality}\label{implement-the-autostart-streaming-functionality}

Currently, whenever we will shutdown the elixir app, settings persist in the database but streamers are not started on the next init.

To fix this, we will add \texttt{autostart\_streaming/0} inside the \texttt{Streamer.DynamicStreamerSupervisor}.

Note: It very important to differentiate between module and process. We will put our autostarting logic inside the \emph{module} but the \texttt{Streamer.DynamicStreamerSupervisor} \emph{process} won't run it.

We will introduce a new \href{https://hexdocs.pm/elixir/master/Task.html}{Task} process that will execute all the autostarting logic.

That will cover the problem of the Supervisor executing too much business logic (as the Task will execute it), but how will we supervise them together?
At init both will start, the \texttt{Streamer.DynamicStreamerSupervisor} first, and then Task will ask it to start multiple children and that will work fine. The problem occurs when the \texttt{Streamer.DynamicStreamerSupervisor} would die because of any reason. Currently, it's supervised using the \texttt{one\_for\_one} strategy(and the \texttt{Task} would be as well) which means that it will get started again by the \texttt{Streamer.Application} process but at that moment the ``autostarting'' \texttt{Task} won't be there anymore to start streaming on all enabled symbols.

We can clearly see that whenever the \texttt{Streamer.DynamicStreamerSupervisor} will die it needs to be started again \emph{together} with the ``autostart'' \texttt{Task} and this won't fit our current \texttt{Streamer.Application}'s strategy.

In cases like those, a new level of supervision needs to be introduced that will have a different supervision strategy for those ``coupled'' processes. We will rename the process name of the \texttt{Streamer.Application} (which is currently registered as \texttt{Streamer.Supervisor}) to \texttt{Streamer.Application}. Then we will introduce the new \texttt{Streamer.Supervisor} module and register it under the same name. We will attach both \texttt{Streamer.DynamicStreamerSupervisor} and Task to the \texttt{Streamer.Supervisor} and assign it with the \texttt{rest\_for\_one} strategy which will restart the Task whenever\\
\texttt{Streamer.DynamicStreamerSupervisor} would die:

\begin{center}\includegraphics[width=1\linewidth,height=0.5\textheight]{images/chapter_11_04_new_sup_tree} \end{center}

Let's start by creating the \texttt{autostart\_streaming/0} functionality inside the\\
\texttt{Streamer.DynamicStreamerSupervisor}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer/dynamic\_streamer\_supervisor.ex}

  \CommentTok{\# add below after the \textasciigrave{}init/1\textasciigrave{} function}
  \KeywordTok{def}\NormalTok{ autostart\_streaming }\KeywordTok{do}
\NormalTok{    fetch\_symbols\_to\_stream}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{start\_streaming}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
  \KeywordTok{end}

  \CommentTok{\# and this at the end of the module}
  \KeywordTok{defp}\NormalTok{ fetch\_symbols\_to\_stream }\KeywordTok{do}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{all}\FunctionTok{(}
\NormalTok{      from}\FunctionTok{(}\NormalTok{s }\KeywordTok{in} \ConstantTok{Settings}\NormalTok{,}
        \VariableTok{where:}\NormalTok{ s}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"on"}\NormalTok{,}
        \VariableTok{select:}\NormalTok{ s}\OperatorTok{.}\NormalTok{symbol}
      \FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\texttt{autostart\_streaming/0} function fetches all symbols from the \texttt{settings} table with \texttt{status\ ==\ "on"} then it passes them one by one into the \texttt{start\_streaming/1} function using \texttt{Enum.map/2}.

We can now focus on referring to the above autostarting logic inside the new supervisor that we will create now. Let's start by creating a new file called \texttt{supervisor.ex} inside the \texttt{/apps/streamer/lib/streamer/} directory and fill it with default \href{https://hexdocs.pm/elixir/master/Supervisor.html\#module-module-based-supervisors}{Supervisor} implementation:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Supervisor} \KeywordTok{do} \CommentTok{\# \textless{}= updated module name}
  \ImportTok{use} \ConstantTok{Supervisor}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, init\_arg, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}

    \OtherTok{]}

    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\NormalTok{children, }\VariableTok{strategy:} \VariableTok{:one\_for\_one}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now update the strategy to \texttt{rest\_for\_one}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/supervisor.ex}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\NormalTok{children, }\VariableTok{strategy:} \VariableTok{:rest\_for\_one}\FunctionTok{)} \CommentTok{\# \textless{}= strategy updated}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The last step inside our new supervisor will be to add 2 children: \texttt{Streamer.DynamicStreamerSupervisor} and \texttt{Task} (that will autostart the symbol streamers):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/supervisor.ex}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Task}\NormalTok{,}
       \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
         \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}\OperatorTok{.}\NormalTok{autostart\_streaming}\FunctionTok{()}
       \KeywordTok{end}\FunctionTok{\}}
    \OtherTok{]}
    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The final update in this chapter will be to replace the \texttt{Streamer.DynamicStreamerSupervisor} as one of the children inside the \texttt{Streamer.Application} module and update the name that the application process registers under:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/application.ex}
    \OperatorTok{...}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}
        \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
        \VariableTok{name:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{, }\VariableTok{adapter\_name:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\ConstantTok{PG2}
      \FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Supervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}} \CommentTok{\# \textless{}= updated supervisor}
    \OtherTok{]}

\NormalTok{    opts }\OperatorTok{=} \OtherTok{[}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{, }\VariableTok{name:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Application}\OtherTok{]} \CommentTok{\# \textless{}= updated name}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\section{Test the implementation}\label{test-the-implementation-3}

Let's start an IEx session and call the \texttt{start\_streaming/1} function twice for two different symbols and then exit using double Ctrl+c:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"ethusdt"}\KeywordTok{)}
\ExtensionTok{18:51:39.809} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting streaming on ETHUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.370.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"neousdt"}\KeywordTok{)}
\ExtensionTok{18:51:47.288} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting streaming on NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.377.0\textgreater{}\}}
\end{Highlighting}
\end{Shaded}

Now, open a \emph{new} IEx session and look at the output:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}} 
\ExtensionTok{18:53:48.920} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting streaming on ETHUSDT}
\ExtensionTok{18:53:50.306} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting streaming on NEOUSDT}
\end{Highlighting}
\end{Shaded}

We can also confirm that streamer processes are there by using \texttt{:observer.start()}:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_11_05_finished_tree} \end{center}

Inside the same \texttt{iex} session run the following:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{5}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.stop\_streaming}\KeywordTok{(}\StringTok{"neousdt"}\KeywordTok{)} 
\ExtensionTok{18:57:37.205} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Stopping streaming on NEOUSDT}
\ExtensionTok{\{:ok,}
 \ExtensionTok{\%Streamer.Schema.Settings\{}
   \ExtensionTok{...}
 \ErrorTok{\}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{6}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.stop\_streaming}\KeywordTok{(}\StringTok{"ethusdt"}\KeywordTok{)}
\ExtensionTok{18:57:51.553} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Stopping streaming on ETHUSDT}
\ExtensionTok{\{:ok,}
 \ExtensionTok{\%Streamer.Schema.Settings\{}
   \ExtensionTok{...}
 \ErrorTok{\}\}}
\end{Highlighting}
\end{Shaded}

Stop the IEx session and start a new one - streamers shouldn't be autostarted anymore.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_11}{GitHub}

\chapter{Start, stop, shutdown and autostart trading}\label{start-stop-shutdown-and-autostart-trading}

\section{Objectives}\label{objectives-11}

\begin{itemize}
\tightlist
\item
  describe and design the required functionality
\item
  (re-)implement the start trading functionality
\item
  implement the stop trading functionality
\item
  implement the autostart trading functionality
\item
  implement the shutdown trading functionality
\item
  test the implementation
\end{itemize}

\section{Describe and design the required functionality}\label{describe-and-design-the-required-functionality-3}

In the 10th chapter, we've introduced the Postgres database inside the \texttt{naive} application together with the settings per symbol.

In this chapter, we will progress forward to provide additional trading functionality that will be similar to the functionality implemented in the last chapter for the \texttt{streaming} application:

\begin{itemize}
\tightlist
\item
  \textbf{stop trading} - as the \texttt{Naive.SymbolSupervisor} processes are registered with names that can be easily reverse engineered, we should be able to utilize the \texttt{Process.where\_is/1} function to retrieve the PIDs and instruct the \texttt{Naive.DynamicSymbolSupervisor} to terminate those child processes. Again, we need to put that logic somewhere so we will implement the \texttt{Naive.DynamicSymbolSupervisor} as a full module using the \texttt{DynamicSupervisor} behavior.
\item
  \textbf{start\_trading} - as our \texttt{Naive.DynamicSymbolSupervisor} will now be a module we will be able to remove the \texttt{start\_trading/1} implementation from the \texttt{Naive} module and reimplement it inside the \texttt{Naive.DynamicSymbolSupervisor} module. It will follow the same pattern of checking for PID, starting the \texttt{Naive.SymbolSupervisor} process and flipping the \texttt{status} flag inside the \texttt{settings} table's row for that symbol.
\item
  \textbf{shutdown trading} - sometimes abruptly stopping trading won't be the best solution, it would be better to allow the \texttt{Naive.Trader} processes to finish their ongoing trades. To be able to do that we will need to inform the \texttt{Naive.Leader} process assigned to the symbol that the settings for that symbol have been updated and that should cause the \texttt{Naive.Leader} process to withhold starting new \texttt{Naive.Trader} processes and terminate the whole tree when the last trader will finish.
\item
  \textbf{autostart trading} - this will be a very similar implementation to the one from the last chapter. It will require introducing a new supervisor(we will follow the same naming convention: rename \texttt{Naive.Application}'s registered process name to \texttt{Naive.Application}, create a new supervisor called \texttt{Naive.Supervisor}) and utilize the \texttt{Task} process to execute the autostarting logic.
\end{itemize}

\begin{center}\includegraphics[width=1\linewidth,height=0.5\textheight]{images/chapter_12_02_sup_diagram} \end{center}

\section{(Re-)Implement the start trading functionality}\label{re-implement-the-start-trading-functionality}

To (re-)implement the \texttt{start\_trading/1} functionality we will need to create a new file called\\
\texttt{dynamic\_symbol\_supervisor.ex} inside the \texttt{/apps/naive/lib/naive} directory that will use the\\
\texttt{DynamicSupervisor} behavior. Previously we have been using default \texttt{DynamicSupervisor} implementation(one of the children of the \texttt{Naive.Application} - to be substituted with the below module):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor} \KeywordTok{do} \CommentTok{\# \textless{}= module updated}
  \ImportTok{use} \ConstantTok{DynamicSupervisor}

  \ImportTok{require} \ConstantTok{Logger} \CommentTok{\# \textless{}= Logger added}

  \ImportTok{import} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Query}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{from:} \DecValTok{2}\OtherTok{]} \CommentTok{\# \textless{}= added for querying}

  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}             \CommentTok{\# \textless{}= added for querying/updating}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}  \CommentTok{\# \textless{}= added for querying/updating}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, init\_arg, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above code is a default implementation from the \href{https://hexdocs.pm/elixir/master/DynamicSupervisor.html\#module-module-based-supervisors}{DynamicSupervisor docs} with some additional imports, require and aliases as we will use them in this chapter.

Our \texttt{start\_trading/1} implementation is almost the same as one for the \texttt{streamer} application from the last chapter:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
    
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting trading of }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_pid}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ start\_symbol\_supervisor}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already started"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, pid}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

together with additional helper functions:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \KeywordTok{defp}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Process}\OperatorTok{.}\NormalTok{whereis}\FunctionTok{(}\NormalTok{:}\StringTok{"Elixir.Naive.SymbolSupervisor{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, status}\FunctionTok{)}
       \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{get\_by}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Changeset}\OperatorTok{.}\NormalTok{change}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\VariableTok{status:}\NormalTok{ status}\FunctionTok{\})}
    \OperatorTok{|\textgreater{}} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{update}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ start\_symbol\_supervisor}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\NormalTok{, symbol}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Both implementation and helper functions are almost the same as the ones inside the \texttt{naive} application. It could be tempting to abstract some of the logic away but remember that we should treat all applications in our umbrella project as standalone services that should not share any code if possible(we broke that rule for the \texttt{TradeEvent} struct from the \texttt{streamer} app but we could easily just make a lib with that struct that would be shared between two applications). I would shy away from sharing any business logic between applications in the umbrella project.

There are two additional places where we need to make updates to get our \texttt{start\_trading/1} to work again:

\begin{itemize}
\tightlist
\item
  we need to update the \texttt{children} list inside the \texttt{Naive.Application}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/application.ex}
    \OperatorTok{...}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}} \CommentTok{\# \textless{}= replacement of DynamicSupervisor}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  we need to replace the \texttt{start\_trading/1} implementation inside the \texttt{Naive} module to \texttt{defdelegate} macro(as we don't have any logic to run there):
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive.ex}
\OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}

  \KeywordTok{defdelegate}\NormalTok{ start\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}\NormalTok{, }\VariableTok{to:} \ConstantTok{DynamicSymbolSupervisor}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

At this moment we are again able to use the \texttt{Naive.start\_trading/1} function to start trading on a symbol (behind the scenes it will use logic from the new \texttt{Naive.DynamicSymbolSupervisor} module).

\section{Implement the stop trading functionality}\label{implement-the-stop-trading-functionality}

Stop trading will require a change in two places, first inside the \texttt{Naive.DynamicSymbolSupervisor} where we will place the termination logic:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ stop\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Stopping trading of }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

        \VariableTok{:ok} \OperatorTok{=}
          \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{terminate\_child}\FunctionTok{(}
            \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{,}
\NormalTok{            pid}
          \FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)}
    \KeywordTok{end}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The second change we need to make is to create a forwarding interface using \texttt{defdelegate} inside the \texttt{Naive} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive.ex}
  \OperatorTok{...}
  \KeywordTok{defdelegate}\NormalTok{ stop\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}\NormalTok{, }\VariableTok{to:} \ConstantTok{DynamicSymbolSupervisor}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

That pretty much finishes the \texttt{stop\_trading/1} functionality. We are now able to start and stop(what was previously not available) trading on a symbol.

\section{Implement the autostart trading functionality}\label{implement-the-autostart-trading-functionality}

To implement the autostarting we will need to (in a similar fashion as in the last chapter) add a new supervision level that will be dedicated to supervising the \texttt{Naive.DynamicSymbolSupervisor} and the ``autostarting'' \texttt{Task}.

Let's create a new file called \texttt{supervisor.ex} inside the \texttt{/apps/naive/lib/naive} directory and (as in the last chapter) we will add the \texttt{Naive.DynamicSymbolSupervisor} and the \texttt{Task} to its children list. We will also update the supervision strategy to \texttt{:rest\_for\_one}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Supervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Supervisor}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, init\_arg, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,                 }\CommentTok{\# \textless{}= added}
      \FunctionTok{\{}\ConstantTok{Task}\NormalTok{,                                               }\CommentTok{\# \textless{}= added}
       \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}                                               \CommentTok{\# \textless{}= added}
         \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\OperatorTok{.}\NormalTok{autostart\_trading}\FunctionTok{()} \CommentTok{\# \textless{}= added}
       \KeywordTok{end}\FunctionTok{\}}                                                \CommentTok{\# \textless{}= added}
    \OtherTok{]}

    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\NormalTok{children, }\VariableTok{strategy:} \VariableTok{:rest\_for\_one}\FunctionTok{)} \CommentTok{\# \textless{}= strategy updated}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we need to swap the \texttt{Naive.DynamicSymbolSupervisor} to \texttt{Naive.Supervisor} in the \texttt{children} list of the \texttt{Naive.Application}, as well as update the registered process' name of the \texttt{Naive.Application}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/application.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Supervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}} \CommentTok{\# \textless{}= replacement for DynamicSymbolSupervisor}
    \OtherTok{]}

\NormalTok{    opts }\OperatorTok{=} \OtherTok{[}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{, }\VariableTok{name:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Application}\OtherTok{]} \CommentTok{\# \textless{}= name updated}
\end{Highlighting}
\end{Shaded}

\newpage

Finally, we need to implement \texttt{autostart\_trading/0} inside the \texttt{Naive.DynamicSymbolSupervisor} module as our new \texttt{Task} refers to it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \OperatorTok{...}
  \CommentTok{\# add the below function after the \textasciigrave{}init/1\textasciigrave{} function}
  \KeywordTok{def}\NormalTok{ autostart\_trading }\KeywordTok{do}
\NormalTok{    fetch\_symbols\_to\_trade}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{start\_trading}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
  \KeywordTok{end}
 
  \OperatorTok{...}

  \CommentTok{\# and this helper at the end of the module}
  \KeywordTok{defp}\NormalTok{ fetch\_symbols\_to\_trade }\KeywordTok{do}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{all}\FunctionTok{(}
\NormalTok{      from}\FunctionTok{(}\NormalTok{s }\KeywordTok{in} \ConstantTok{Settings}\NormalTok{,}
        \VariableTok{where:}\NormalTok{ s}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"on"}\NormalTok{,}
        \VariableTok{select:}\NormalTok{ s}\OperatorTok{.}\NormalTok{symbol}
      \FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Those are the same (excluding updated function names) as inside the \texttt{streamer} application. We are fetching enabled symbols and starting new \texttt{Naive.SymbolSupervisor} processes for each one.

At this moment we can already see our implementation in action:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_12_01_autostarting_sup_tree} \end{center}

At this moment we are able to test the current implementation inside the IEx:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"ethusdt"}\KeywordTok{)}
\ExtensionTok{21:35:30.207} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting trading of ETHUSDT}
\ExtensionTok{21:35:30.261} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on ETHUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.372.0\textgreater{}\}}
\ExtensionTok{21:35:33.344} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1612647333342}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ ETHUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"neousdt"}\KeywordTok{)}    
\ExtensionTok{21:35:54.128} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting trading of NEOUSDT}
\ExtensionTok{21:35:54.169} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.383.0\textgreater{}\}}
\ExtensionTok{21:35:56.007} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1612647356007}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ NEOUSDT}
\ExtensionTok{21:38:07.699} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Stopping trading of NEOUSDT}
\ExtensionTok{\{:ok,}
 \ExtensionTok{\%Naive.Schema.Settings\{}
     \ExtensionTok{...}
 \ErrorTok{\}\}}
\end{Highlighting}
\end{Shaded}

We can now exit the IEx and start a new one:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{21:39:16.894} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting trading of ETHUSDT}
\ExtensionTok{21:39:16.938} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on ETHUSDT}
\ExtensionTok{21:39:18.786} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1612647558784}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ ETHUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

The above logs confirm that the \texttt{naive} application autostarts the previously enabled symbols(using the \texttt{start\_trading/1} function) as well as \texttt{stop\_trading/1} updates the status inside the database (so the symbol isn't autostarted at the next initialization).

\section{Implement the shutdown trading functionality}\label{implement-the-shutdown-trading-functionality}

Last but not least, we will move on to the \texttt{shutdown\_trading/1} functionality. Let's start with the simplest part which is delegating the function call to the \texttt{Naive.DynamicSymbolSupervisor} module from the \texttt{Naive} module(interface):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive.ex}
  \OperatorTok{...}
  \KeywordTok{defdelegate}\NormalTok{ shutdown\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}\NormalTok{, }\VariableTok{to:} \ConstantTok{DynamicSymbolSupervisor}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Next, we will create a \texttt{shutdown\_trading/1} function inside the \texttt{Naive.DynamicSymbolSupervisor} module where we will check is there any trading going on for that symbol(the same as for start/stop), and in case of trading happening we will inform the \texttt{Naive.Leader} process handling that symbol that settings have been updated:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ shutdown\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)}

\NormalTok{      \_pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Shutdown of trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ initialized"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"shutdown"}\FunctionTok{)}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:settings\_updated}\NormalTok{, settings}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The crucial part of the implementation above is the \texttt{notify(:settings\_updated,\ settings)} where we inform the \texttt{Naive.Leader} process that it needs to update trading settings.

Currently, the \texttt{Naive.Leader} module does \emph{not} support updating the settings after startup - let's add a new interface function together with a callback function that will handle settings updating:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \CommentTok{\# add the below function as the last clause of the \textasciigrave{}notify\textasciigrave{} function}
  \KeywordTok{def}\NormalTok{ notify}\FunctionTok{(}\VariableTok{:settings\_updated}\NormalTok{, settings}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{call}\FunctionTok{(}
\NormalTok{      :}\StringTok{"}\OtherTok{\#\{}\ConstantTok{\_\_MODULE\_\_}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{settings}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:update\_settings}\NormalTok{, settings}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}

  \CommentTok{\# add the below handler function as the last clause of \textasciigrave{}handle\_call\textasciigrave{} function}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:update\_settings}\NormalTok{, new\_settings}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_,}
\NormalTok{        state}
      \FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{settings:}\NormalTok{ new\_settings}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Ok, we have a way to update the settings of the \texttt{Naive.Leader} process ``on the go'' but what effects should the \texttt{shutdown} state have on the \texttt{Naive.Leader}'s actions?

There are two places that require modification:

\begin{itemize}
\tightlist
\item
  whenever the \texttt{Naive.Trader} process will finish the trade cycle, \texttt{Naive.Leader} process should \emph{not} start a new one, as well as check, was that the last trader process and if that was the case it needs to call the \texttt{Naive.stop\_trading/1} function with its symbol to terminate whole supervision tree for that symbol
\item
  whenever the \texttt{Naive.Leader} process will receive a \texttt{rebuy} notification, it should just ignore it when the symbol is in the \texttt{shutdown} state.
\end{itemize}

Let's look at the updated implementation of the ``end of trade'' handler:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:DOWN}\NormalTok{, \_ref, }\VariableTok{:process}\NormalTok{, trader\_pid, }\VariableTok{:normal}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\FunctionTok{\{}\VariableTok{traders:}\NormalTok{ traders, }\VariableTok{symbol:}\NormalTok{ symbol, }\VariableTok{settings:}\NormalTok{ settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ trader finished trade {-} restarting"}\FunctionTok{)}

    \KeywordTok{case} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find\_index}\FunctionTok{(}\NormalTok{traders, }\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{pid }\OperatorTok{==}\NormalTok{ trader\_pid}\FunctionTok{))} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}
          \StringTok{"Tried to restart finished }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ "} \OperatorTok{\textless{}\textgreater{}}
            \StringTok{"trader that leader is not aware of"}
        \FunctionTok{)}

        \ControlFlowTok{if}\NormalTok{ settings}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"shutdown"} \KeywordTok{and}\NormalTok{ traders }\OperatorTok{==} \OtherTok{[]} \KeywordTok{do} \CommentTok{\# \textless{}= additional check}
          \ConstantTok{Naive}\OperatorTok{.}\NormalTok{stop\_trading}\FunctionTok{(}\NormalTok{state}\OperatorTok{.}\NormalTok{symbol}\FunctionTok{)}
        \KeywordTok{end}

        \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}

\NormalTok{      index }\OperatorTok{{-}\textgreater{}}
\NormalTok{        new\_traders }\OperatorTok{=}
          \ControlFlowTok{if}\NormalTok{ settings}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"shutdown"} \KeywordTok{do} \CommentTok{\# \textless{}= refactored code}
            \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}
              \StringTok{"The leader won\textquotesingle{}t start a new trader on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ "} \OperatorTok{\textless{}\textgreater{}}
                \StringTok{"as symbol is in the \textquotesingle{}shutdown\textquotesingle{} state"}
            \FunctionTok{)}
            
            \ControlFlowTok{if}\NormalTok{ length}\FunctionTok{(}\NormalTok{traders}\FunctionTok{)} \OperatorTok{==} \DecValTok{1} \KeywordTok{do}
              \ConstantTok{Naive}\OperatorTok{.}\NormalTok{stop\_trading}\FunctionTok{(}\NormalTok{state}\OperatorTok{.}\NormalTok{symbol}\FunctionTok{)}
            \KeywordTok{end}
            
            \ConstantTok{List}\OperatorTok{.}\NormalTok{delete\_at}\FunctionTok{(}\NormalTok{traders, index}\FunctionTok{)}
          \ControlFlowTok{else}
\NormalTok{            new\_trader\_data }\OperatorTok{=}\NormalTok{ start\_new\_trader}\FunctionTok{(}\NormalTok{fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{))}
            \ConstantTok{List}\OperatorTok{.}\NormalTok{replace\_at}\FunctionTok{(}\NormalTok{traders, index, new\_trader\_data}\FunctionTok{)}
          \KeywordTok{end}

        \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{traders:}\NormalTok{ new\_traders}\FunctionTok{\}\}}
    \KeywordTok{end}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

As visible in the above code, whenever the \texttt{Naive.Trader} process will finish the trade cycle, the \texttt{Naive.Leader} process will check can it find a record of that trader in its state (no changes here). We will modify the callback so the leader process will check the \texttt{settings.status}. In the \texttt{shutdown} status it checks wheater it was the last trader in the \texttt{traders} list, to terminate the whole tree at that time(using the \texttt{Naive.stop\_trading/1} function).

The second callback that we need to modify is the \texttt{rebuy} triggered:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/leader.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:rebuy\_triggered}\NormalTok{, new\_trader\_state}\FunctionTok{\}}\NormalTok{,}
        \FunctionTok{\{}\NormalTok{trader\_pid, \_}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\FunctionTok{\{}\VariableTok{traders:}\NormalTok{ traders, }\VariableTok{symbol:}\NormalTok{ symbol, }\VariableTok{settings:}\NormalTok{ settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find\_index}\FunctionTok{(}\NormalTok{traders, }\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{pid }\OperatorTok{==}\NormalTok{ trader\_pid}\FunctionTok{))} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Rebuy triggered by trader that leader is not aware of"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}}

\NormalTok{      index }\OperatorTok{{-}\textgreater{}}
\NormalTok{        old\_trader\_data }\OperatorTok{=} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{at}\FunctionTok{(}\NormalTok{traders, index}\FunctionTok{)}
\NormalTok{        new\_trader\_data }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{old\_trader\_data }\OperatorTok{|} \VariableTok{:state} \OperatorTok{=\textgreater{}}\NormalTok{ new\_trader\_state}\FunctionTok{\}}
\NormalTok{        updated\_traders }\OperatorTok{=} \ConstantTok{List}\OperatorTok{.}\NormalTok{replace\_at}\FunctionTok{(}\NormalTok{traders, index, new\_trader\_data}\FunctionTok{)}

\NormalTok{        updated\_traders }\OperatorTok{=}
          \ControlFlowTok{if}\NormalTok{ settings}\OperatorTok{.}\NormalTok{chunks }\OperatorTok{==}\NormalTok{ length}\FunctionTok{(}\NormalTok{traders}\FunctionTok{)} \KeywordTok{do}
            \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"All traders already started for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
\NormalTok{            updated\_traders}
          \ControlFlowTok{else}
            \ControlFlowTok{if}\NormalTok{ settings}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"shutdown"} \KeywordTok{do}
              \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}
                \StringTok{"The leader won\textquotesingle{}t start a new trader on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ "} \OperatorTok{\textless{}\textgreater{}}
                  \StringTok{"as symbol is in the \textquotesingle{}shutdown\textquotesingle{} state"}
              \FunctionTok{)}

\NormalTok{              updated\_traders}
            \ControlFlowTok{else}
              \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting new trader for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
              \OtherTok{[}\NormalTok{start\_new\_trader}\FunctionTok{(}\NormalTok{fresh\_trader\_state}\FunctionTok{(}\NormalTok{settings}\FunctionTok{))} \OperatorTok{|}\NormalTok{ updated\_traders}\OtherTok{]}
            \KeywordTok{end}
          \KeywordTok{end}

        \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{:traders} \OperatorTok{=\textgreater{}}\NormalTok{ updated\_traders}\FunctionTok{\}\}}
    \KeywordTok{end}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

In the above \texttt{rebuy\_triggered} handler function we added branching on the \texttt{settings.status} and we simply ignore the rebuy notification when the symbol is in the \texttt{shutdown} status.

The final change will be to create a new migration that will update the \texttt{TradingStatusEnum} to have a \texttt{shutdown} option:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps/naive }
\ExtensionTok{$}\NormalTok{ mix ecto.gen.migration update\_trading\_status}
\ExtensionTok{*}\NormalTok{ creating priv/repo/migrations/20210205232303\_update\_trading\_status.exs}
\end{Highlighting}
\end{Shaded}

Inside the generated migration file we need to excute a raw SQL command:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/repo/migrations/20210205232303\_update\_trading\_status.exs}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{UpdateTradingStatus} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}

  \OtherTok{@disable\_ddl\_transaction} \ConstantTok{true}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}\OperatorTok{.}\NormalTok{execute }\StringTok{"ALTER TYPE trading\_status ADD VALUE IF NOT EXISTS \textquotesingle{}shutdown\textquotesingle{}"}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We need to apply the same change to the \texttt{Naive.Schema.TradingStatusEnum}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/schema/trading\_status\_enum.ex}
\ImportTok{import} \ConstantTok{EctoEnum}

\NormalTok{defenum}\FunctionTok{(}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradingStatusEnum}\NormalTok{, }\VariableTok{:trading\_status}\NormalTok{, }\OtherTok{[}\VariableTok{:on}\NormalTok{, }\VariableTok{:off}\NormalTok{, }\VariableTok{:shutdown}\OtherTok{]}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Don't forget to run \texttt{mix\ ecto.migrate} to run the new migration.

We can now test the \texttt{shutdown\_trading/1} functionality inside the IEx:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"ethusdt"}\KeywordTok{)}
\ExtensionTok{21:46:26.651} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting streaming on ETHUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.372.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"ethusdt"}\KeywordTok{)}     
\ExtensionTok{21:46:42.830} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting trading of ETHUSDT}
\ExtensionTok{21:46:42.867} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on ETHUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.379.0\textgreater{}\}}
\ExtensionTok{21:46:44.816} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1612648004814}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ ETHUSDT}
\ExtensionTok{...}
\ExtensionTok{21:47:52.448} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for ETHUSDT by the trader}\ErrorTok{(}\ExtensionTok{1612648004814}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{21:49:58.900} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for ETHUSDT by the trader}\ErrorTok{(}\ExtensionTok{1612648089409}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{21:50:58.927} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for ETHUSDT by the trader}\ErrorTok{(}\ExtensionTok{1612648198900}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{21:53:27.202} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for ETHUSDT by the trader}\ErrorTok{(}\ExtensionTok{1612648326215}\KeywordTok{)}
\ExtensionTok{21:53:27.250} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Rebuy triggered for ETHUSDT by the trader}\ErrorTok{(}\ExtensionTok{1612648325512}\KeywordTok{)}
\ExtensionTok{21:53:27.250} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  All traders already started for ETHUSDT}

\CommentTok{\# at this moment we have 5 \textasciigrave{}Naive.Trader\textasciigrave{} processes trading in parallel}

\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{4}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.shutdown\_trading}\KeywordTok{(}\StringTok{"ethusdt"}\KeywordTok{)}
\ExtensionTok{21:55:01.556} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Shutdown of trading on ETHUSDT initialized}
\ExtensionTok{\{:ok,}
 \ExtensionTok{\%Naive.Schema.Settings\{}
     \ExtensionTok{...}
 \ErrorTok{\}\}}
\ExtensionTok{...}
\ExtensionTok{22:06:58.855} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1612648407202}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for ETHUSDT}
\ExtensionTok{22:06:58.855} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  ETHUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{22:06:58.855} \PreprocessorTok{[}\SpecialStringTok{warn}\PreprocessorTok{]}\NormalTok{  The leader won}\StringTok{\textquotesingle{}t start a new trader on ETHUSDTas symbol is in}
\StringTok{shutdown state}
\StringTok{22:07:50.768 [info]  Trader(1612648325512) finished trade cycle for ETHUSDT}
\StringTok{22:07:50.768 [info]  ETHUSDT trader finished trade {-} restarting}
\StringTok{22:07:50.768 [warn]  The leader won\textquotesingle{}}\NormalTok{t start a new trader on ETHUSDTas symbol is in}
\ExtensionTok{shutdown}\NormalTok{ state}
\ExtensionTok{22:07:50.857} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1612648326215}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for ETHUSDT}
\ExtensionTok{22:07:50.857} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  ETHUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{22:07:50.857} \PreprocessorTok{[}\SpecialStringTok{warn}\PreprocessorTok{]}\NormalTok{  The leader won}\StringTok{\textquotesingle{}t start a new trader on ETHUSDTas symbol is in}
\StringTok{shutdown state}
\StringTok{22:07:51.079 [info]  Trader(1612648089409) finished trade cycle for ETHUSDT}
\StringTok{22:07:51.079 [info]  ETHUSDT trader finished trade {-} restarting}
\StringTok{22:07:51.079 [warn]  The leader won\textquotesingle{}}\NormalTok{t start a new trader on ETHUSDTas symbol is in}
\ExtensionTok{shutdown}\NormalTok{ state}
\ExtensionTok{22:08:05.401} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trader}\ErrorTok{(}\ExtensionTok{1612648004814}\KeywordTok{)} \ExtensionTok{finished}\NormalTok{ trade cycle for ETHUSDT}
\ExtensionTok{22:08:05.401} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  ETHUSDT trader finished trade }\AttributeTok{{-}}\NormalTok{ restarting}
\ExtensionTok{22:08:05.401} \PreprocessorTok{[}\SpecialStringTok{warn}\PreprocessorTok{]}\NormalTok{  The leader won}\StringTok{\textquotesingle{}t start a new trader on ETHUSDTas symbol is in}
\StringTok{shutdown state}
\StringTok{22:08:05.401 [info]  Stopping trading of ETHUSDT}
\end{Highlighting}
\end{Shaded}

As we can see from the logs above, our \texttt{naive} strategy grown from 1 to 5 \texttt{Naive.Trader} processes running in parallel, then we called the \texttt{shutdown\_trading/1} function. In the \texttt{shutdown} status, the \texttt{Naive.Leader} process ignored \texttt{rebuy} notifications and wasn't starting any new \texttt{Naive.Trader} processes as the old ones were finishing. At the moment when the last \texttt{Naive.Trader} process finished the trade cycle, the \texttt{Naive.Leader} called \texttt{stop\_trading/1} on ``it's'' symbol, terminating the whole supervision tree for that symbol.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_12}{GitHub}

\chapter{Abstract duplicated supervision code}\label{abstract-duplicated-supervision-code}

\section{Objectives}\label{objectives-12}

\begin{itemize}
\tightlist
\item
  overview of requirements
\item
  pseudo generalize \texttt{Core.ServiceSupervisor} module
\item
  utilize pseudo generalized code inside the \texttt{Naive.DynamicSymbolSupervisor}
\item
  implement a truly generic \texttt{Core.ServiceSupervisor}
\item
  use the \texttt{Core.ServiceSupervisor} module inside the \texttt{streamer} application
\end{itemize}

\section{Overview of requirements}\label{overview-of-requirements}

In the last few chapters, we went through adding and modifying the dynamic supervision tree around the \texttt{naive} and \texttt{streamer} applications' workers. Initially, we just copied the implementation from the \texttt{streamer} application to the \texttt{naive} application (with a few minor tweaks like log messages). That wasn't the most sophisticated solution and we will address this copy-paste pattern in this chapter.

We will write an ``extension'' of the \texttt{DynamicSupervisor} that allows to start, stop and autostart workers. Just to keep things simple we will create a new application inside our umbrella project where we will place the logic. This will save us from creating a new repo for time being.

Our new \texttt{Core.ServiceSupervisor} module will hold all the logic responsible for starting, stopping, and autostarting worker processes. To limit the boilerplate inside the implementation modules (like \texttt{Naive.DynamicSymbolSupervisor} or \texttt{Streamer.DynamicStreamerSupervisor}) we will utilize the \texttt{use} macro that will dynamically generate low-level wiring for us.

\newpage

\section{Pseudo generalize Core.ServiceSupervisor module}\label{pseudo-generalize-core.servicesupervisor-module}

Let's start by creating a new \emph{non-supervised} application called \texttt{core} inside our umbrella project. At this moment our ``abstraction code'' will sit inside it just to keep things simple as otherwise, we would need to create a new repo and jump between codebases which we will avoid for time being:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps}
\ExtensionTok{$}\NormalTok{ mix new core}
\ExtensionTok{*}\NormalTok{ creating README.md}
\ExtensionTok{*}\NormalTok{ creating .formatter.exs}
\ExtensionTok{*}\NormalTok{ creating .gitignore}
\ExtensionTok{*}\NormalTok{ creating mix.exs}
\ExtensionTok{*}\NormalTok{ creating lib}
\ExtensionTok{*}\NormalTok{ creating lib/core.ex}
\ExtensionTok{*}\NormalTok{ creating test}
\ExtensionTok{*}\NormalTok{ creating test/test\_helper.exs}
\ExtensionTok{*}\NormalTok{ creating test/core\_test.exs}
\ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

We can now create a new directory called \texttt{core} inside the \texttt{apps/core/lib} directory and a new file called \texttt{service\_supervisor.ex} inside it where we will put all abstracted starting/stopping/autostarting logic.

Let's start with an empty module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor} \KeywordTok{do}

\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The first step in our refactoring process will be to move(cut) all of the functions from the \texttt{Naive.DynamicSymbolSupervisor} (excluding the \texttt{start\_link/1}, \texttt{init/1} and \texttt{shutdown\_trading/1}) and put them inside the \texttt{Core.ServiceSupervisor} module which should look as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor} \KeywordTok{do}

  \KeywordTok{def}\NormalTok{ autostart\_trading }\KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ start\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ update\_trading\_status}\FunctionTok{(}\NormalTok{symbol, status}\FunctionTok{)}
       \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ start\_symbol\_supervisor}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ fetch\_symbols\_to\_trade }\KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

All of the above code is \texttt{trading} related - we need to rename functions/logs to be more generic.

Starting with \texttt{autostart\_trading/0} we can rename it to \texttt{autostart\_workers/0}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}       \CommentTok{\# \textless{}= updated function name}
\NormalTok{    fetch\_symbols\_to\_start}\FunctionTok{()}     \CommentTok{\# \textless{}= updated function name}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{start\_worker}\OperatorTok{/}\DecValTok{1}\FunctionTok{)} \CommentTok{\# \textless{}= updated function name}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

As we updated two functions inside the \texttt{autostart\_workers/0} we need to update their implementations.

The \texttt{start\_trading/1} will become \texttt{start\_worker/1}, internally we will inline the\\
\texttt{start\_symbol\_supervisor/1} function(move it's contents inside the \texttt{start\_worker/1} function and remove the \texttt{start\_symbol\_supervisor/1} function) as it's used just once inside this module as well as \texttt{update\_trading\_status/2} need to be renamed to \texttt{update\_status/2}.

The \texttt{fetch\_symbols\_to\_trade/0} will get updated to \texttt{fetch\_symbols\_to\_start/0}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= updated name}
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting trading of }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\FunctionTok{)} \CommentTok{\# \textless{}= updated name}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_pid}\FunctionTok{\}} \OperatorTok{=}
          \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
            \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{,}
            \FunctionTok{\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\NormalTok{, symbol}\FunctionTok{\}}
          \FunctionTok{)}  \CommentTok{\# \^{}\^{}\^{}\^{}\^{}\^{} inlined \textasciigrave{}start\_symbol\_supervisor/1\textasciigrave{}}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already started"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\FunctionTok{)} \CommentTok{\# \textless{}= updated name}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, pid}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}

  \OperatorTok{...}

  \KeywordTok{defp}\NormalTok{ fetch\_symbols\_to\_start }\KeywordTok{do} \CommentTok{\# \textless{}= updated name}
    \OperatorTok{...}
  \KeywordTok{end}  
\end{Highlighting}
\end{Shaded}

Inside the above code we updated the \texttt{update\_trading\_status/2} call to \texttt{update\_status/2} so we need to update the function header to match:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{defp}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, status}\FunctionTok{)} \CommentTok{\# \textless{}= updated name}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
     \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Last function to rename in this module will be the \texttt{stop\_trading/1} to \texttt{stop\_worker/1}, we also need to update calls to \texttt{update\_trading\_status/2} to \texttt{update\_status/2} as it was renamed:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= updated name}
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)} \CommentTok{\# \textless{}= updated name}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Stopping trading of }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

        \VariableTok{:ok} \OperatorTok{=}
          \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{terminate\_child}\FunctionTok{(}
            \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{,}
\NormalTok{            pid}
          \FunctionTok{)}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)} \CommentTok{\# \textless{}= updated name}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment we have a pseudo-generic implementation of \texttt{start\_worker/1} and \texttt{stop\_worker/1} inside the \texttt{Core.ServiceSupervisor} module. Function names are generic but they still refer to \texttt{Repo}, \texttt{Settings}, and other modules specific to the \texttt{naive} app's implementation. We are probably in a worse situation than we have been before starting this refactoring ;) but don't fear this was just the first step on the way to abstract away that starting, stopping, and autostarting code.

\section{Utilize pseudo generalized code inside the Naive DynamicSymbolSupervisor}\label{utilize-pseudo-generalized-code-inside-the-naive-dynamicsymbolsupervisor}

Before we will jump back to the \texttt{naive}'s application modules we need to add the \texttt{core} application the dependencies of the \texttt{naive} application:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:binance\_mock}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:core}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= core dep added }
      \OperatorTok{....}
\end{Highlighting}
\end{Shaded}

Let's get back to the \texttt{Naive.DynamicSymbolSupervisor} where we expect functions that we just cut out to exist like \texttt{start\_trading/1} or \texttt{stop\_trading/1}.

Let's reimplement more generic versions of those functions as just simple calls to the\\
\texttt{Core.ServiceSupervisor} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We also need to update the \texttt{shutdown\_trading/1} function as we removed all the private functions that it relies on:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ shutdown\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= updated name}
    \KeywordTok{case} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}      \CommentTok{\# \textless{}= module added}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)}
                                                \CommentTok{\# \^{}\^{}\^{} updated name + module}

\NormalTok{      \_pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Shutdown of trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ initialized"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"shutdown"}\FunctionTok{)}
                                                \CommentTok{\# \^{}\^{}\^{} updated name + module}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:settings\_updated}\NormalTok{, settings}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we were moving all the private helper functions we didn't make them public so the\\
\texttt{Naive.DynamicSymbolSupervisor} module can use them - we will fix that now together with temporary aliases/require/imports at the top of the \texttt{Core.ServiceSupervisor}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor} \KeywordTok{do}

  \ImportTok{require} \ConstantTok{Logger}                     \CommentTok{\# \textless{}= added require}

  \ImportTok{import} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Query}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{from:} \DecValTok{2}\OtherTok{]} \CommentTok{\# \textless{}= added import}

  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}                   \CommentTok{\# \textless{}= added alias}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}        \CommentTok{\# \textless{}= added alias}

  \OperatorTok{...}

  \KeywordTok{def}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= updated from private to public}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, status}\FunctionTok{)} \CommentTok{\# \textless{}= updated from private to public}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As \texttt{fetch\_symbols\_to\_start/0} is only used internally by the \texttt{Core.ServiceSupervisor} module itself, we don't need to make it public.

We can also remove the \texttt{alias}es and \texttt{import} from the \texttt{Naive.DynamicSymbolSupervisor} as it won't need them anymore.

The next step will be to add \texttt{ecto} to the deps of the \texttt{core} application as it will make db queries now:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:ecto\_sql}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 3.0"}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we modified the interface of the \texttt{Naive.DynamicSymbolSupervisor} (for example renamed \texttt{start\_trading/1} to \texttt{start\_worker/1} and others) we need to modify the \texttt{Naive.Supervisor}'s children list - more specifically the Task process:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/supervisor.ex}
      \OperatorTok{...}
      \FunctionTok{\{}\ConstantTok{Task}\NormalTok{,}
       \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
         \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{()} \CommentTok{\# \textless{}= func name updated}
       \KeywordTok{end}\FunctionTok{\}}
       \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The last step will be to update the interface of the \texttt{naive} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive.ex}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}

  \KeywordTok{def}\NormalTok{ start\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicSymbolSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicSymbolSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ shutdown\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicSymbolSupervisor}\OperatorTok{.}\NormalTok{shutdown\_worker}\FunctionTok{()}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Believe it or not, but at this moment(ignoring all of the warnings because we created a circular dependency between the \texttt{core} and the \texttt{naive} applications - which we will fix in the next steps) our application \emph{runs} just fine! We are able to start and stop trading, autostarting works as well.

\section{\texorpdfstring{Implement a truly generic \texttt{Core.ServiceSupervisor}}{Implement a truly generic Core.ServiceSupervisor}}\label{implement-a-truly-generic-core.servicesupervisor}

Ok. Why did we even do this? What we are aiming for is a separation between the interface of our \texttt{Naive.DynamicSymbolSupervisor} module (like \texttt{start\_worker/1}, \texttt{autostart\_workers/0} and \texttt{stop\_worker/1}) and the implementation which is now placed inside the \texttt{Core.ServiceSupervisor} module.

That's all nice and to-some-extent understandable but \texttt{Core.ServiceSupervisor} module is \emph{not} a generic module. We can't use it inside the \texttt{streaming} application to supervise the \texttt{Streamer.Binance} processes.

So, what's the point? Well, we can make it even more generic!

\subsection{\texorpdfstring{First path starting with the \texttt{fetch\_symbols\_to\_start/0} function}{First path starting with the fetch\_symbols\_to\_start/0 function}}\label{first-path-starting-with-the-fetch_symbols_to_start0-function}

Moving on to full generalization of the \texttt{Core.ServiceSupervisor} module. We will start with the helper functions first as they are the ones doing the work and they need to be truly generalized first:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ fetch\_symbols\_to\_start }\KeywordTok{do}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{all}\FunctionTok{(}
\NormalTok{      from}\FunctionTok{(}\NormalTok{s }\KeywordTok{in} \ConstantTok{Settings}\NormalTok{,}
        \VariableTok{where:}\NormalTok{ s}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"on"}\NormalTok{,}
        \VariableTok{select:}\NormalTok{ s}\OperatorTok{.}\NormalTok{symbol}
      \FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The \texttt{fetch\_symbols\_to\_start/0} function uses \texttt{Repo} and \texttt{Settings} that are aliased at the top of the\\
\texttt{Core.ServiceSupervisor} module. This just won't work with any other applications as Streamer will require its own \texttt{Repo} and \texttt{Settings} modules etc.

To fix that we will \emph{pass} both \texttt{repo} and \texttt{schema} as arguments to the \texttt{fetch\_symbols\_to\_start/0} function which will become \texttt{fetch\_symbols\_to\_start/2}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ fetch\_symbols\_to\_start}\FunctionTok{(}\NormalTok{repo, schema}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= args added}
\NormalTok{    repo}\OperatorTok{.}\NormalTok{all}\FunctionTok{(} \CommentTok{\# \textless{}= lowercase \textasciigrave{}repo\textasciigrave{} is an argument not aliased module}
\NormalTok{      from}\FunctionTok{(}\NormalTok{s }\KeywordTok{in}\NormalTok{ schema, }\CommentTok{\# \textless{}= settings schema module passed as arg}
        \VariableTok{where:}\NormalTok{ s}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"on"}\NormalTok{,}
        \VariableTok{select:}\NormalTok{ s}\OperatorTok{.}\NormalTok{symbol}
      \FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This will have a knock-on effect on any functions that are using \texttt{fetch\_symbols\_to\_start/0} - now they need to use \texttt{fetch\_symbols\_to\_start/2} and pass appropriate \texttt{Repo} and \texttt{Schema} modules.

So, the \texttt{fetch\_symbols\_to\_start/0} is referenced by the \texttt{autostart\_workers/0} - we will need to modify it to pass the repo and schema to the \texttt{fetch\_symbols\_to\_start/2} and as it's inside the \texttt{Core.ServiceSupervisor} module it needs to get them passed as arguments:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ autostart\_workers}\FunctionTok{(}\NormalTok{repo, schema}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= args added}
\NormalTok{    fetch\_symbols\_to\_start}\FunctionTok{(}\NormalTok{repo, schema}\FunctionTok{)} \CommentTok{\# \textless{}= args passed}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{start\_worker}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Going even further down the line, \texttt{autostart\_workers/0} is referenced by the \texttt{autostart\_workers/0} inside the \texttt{Naive.DynamicSymbolSupervisor} module. As this module is (\texttt{naive}) application-specific, it is a place where \texttt{repo} and \texttt{schema} are known from the context - for the \texttt{naive} application \texttt{repo} is the \texttt{Naive.Repo} module and \texttt{schema} is the \texttt{Naive.Schema.Settings} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{(}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,           }\CommentTok{\# \textless{}= new value passed}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings} \CommentTok{\# \textless{}= new value passed}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This finishes the first of multiple paths that we need to follow to fully refactor the \texttt{Core.ServiceSupervisor} module.

\newpage

\subsection{\texorpdfstring{Second path starting with the \texttt{update\_status/2}}{Second path starting with the update\_status/2}}\label{second-path-starting-with-the-update_status2}

Let's don't waste time and start from the other helper function inside the \texttt{Core.ServiceSupervisor} module. This time we will make the \texttt{update\_status/2} function fully generic:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, status, repo, schema}\FunctionTok{)} \CommentTok{\# \textless{}= args added}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    repo}\OperatorTok{.}\NormalTok{get\_by}\FunctionTok{(}\NormalTok{schema, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)} \CommentTok{\# \textless{}= using dynamic repo and schema modules}
    \OperatorTok{|\textgreater{}} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Changeset}\OperatorTok{.}\NormalTok{change}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\VariableTok{status:}\NormalTok{ status}\FunctionTok{\})}
    \OperatorTok{|\textgreater{}}\NormalTok{ repo}\OperatorTok{.}\NormalTok{update}\FunctionTok{()} \CommentTok{\# \textless{}= using dynamic repo module}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As previously we added \texttt{repo} and \texttt{schema} as arguments and modified the body of the function to utilize them instead of hardcoded modules (aliased at the top of the \texttt{Core.ServiceSupervisor} module).

In the same fashion as previously, we need to check ``who'' is using the \texttt{update\_status/2} and update those calls to \texttt{update\_status/4}.

The function is used inside the \texttt{start\_worker/1} and the \texttt{stop\_worker/1} inside the\\
\texttt{Core.ServiceSupervisor} module so as previously we need to bubble them up(pass via arguments to both \texttt{start\_worker/1} and \texttt{stop\_worker/1} functions):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol, repo, schema}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= new args}
    \OperatorTok{...}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\NormalTok{, repo, schema}\FunctionTok{)} \CommentTok{\# \textless{}= args passed}
    \OperatorTok{...}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\NormalTok{, repo, schema}\FunctionTok{)} \CommentTok{\# \textless{}= args passed}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol, repo, schema}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= new args}
    \OperatorTok{...}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\NormalTok{, repo, schema}\FunctionTok{)} \CommentTok{\# \textless{}= args passed}
    \OperatorTok{...}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\NormalTok{, repo, schema}\FunctionTok{)} \CommentTok{\# \textless{}= args passed}
    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we modified both \texttt{start\_worker/1} and \texttt{stop\_worker/1} by adding two additional arguments we need to update all references to them and here is where things branch out a bit.

\newpage

We will start with \texttt{start\_worker/1} function (which is now \texttt{start\_worker/3}) - it's used by the \texttt{autostart\_workers/2} inside \texttt{Core.ServiceSupervisor} module. The \texttt{autostart\_workers/2} function already has \texttt{repo} and \texttt{schema} so we can just pass them to the \texttt{start\_worker/3}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ autostart\_workers}\FunctionTok{(}\NormalTok{repo, schema}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    fetch\_symbols\_to\_start}\FunctionTok{(}\NormalTok{repo, schema}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{start\_worker}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, repo, schema}\FunctionTok{))} \CommentTok{\# \textless{}= args passed}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Both the \texttt{start\_worker/3} and the \texttt{stop\_worker/3} function are used by the functions inside the \texttt{Naive.DynamicSymbolSupervisor} module. We need to pass the \texttt{Repo} and \texttt{Schema} in the same fashion as previously with the \texttt{autostart\_workers/2} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{(}
\NormalTok{      symbol,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,            }\CommentTok{\# \textless{}= new arg passed}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}  \CommentTok{\# \textless{}= new arg passed}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{(}
\NormalTok{      symbol,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,           }\CommentTok{\# \textless{}= new arg passed}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings} \CommentTok{\# \textless{}= new arg passed}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment there's no code inside the \texttt{Core.ServiceSupervisor} module referencing the \texttt{alias}ed \texttt{Repo} nor \texttt{Schema} modules so we can safely remove both aliases - definitely, we are moving in the right direction!

Btw. Our project still works at this stage, we can start/stop trading and it autostarts trading.

\subsection{\texorpdfstring{Third path starting with the \texttt{get\_pid/1} function}{Third path starting with the get\_pid/1 function}}\label{third-path-starting-with-the-get_pid1-function}

Starting again from the most nested helper function - this time the \texttt{get\_pid/1}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Process}\OperatorTok{.}\NormalTok{whereis}\FunctionTok{(}\NormalTok{:}\StringTok{"Elixir.Naive.SymbolSupervisor{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
  \KeywordTok{end}  
\end{Highlighting}
\end{Shaded}

We can see that it has a hardcoded \texttt{Naive.SymbolSupervisor} worker module - we need to make this part dynamic by using the \texttt{worker\_module} argument:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{worker\_module, symbol}\FunctionTok{)} \KeywordTok{do}  \CommentTok{\# \textless{}= arg added}
    \ConstantTok{Process}\OperatorTok{.}\NormalTok{whereis}\FunctionTok{(}\NormalTok{:}\StringTok{"}\OtherTok{\#\{}\NormalTok{worker\_module}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)} \CommentTok{\# \textless{}= arg used}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Moving up to functions that are referencing the \texttt{get\_pid/1} function, those will be the \texttt{start\_worker/3} and the \texttt{stop\_worker/3} function.

As those are the two last functions to be updated, we will look into them more closely to finish our refactoring in this 3rd run. At this moment both need to add \texttt{worker\_module} as both are calling the \texttt{get\_pid/2} function. Looking at both function we can see two other hardcoded details:

\begin{itemize}
\tightlist
\item
  inside log message there are words ``trading'' - we can replace them so we will utilize the \texttt{worker\_module} and \texttt{symbol} arguments
\item
  there are two references to the \texttt{Naive.DynamicSymbolSupervisor} which we will replace with the \texttt{module} argument
\item
  there is one more reference to the \texttt{Naive.SymbolSupervisor} module which we will replace with the \texttt{worker\_module} argument
\end{itemize}

Let's look at updated functions:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \CommentTok{\# module and worker\_module args added vvvv}
  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol, repo, schema, module, worker\_module}\FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{worker\_module, symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= worker\_module passed}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting }\OtherTok{\#\{}\NormalTok{worker\_module}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
                      \CommentTok{\# \^{}\^{}\^{} dynamic text}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\NormalTok{, repo, schema}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_pid}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}\NormalTok{module, }\FunctionTok{\{}\NormalTok{worker\_module, symbol}\FunctionTok{\})}
                                                              \CommentTok{\# \^{}\^{}\^{} args used}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"}\OtherTok{\#\{}\NormalTok{worker\_module}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already started"}\FunctionTok{)}
                        \CommentTok{\# \^{}\^{}\^{} dynamic text}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\NormalTok{, repo, schema}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, pid}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}

  \CommentTok{\# module and worker\_module added as args vvvv}
  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol, repo, schema, module, worker\_module}\FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{worker\_module, symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= worker\_module passed}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"}\OtherTok{\#\{}\NormalTok{worker\_module}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
                             \CommentTok{\# \^{}\^{}\^{} dynamic text}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\NormalTok{, repo, schema}\FunctionTok{)}

\NormalTok{      pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Stopping }\OtherTok{\#\{}\NormalTok{worker\_module}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
                             \CommentTok{\# \^{}\^{}\^{} dynamic text}
        \VariableTok{:ok} \OperatorTok{=} \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{terminate\_child}\FunctionTok{(}\NormalTok{module, pid}\FunctionTok{)} \CommentTok{\# \textless{}= arg used}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\NormalTok{, repo, schema}\FunctionTok{)}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Inside both the \texttt{start\_worker/5} and the \texttt{stop\_worker/5} functions we modified:

\begin{itemize}
\tightlist
\item
  \texttt{get\_pid/1} to pass the \texttt{worker\_module}
\item
  \texttt{Logger}'s messages to use the \texttt{worker\_module} and \texttt{symbol}
\item
  \texttt{DynamicSupervisor}'s functions to use the \texttt{module} and the \texttt{worker\_module}
\end{itemize}

Again, as we modified \texttt{start\_worker/5} we need to make the last change inside the\\
\texttt{Core.ServiceSupervisor} module - \texttt{autostart\_workers/2} uses the \texttt{start\_worker/5} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ autostart\_workers}\FunctionTok{(}\NormalTok{repo, schema, module, worker\_module}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= args added}
\NormalTok{    fetch\_symbols\_to\_start}\FunctionTok{(}\NormalTok{repo, schema}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{start\_worker}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, repo, schema, module, worker\_module}\FunctionTok{))} \CommentTok{\# \textless{}= args added}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Just for reference - the final function headers look as following:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor} \KeywordTok{do}
  \KeywordTok{def}\NormalTok{ autostart\_workers}\FunctionTok{(}\NormalTok{repo, schema, module, worker\_module}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol, repo, schema, module, worker\_module}\FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol, repo, schema, module, worker\_module}\FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{worker\_module, symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, status, repo, schema}\FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ fetch\_symbols\_to\_start}\FunctionTok{(}\NormalTok{repo, schema}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That finishes the 3rd round of updates inside the \texttt{Core.ServiceSupervisor} module, now we need to update the \texttt{Naive.DynamicSymbolSupervisor} module to use updated functions(and pass required arguments):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{(}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,             }\CommentTok{\# \textless{}= added arg}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}  \CommentTok{\# \textless{}= added arg}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{(}
\NormalTok{      symbol,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,             }\CommentTok{\# \textless{}= added arg}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}  \CommentTok{\# \textless{}= added arg}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{(}
\NormalTok{      symbol,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,             }\CommentTok{\# \textless{}= added arg}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}  \CommentTok{\# \textless{}= added arg}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ shutdown\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{get\_pid}\FunctionTok{(}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\NormalTok{, symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= arg added}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"}\OtherTok{\#\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
                                                              \CommentTok{\# \^{}\^{}\^{} updated}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}
          \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}
\NormalTok{            symbol,}
            \StringTok{"off"}\NormalTok{,}
            \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
            \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}
          \FunctionTok{)} \CommentTok{\# \^{}\^{}\^{} args added}

\NormalTok{      \_pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
          \StringTok{"Initializing shutdown of }\OtherTok{\#\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
        \FunctionTok{)}                                     \CommentTok{\# \^{}\^{}\^{} updated}

        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}} \OperatorTok{=}
          \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}
\NormalTok{            symbol,}
            \StringTok{"shutdown"}\NormalTok{,}
            \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
            \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}
          \FunctionTok{)} \CommentTok{\# \^{}\^{}\^{} additional args passed}

        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:settings\_updated}\NormalTok{, settings}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We needed to update referrences inside the \texttt{shutdown\_trading/1} function as well, as it calls \texttt{get\_pid/2} and \texttt{update\_status/4} functions.

We are now done with refactoring the \texttt{Core.ServiceSupervisor} module, it's completely generic and can be used inside both \texttt{streamer} and the \texttt{naive} applications.

At this moment to use the \texttt{Core.ServiceSupervisor} module we need to write interface functions in our supervisors and pass multiple arguments in each one - again, would need to use of copies those functions inside \texttt{streamer} and \texttt{naive} application. In the next section we will look into how could we leverage Elixir \href{https://elixir-lang.org/getting-started/meta/macros.html}{macros} to remove that boilerplate.

\section{\texorpdfstring{Remove boilerplate using \texttt{use} macro}{Remove boilerplate using use macro}}\label{remove-boilerplate-using-use-macro}

Elixir provides a way to \texttt{use} other modules. Idea is that inside the \texttt{Naive.DynamicSymbolSupervisor} module we are \texttt{use}ing the \texttt{DynamicSupervisor} module currently but we could use \texttt{Core.ServiceSupervisor}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}
\end{Highlighting}
\end{Shaded}

To be able to \texttt{use} the \texttt{Core.ServiceSupervisor} module it needs to provide the \texttt{\_\_using\_\_/1} macro. As the simplest content of that macro, we can use here would be just to use the \texttt{DynamicSupervisor} inside:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{defmacro}\NormalTok{ \_\_using\_\_}\FunctionTok{(}\NormalTok{opts}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{IO}\OperatorTok{.}\NormalTok{inspect}\FunctionTok{(}\NormalTok{opts}\FunctionTok{)}
    \KeywordTok{quote} \VariableTok{location:} \VariableTok{:keep} \KeywordTok{do}
      \ImportTok{use} \ConstantTok{DynamicSupervisor}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

How does this work? As an oversimplification, you can think about it as Elixir will look through the contents of \texttt{quote}'s body(everything between \texttt{quote\ ...\ do} and \texttt{end}) in search for the \texttt{unquote} function which can inject dynamic content. All of this will become much clearer as we will go through the first example but the important part is that after executing any potential \texttt{unquote}s inside the \texttt{quote}'s body, Elixir will grab that code as it would be just part of code and place it inside the \texttt{Naive.DynamicSymbolSupervisor} module at compile time(we will also see the result of \texttt{IO.inspect/1} at compilation).

At this moment(after swapping to \texttt{use\ Core.ServiceSupervisor}) our code still works and it's exactly as we would simply have \texttt{use\ DynamicSupervisor} inside the \texttt{Naive.DynamicSymbolSupervisor} module - as at compilation, it will be swapped to it either way(as per contents of the \texttt{\_\_using\_\_/1} macro).

As the \texttt{autostart\_workers/0} function is a part of the boilerplate, we will move it from the \texttt{Naive.DynamicSymbolSupervisor} module to the \texttt{Core.ServiceSupervisor} module inside the \texttt{\_\_using\_\_/1} macro.

Ok, but it has all of those other \texttt{naive} application-specific arguments - where will we get those?

\newpage

That's what that \texttt{opts} argument is for inside the \texttt{\_\_using\_\_/1} macro. When we call\\
\texttt{use\ Core.ServiceSupervisor} we can pass an additional keyword list which will contain all \texttt{naive} application-specific details:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\NormalTok{,}
    \VariableTok{repo:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
    \VariableTok{schema:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
    \VariableTok{module:} \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
    \VariableTok{worker\_module:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}
\end{Highlighting}
\end{Shaded}

We can now update the \texttt{\_\_using\_\_/1} macro to assign all of those details to variables(instead of using \texttt{IO.inspect/1}):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{defmacro}\NormalTok{ \_\_using\_\_}\FunctionTok{(}\NormalTok{opts}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, repo}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:repo}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, schema}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:schema}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, module}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:module}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, worker\_module}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:worker\_module}\FunctionTok{)}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

At this moment we can use those \emph{dynamic} values to generate code that will be specific to the implementation module for example \texttt{autostart\_workers/0} that we moved from the \texttt{Naive.DynamicSymbolSupervisor} module and will need to have different values passed to it(like \texttt{Streamer.Binance} as \texttt{worker\_module}) for the \texttt{streamer} application. We can see that it requires inserting those dynamic values inside the \texttt{autstart\_workers/0} but how to dynamically inject arguments - \texttt{unquote} to the rescue. When we will update the \texttt{autostart\_workers/0} function from:

\begin{Shaded}
\begin{Highlighting}[]
      \CommentTok{\# sample moved code from the \textasciigrave{}Naive.DynamicSymbolSupervisor\textasciigrave{} module}
      \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
          \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{(}
          \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
          \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
          \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
          \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}
        \FunctionTok{)}
      \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

to:

\begin{Shaded}
\begin{Highlighting}[]
      \CommentTok{\# updated code that will become part of the \textasciigrave{}\_\_using\_\_/1\textasciigrave{} macro}
      \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
        \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{(}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{repo}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{schema}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{module}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{worker\_module}\FunctionTok{)}
        \FunctionTok{)}
      \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At the end, generated code that will be ``pasted'' to the \texttt{Naive.DynamicSymbolSupervisor} module at compile time will be:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# compiled code attached to the \textasciigrave{}Naive.DynamicSymbolSupervisor\textasciigrave{} module}
    \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
      \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{(}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{,}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}
      \FunctionTok{)}
    \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This way we can dynamically create functions for any application(for the \texttt{streamer} application, it will generate function call with the \texttt{Streamer.Repo}, \texttt{Streamer.Schema.Settings} args, etc).

We can apply that to all of the passed variables inside the \texttt{autostart\_workers/0} function - just for reference full macro will look as follows:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{defmacro}\NormalTok{ \_\_using\_\_}\FunctionTok{(}\NormalTok{opts}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, repo}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:repo}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, schema}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:schema}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, module}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:module}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, worker\_module}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Keyword}\OperatorTok{.}\NormalTok{fetch}\FunctionTok{(}\NormalTok{opts, }\VariableTok{:worker\_module}\FunctionTok{)}

    \KeywordTok{quote} \VariableTok{location:} \VariableTok{:keep} \KeywordTok{do}
      \ImportTok{use} \ConstantTok{DynamicSupervisor}

      \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
        \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{(}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{repo}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{schema}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{module}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{worker\_module}\FunctionTok{)}
        \FunctionTok{)}
      \KeywordTok{end}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

You can think about the above macro that it will substitute the \texttt{unquote(..)} parts with passed values and then it will grab the whole contents between \texttt{quote\ ...\ do} and \texttt{end} and it will paste it to the \texttt{Naive.DynamicSymbolSupervisor} module at compile-time - we can visualize generated/``pasted'' code as:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# generated by the \textasciigrave{}\_\_using\_\_/1\textasciigrave{} macro injected into the \textasciigrave{}Naive.DynamicSymbolSupervisor\textasciigrave{}}
  \ImportTok{use} \ConstantTok{DynamicSupervisor}

  \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{(}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicSymbolSupervisor}\NormalTok{,}
      \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This is exactly the code that we had before inside the \texttt{Naive.DynamicSymbolSupervisor} module but now it's stored away inside the \texttt{Core.ServiceSupervisor}'s \texttt{\_\_using\_\_/1} macro and it doesn't need to be implemented/copied across twice into two apps anymore.

We can now follow the same principle and move \texttt{start\_worker/1} and \texttt{stop\_worker/1} from the\\
\texttt{Naive.DynamicSymbolSupervisor} module into \texttt{\_\_using\_\_/1} macro inside the \texttt{Core.ServiceSupervisor} module:

\begin{Shaded}
\begin{Highlighting}[]
      \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
      \CommentTok{\# append the below before the end of the \_\_using\_\_/1 macro}
      \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
        \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{(}
\NormalTok{          symbol, }\CommentTok{\# \textless{}= this needs to stay as variable}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{repo}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{schema}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{module}\FunctionTok{)}\NormalTok{, }
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{worker\_module}\FunctionTok{)}
        \FunctionTok{)}
      \KeywordTok{end}

      \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
        \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{(}
\NormalTok{          symbol, }\CommentTok{\# \textless{}= this needs to stay as variable}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{repo}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{schema}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{module}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{worker\_module}\FunctionTok{)}
        \FunctionTok{)}
      \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Here we have an example of an execution time variable called \texttt{symbol} that we should \emph{not} \texttt{unquote} as it will be different per function call (source code should have \texttt{symbol} variable there not for example \texttt{"NEOUSDT"}).

At this moment the \texttt{Naive.DynamicSymbolSupervisor} consists of only \texttt{start\_link/1}, \texttt{init/1} and\\
\texttt{shutdown\_worker/1}, it's under 50 lines of code and works exactly as before refactoring. All of the boilerplate was moved to the \texttt{Core.ServiceSupervisor} module.

We left the \texttt{shutdown\_worker/1} function as it's specific to the \texttt{naive} application, but inside it, we utilize both the \texttt{get\_pid/2} and the \texttt{update\_status/4} functions where we are passing the \texttt{naive} application-specific variables(like \texttt{Naive.Repo}).

To make things even nicer we can create convenience wrappers for those two functions inside the \texttt{\_\_using\_\_/1} macro:

\begin{Shaded}
\begin{Highlighting}[]
      \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
      \CommentTok{\# add below at the end of \textasciigrave{}quote\textasciigrave{} block inside \textasciigrave{}\_\_using\_\_/1\textasciigrave{}}
      \KeywordTok{defp}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
        \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{get\_pid}\FunctionTok{(}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{worker\_module}\FunctionTok{)}\NormalTok{,}
\NormalTok{          symbol}
        \FunctionTok{)}
      \KeywordTok{end}

      \KeywordTok{defp}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, status}\FunctionTok{)} \KeywordTok{do}
        \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}
\NormalTok{          symbol,}
\NormalTok{          status,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{repo}\FunctionTok{)}\NormalTok{,}
          \KeywordTok{unquote}\FunctionTok{(}\NormalTok{schema}\FunctionTok{)}
        \FunctionTok{)}
      \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As those will get compiled and ``pasted'' into the \texttt{Naive.DynamicSymbolSupervisor} module we can utilize them inside the \texttt{shutdown\_worker/1} function as they would be much simpler naive application-specific local functions:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ shutdown\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case}\NormalTok{ get\_pid}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= macro provided function}
      \ConstantTok{nil} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"}\OtherTok{\#\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ already stopped"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)} \CommentTok{\# \textless{}= macro provided function}

\NormalTok{      \_pid }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
          \StringTok{"Initializing shutdown of }\OtherTok{\#\{}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SymbolSupervisor}\OtherTok{\}}\StringTok{ worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
        \FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"shutdown"}\FunctionTok{)} \CommentTok{\# \textless{}= macro provided function}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:settings\_updated}\NormalTok{, settings}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

And now, a very last change - I promise ;) Both the \texttt{start\_link/1} and the \texttt{init/1} functions are still referencing the \texttt{DynamicSupervisor} module which could be a little bit confusing - let's swap those calls to use the \texttt{Core.ServiceSupervisor} module (both to not confuse people and be consistent with the \texttt{use} macro):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_symbol\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, init\_arg, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we don't want/need to do anything different inside the \texttt{Core.ServiceSupervisor} module than the \texttt{DynamicSupervisor} is doing we can just delegate both of those inside the \texttt{Core.ServiceSupervisor} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/service\_supervisor.ex}
  \KeywordTok{defdelegate}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{module, args, opts}\FunctionTok{)}\NormalTok{, }\VariableTok{to:} \ConstantTok{DynamicSupervisor}
  \KeywordTok{defdelegate}\NormalTok{ init}\FunctionTok{(}\NormalTok{opts}\FunctionTok{)}\NormalTok{, }\VariableTok{to:} \ConstantTok{DynamicSupervisor}
\end{Highlighting}
\end{Shaded}

That finishes our refactoring of both the \texttt{Naive.DynamicSymbolSupervisor} and the\\
\texttt{Core.ServiceSupervisor} modules.

We can test to confirm that everything works as expected:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}    
\ExtensionTok{21:42:37.741} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Naive.SymbolSupervisor worker for NEOUSDT}
\ExtensionTok{21:42:37.768} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.464.0\textgreater{}\}}
\ExtensionTok{21:42:39.455} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1614462159452}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ NEOUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.stop\_trading}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)} 
\ExtensionTok{21:43:08.362} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Stopping Elixir.Naive.SymbolSupervisor worker for NEOUSDT}
\ExtensionTok{\{:ok,}
 \ExtensionTok{\%Naive.Schema.Settings\{}
   \ExtensionTok{...}
 \ErrorTok{\}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"HNTUSDT"}\KeywordTok{)}
\ExtensionTok{21:44:08.689} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Naive.SymbolSupervisor worker for HNTUSDT}
\ExtensionTok{21:44:08.723} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on HNTUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.475.0\textgreater{}\}}
\ExtensionTok{21:44:11.182} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1614462251182}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{BREAK:} \ErrorTok{(}\ExtensionTok{a}\KeywordTok{)}\ExtensionTok{bort} \ErrorTok{(}\ExtensionTok{A}\KeywordTok{)}\ExtensionTok{bort}\NormalTok{ with dump }\ErrorTok{(}\ExtensionTok{c}\KeywordTok{)}\ExtensionTok{ontinue} \ErrorTok{(}\ExtensionTok{p}\KeywordTok{)}\ExtensionTok{roc}\NormalTok{ info }\ErrorTok{(}\ExtensionTok{i}\KeywordTok{)}\ExtensionTok{nfo}
       \KeywordTok{(}\ExtensionTok{l}\KeywordTok{)}\ExtensionTok{oaded} \ErrorTok{(}\ExtensionTok{v}\KeywordTok{)}\ExtensionTok{ersion} \ErrorTok{(}\ExtensionTok{k}\KeywordTok{)}\ExtensionTok{ill} \ErrorTok{(}\ExtensionTok{D}\KeywordTok{)}\ExtensionTok{b{-}tables} \ErrorTok{(}\ExtensionTok{d}\KeywordTok{)}\ExtensionTok{istribution}
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{21:47:22.119} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Naive.SymbolSupervisor worker for HNTUSDT}
\ExtensionTok{21:47:22.161} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on HNTUSDT}
\ExtensionTok{21:47:24.213} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1614462444212}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ HNTUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.shutdown\_trading}\KeywordTok{(}\StringTok{"HNTUSDT"}\KeywordTok{)}
\ExtensionTok{21:48:42.003} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing shutdown of Elixir.Naive.SymbolSupervisor worker for}
\ExtensionTok{HNTUSDT}
\ExtensionTok{\{:ok,}
 \ExtensionTok{\%Naive.Schema.Settings\{}
   \ExtensionTok{...}
 \ErrorTok{\}\}}
\end{Highlighting}
\end{Shaded}

The above test confirms that we can start, stop, and shut down trading on a symbol as well as autostarting of trading works.

\section{\texorpdfstring{Use the \texttt{Core.ServiceSupervisor} module inside the \texttt{streamer} application}{Use the Core.ServiceSupervisor module inside the streamer application}}\label{use-the-core.servicesupervisor-module-inside-the-streamer-application}

As we are happy with the implementation of the \texttt{Core.ServiceSupervisor} module we can upgrade the \texttt{streamer} application to use it.

We need to start with adding the \texttt{core} application to the list of dependencies of the \texttt{streamer} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:core}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= core added to deps}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

We can now move on to the \texttt{Streamer.DynamicStreamerSupervisor} where we will remove everything (really everything including \texttt{import}s, \texttt{alias}es and even \texttt{require}) beside the \texttt{start\_link/1} and the \texttt{init/1}. As with the \texttt{Naive.DynamicSymbolSupervisor} we will \texttt{use} the \texttt{Core.ServiceSupervisor} and pass all required options - \emph{full} implementation of the \texttt{Streamer.DynamicStreamerSupervisor} module should look as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/dynamic\_streamer\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\NormalTok{,}
    \VariableTok{repo:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
    \VariableTok{schema:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{,}
    \VariableTok{module:} \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
    \VariableTok{worker\_module:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, init\_arg, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_init\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Core}\OperatorTok{.}\ConstantTok{ServiceSupervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Not much to add here - we are \texttt{use}ing the \texttt{Core.ServiceSupervisor} module and passing options to it so it can macro generates \texttt{streamer} application-specific wrappers(like \texttt{start\_worker/1} or \texttt{stop\_worker/1} with required repo, schema, etc) around generic logic from the \texttt{Core.ServiceSupervisor} module.

Using the \texttt{Core.Servicesupervisor} module will have an impact on the interface of the\\
\texttt{Streamer.DynamicStreamerSupervisor} as it will now provide functions like \texttt{start\_worker/1} instead of \texttt{start\_streaming/1} etc.

As with the \texttt{naive} application, we need to update the Task function inside the \texttt{Streamer.Supervisor} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/supervisor.ex}
      \OperatorTok{...}
      \FunctionTok{\{}\ConstantTok{Task}\NormalTok{,}
       \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
         \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{()}
       \KeywordTok{end}\FunctionTok{\}}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

As well as main \texttt{Streamer} module needs to forward calls instead of delegating:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/streamer/lib/streamer.ex}
  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}

  \KeywordTok{def}\NormalTok{ start\_streaming}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicStreamerSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_streaming}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicStreamerSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{()}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can run a quick test to confirm that indeed everything works as expected:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{22:10:38.813} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Streamer.Binance worker for NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.465.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.stop\_streaming}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{22:10:48.212} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Stopping Elixir.Streamer.Binance worker for NEOUSDT}
\ExtensionTok{\{:ok,}
 \ExtensionTok{\%Streamer.Schema.Settings\{}
   \ExtensionTok{\_\_meta\_\_:} \CommentTok{\#Ecto.Schema.Metadata\textless{}:loaded, "settings"\textgreater{},}
   \ExtensionTok{id:} \StringTok{"db8c9429{-}2356{-}4243{-}a08f{-}0d0e89b74986"}\NormalTok{,}
   \ExtensionTok{inserted\_at:}\NormalTok{ \textasciitilde{}N[2021{-}02{-}25 22:15:16],}
   \ExtensionTok{status:} \StringTok{"off"}\NormalTok{,}
   \ExtensionTok{symbol:} \StringTok{"NEOUSDT"}\NormalTok{,}
   \ExtensionTok{updated\_at:}\NormalTok{ \textasciitilde{}N[2021{-}02{-}27 22:10:48]}
 \ErrorTok{\}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"LTCUSDT"}\KeywordTok{)} 
\ExtensionTok{22:26:03.361} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Streamer.Binance worker for LTCUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.490.0\textgreater{}\}}
\ExtensionTok{BREAK:} \ErrorTok{(}\ExtensionTok{a}\KeywordTok{)}\ExtensionTok{bort} \ErrorTok{(}\ExtensionTok{A}\KeywordTok{)}\ExtensionTok{bort}\NormalTok{ with dump }\ErrorTok{(}\ExtensionTok{c}\KeywordTok{)}\ExtensionTok{ontinue} \ErrorTok{(}\ExtensionTok{p}\KeywordTok{)}\ExtensionTok{roc}\NormalTok{ info }\ErrorTok{(}\ExtensionTok{i}\KeywordTok{)}\ExtensionTok{nfo}
       \KeywordTok{(}\ExtensionTok{l}\KeywordTok{)}\ExtensionTok{oaded} \ErrorTok{(}\ExtensionTok{v}\KeywordTok{)}\ExtensionTok{ersion} \ErrorTok{(}\ExtensionTok{k}\KeywordTok{)}\ExtensionTok{ill} \ErrorTok{(}\ExtensionTok{D}\KeywordTok{)}\ExtensionTok{b{-}tables} \ErrorTok{(}\ExtensionTok{d}\KeywordTok{)}\ExtensionTok{istribution}
\ExtensionTok{\^{}C}
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{22:26:30.775} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Streamer.Binance worker for LTCUSDT}
\end{Highlighting}
\end{Shaded}

This finishes the implementation for both the \texttt{streamer} and the \texttt{naive} application. We are generating dynamic functions(metaprogramming) using Elixir macros which is a cool exercise to go through and feels like superpowers ;)

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_13}{GitHub}

\chapter{Store trade events and orders inside the database}\label{store-trade-events-and-orders-inside-the-database}

\section{Objectives}\label{objectives-13}

\begin{itemize}
\tightlist
\item
  overview of requirements
\item
  create a new \texttt{data\_warehouse} application in the umbrella
\item
  connect to the database using Ecto
\item
  store trade events' data
\item
  store orders' data
\item
  implement supervision
\end{itemize}

\section{Overview of requirements}\label{overview-of-requirements-1}

In the next chapter, we will move on to testing our strategy against historical data(aka backtesting - I will explain that process in the next chapter). What we need to have in place before we will be able to do that is both trade events and orders stored in the database.

Starting with the trade events. The \texttt{streamer} application could store trade events from Binance inside its database but how would that work if we would like to introduce another source of non-streamed trade events(ie. flat files, HTTP polling). It would be better if the \texttt{Streamer.Binance} process would keep on streaming those trade events as it is and we would create a new application that would subscribe to the existing \texttt{TRADE\_EVENTS:\#\{symbol\}} topic and store them in the database.

A similar idea applies to the orders' data. At this moment the \texttt{naive} application uses the Binance module to place orders. We could store them inside the \texttt{naive} application's database but how would that work if we would like to introduce another trading strategy. Holding data in separate databases for each strategy would cause further complications in future reporting, auditing, etc.

To store trade events' and orders' data we will create a new application called \texttt{data\_warehouse} inside our umbrella project. It will subscribe to a \texttt{TRADE\_EVENTS:\#\{symbol\}} stream as well as \texttt{ORDERS:\#\{symbol\}} stream, convert broadcasted data to its own representations(structs) and store it inside the database.

Trade events are already broadcasted to the PubSub topic, orders on the other hand aren't. We will need to modify the \texttt{Naive.Trader} module to broadcast the new and updated orders to the \texttt{ORDERS:\#\{symbol\}} topic.

After implementing the basic worker that will store the incoming data(trade events and orders) inside the database, we will look into adding a supervision tree utilizing \href{https://hexdocs.pm/elixir/master/Registry.html}{Elixir Registry}. It will allow us to skip registering every worker with a unique atom and will offer an easy lookup to fetch PIDs instead.

\section{\texorpdfstring{Create a new \texttt{data\_warehouse} application in the umbrella}{Create a new data\_warehouse application in the umbrella}}\label{create-a-new-data_warehouse-application-in-the-umbrella}

Let's start by creating a new application called \texttt{data\_warehouse} inside our umbrella:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps}
\ExtensionTok{$}\NormalTok{ mix new data\_warehouse }\AttributeTok{{-}{-}sup}
\ExtensionTok{*}\NormalTok{ creating README.md}
\ExtensionTok{*}\NormalTok{ creating .formatter.exs}
\ExtensionTok{*}\NormalTok{ creating .gitignore}
\ExtensionTok{*}\NormalTok{ creating mix.exs}
\ExtensionTok{*}\NormalTok{ creating lib}
\ExtensionTok{*}\NormalTok{ creating lib/data\_warehouse.ex}
\ExtensionTok{*}\NormalTok{ creating lib/data\_warehouse/application.ex}
\ExtensionTok{*}\NormalTok{ creating test}
\ExtensionTok{*}\NormalTok{ creating test/test\_helper.exs}
\ExtensionTok{*}\NormalTok{ creating test/data\_warehouse\_test.exs}
\ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

\section{Connect to the database using Ecto}\label{connect-to-the-database-using-ecto}

We can now follow similar steps as previously and add required dependencies (like the \texttt{ecto}) to its \texttt{deps} by modifying its \texttt{mix.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:ecto\_sql}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 3.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:ecto\_enum}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.4"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:phoenix\_pubsub}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:postgrex}\NormalTok{, }\StringTok{"\textgreater{}= 0.0.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:streamer}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Additionally, we added the \texttt{phoenix\_pubsub}(to subscribe to the PubSub topic), the \texttt{streamer} application(to use its \texttt{Streamer.Binance.TradeEvent} struct) and the \texttt{binance} package(to pattern match it's structs).

We can now jump back to the terminal to install added dependencies and generate a new \texttt{Ecto.Repo} module:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix deps.get}
  \ExtensionTok{...}
\ExtensionTok{$}\NormalTok{ cd apps/data\_warehouse }
\ExtensionTok{$}\NormalTok{ mix ecto.gen.repo }\AttributeTok{{-}r}\NormalTok{ DataWarehouse.Repo}
\ExtensionTok{*}\NormalTok{ creating lib/data\_warehouse}
\ExtensionTok{*}\NormalTok{ creating lib/data\_warehouse/repo.ex}
\ExtensionTok{*}\NormalTok{ updating ../../config/config.exs}
\end{Highlighting}
\end{Shaded}

Before we will be able to create migrations that will create our tables we need to update the generated configuration inside the \texttt{config/config.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\OperatorTok{...}
\NormalTok{config }\VariableTok{:data\_warehouse}\NormalTok{,            }\CommentTok{\# \textless{}= added line}
  \VariableTok{ecto\_repos:} \OtherTok{[}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OtherTok{]} \CommentTok{\# \textless{}= added line}

\NormalTok{config }\VariableTok{:data\_warehouse}\NormalTok{, }\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
  \VariableTok{database:} \StringTok{"data\_warehouse"}\NormalTok{,         }\CommentTok{\# \textless{}= updated line}
  \VariableTok{username:} \StringTok{"postgres"}\NormalTok{,               }\CommentTok{\# \textless{}= updated line}
  \VariableTok{password:} \StringTok{"hedgehogSecretPassword"}\NormalTok{, }\CommentTok{\# \textless{}= updated line}
  \VariableTok{hostname:} \StringTok{"localhost"}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

and add the \texttt{DataWarehouse.Repo} module to the children list of the \texttt{DataWarehouse.Application}'s process:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/application.ex}
    \OperatorTok{...}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}
    \OtherTok{]}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The last step will be to create a database by running \texttt{mix\ ecto.create\ -r\ DataWarehouse.Repo} command.

This ends up the setup of the \texttt{Ecto} - we can now move on to the implementation of storing the orders and the trade events.

\newpage

\section{Store trade events' data}\label{store-trade-events-data}

The first step to store trade events inside the database will be to create a table that will hold our data. We will start by creating the migration:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ cd apps}\OperatorTok{/}\NormalTok{data\_warehouse}
\NormalTok{$ mix ecto}\OperatorTok{.}\NormalTok{gen}\OperatorTok{.}\NormalTok{migration create\_trade\_events}
\OperatorTok{*}\NormalTok{ creating priv}\OperatorTok{/}\NormalTok{repo}\OperatorTok{/}\NormalTok{migrations}
\OperatorTok{*}\NormalTok{ creating priv}\OperatorTok{/}\NormalTok{repo}\OperatorTok{/}\NormalTok{migrations}\OperatorTok{/}\DecValTok{20210222224514}\NormalTok{\_create\_trade\_events}\OperatorTok{.}\NormalTok{exs}
\end{Highlighting}
\end{Shaded}

The \texttt{Streamer.Binance.TradeEvent} struct will serve as a list of columns for our new \texttt{trade\_events} table. Here's the full implementation of our migration:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/priv/repo/migrations/20210222224514\_create\_trade\_events.exs}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateTradeEvents} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
\NormalTok{    create table}\FunctionTok{(}\VariableTok{:trade\_events}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:id}\NormalTok{, }\VariableTok{:uuid}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{true}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:event\_type}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:event\_time}\NormalTok{, }\VariableTok{:bigint}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:trade\_id}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:price}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:quantity}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:buyer\_order\_id}\NormalTok{, }\VariableTok{:bigint}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:seller\_order\_id}\NormalTok{, }\VariableTok{:bigint}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:trade\_time}\NormalTok{, }\VariableTok{:bigint}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:buyer\_market\_maker}\NormalTok{, }\VariableTok{:bool}\FunctionTok{)}

\NormalTok{      timestamps}\FunctionTok{()}
    \KeywordTok{end}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We added the additional \texttt{id} field to easily identify each trade event and our timestamps for monitoring.

Let's run the migration so it will create a new \texttt{trade\_events} table for us:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ mix ecto}\OperatorTok{.}\NormalTok{migrate}
\end{Highlighting}
\end{Shaded}

\newpage

The next step will be to create a new directory called \texttt{schema} inside the\\
\texttt{apps/data\_warehouse/lib/data\_warehouse} directory. Inside it, we need to create a new schema file called \texttt{trade\_event.ex}. We can copy across the same columns from the migration straight to schema:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/schema/trade\_event.ex}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradeEvent} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Schema}

  \OtherTok{@primary\_key} \FunctionTok{\{}\VariableTok{:id}\NormalTok{, }\VariableTok{:binary\_id}\NormalTok{, }\VariableTok{autogenerate:} \ConstantTok{true}\FunctionTok{\}}

\NormalTok{  schema }\StringTok{"trade\_events"} \KeywordTok{do}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:event\_type}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:event\_time}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:trade\_id}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:price}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:quantity}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:buyer\_order\_id}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:seller\_order\_id}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:trade\_time}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:buyer\_market\_maker}\NormalTok{, }\VariableTok{:boolean}\FunctionTok{)}

\NormalTok{    timestamps}\FunctionTok{()}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment we should be able to execute crud(create, read{[}select{]}, update, delete) operations over the table using the above struct.

Currently, we can already store the trade events' data inside the database so we can move on to collecting it. Trade events are getting broadcasted by the \texttt{Streamer.Binance} process here:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/streamer/lib/streamer/binance.ex}
    \OperatorTok{...}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      trade\_event}
    \FunctionTok{)}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We will implement a \texttt{subscriber} process that will be given a PubSub topic and will store incoming data inside the database.

\newpage

Let's start by creating a new folder called \texttt{subscriber} inside the\\
\texttt{apps/data\_warehouse/lib/data\_warehouse} directory together with a new file called \texttt{worker.ex} inside it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/worker.ex}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Subscriber}\OperatorTok{.}\ConstantTok{Worker} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{GenServer}

  \ImportTok{require} \ConstantTok{Logger}

  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}\VariableTok{:topic}\OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}\VariableTok{:topic}\OtherTok{]}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
\NormalTok{      topic,}
      \VariableTok{name:}\NormalTok{ :}\StringTok{"}\OtherTok{\#\{}\ConstantTok{\_\_MODULE\_\_}\OtherTok{\}}\StringTok{{-}}\OtherTok{\#\{}\NormalTok{topic}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{,}
\NormalTok{     \%}\ConstantTok{State}\FunctionTok{\{}
       \VariableTok{topic:}\NormalTok{ topic}
     \FunctionTok{\}\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment it's just a box standard implementation of the \texttt{GenServer} with a state struct containing a single key(\texttt{:topic}). We need to update the \texttt{init/1} function to subscribe to the PubSub topic:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/worker.ex}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"DataWarehouse worker is subscribing to }\OtherTok{\#\{}\NormalTok{topic}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
\NormalTok{      topic}
    \FunctionTok{)}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

Next, we need to add a handler for received messages:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/worker.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    opts }\OperatorTok{=}
\NormalTok{      trade\_event}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}

\NormalTok{    struct!}\FunctionTok{(}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradeEvent}\NormalTok{, opts}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert}\FunctionTok{()}

    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we did in the case of the \texttt{Naive.Trader}, all incoming messages trigger a \texttt{handle\_info/2} callback with the contents of the message and the current state of the subscriber worker. We just convert that incoming trade event to a map and then that map to the \texttt{TradeEvent} struct that gets inserted into the database.

This finishes storing of trade events implementation which we can test by in the interactive shell by running:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{00:48:30.147} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Streamer.Binance worker for XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.395.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.Subscriber.Worker.start\_link}\KeywordTok{(}\StringTok{"TRADE\_EVENTS:XRPUSDT"}\KeywordTok{)}
\ExtensionTok{00:49:48.204} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to TRADE\_EVENTS:XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.405.0\textgreater{}\}}
\end{Highlighting}
\end{Shaded}

After a couple of minutes we can check the database using \texttt{psql}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ psql }\AttributeTok{{-}Upostgres} \AttributeTok{{-}h127.0.0.1}
\ExtensionTok{Password}\NormalTok{ for user postgres:}
\ExtensionTok{...}
\VariableTok{postgres}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}c}\NormalTok{ data\_warehouse}\KeywordTok{;}
\ExtensionTok{You}\NormalTok{ are now connected to database }\StringTok{"data\_warehouse"}\NormalTok{ as user }\StringTok{"postgres"}\NormalTok{.}
\VariableTok{data\_warehouse}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}x}
\ExtensionTok{Expanded}\NormalTok{ display is on.}
\VariableTok{data\_warehouse}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{SELECT} \PreprocessorTok{*}\NormalTok{ FROM trade\_events}\KeywordTok{;}
\ExtensionTok{{-}[}\NormalTok{ RECORD 1 ]{-}{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\FunctionTok{id}                 \KeywordTok{|} \ExtensionTok{f6eae686{-}946a{-}4e34{-}9c33{-}c7034c2cad5d}
\ExtensionTok{event\_type}         \KeywordTok{|} \ExtensionTok{trade}
\ExtensionTok{event\_time}         \KeywordTok{|} \ExtensionTok{1614041388236}
\ExtensionTok{symbol}             \KeywordTok{|} \ExtensionTok{XRPUSDT}
\ExtensionTok{trade\_id}           \KeywordTok{|} \ExtensionTok{152765072}
\ExtensionTok{price}              \KeywordTok{|} \ExtensionTok{0.56554000}
\ExtensionTok{quantity}           \KeywordTok{|} \ExtensionTok{1199.10000000}
\ExtensionTok{buyer\_order\_id}     \KeywordTok{|} \ExtensionTok{1762454848}
\ExtensionTok{seller\_order\_id}    \KeywordTok{|} \ExtensionTok{1762454775}
\ExtensionTok{trade\_time}         \KeywordTok{|} \ExtensionTok{1614041388235}
\ExtensionTok{buyer\_market\_maker} \KeywordTok{|} \ExtensionTok{f}
\ExtensionTok{inserted\_at}        \KeywordTok{|} \ExtensionTok{2021{-}02{-}23}\NormalTok{ 00:49:48}
\ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

As we can see in the above output, trade events are now getting stored inside the database.

\section{Store orders' data}\label{store-orders-data}

In the same fashion as with trade events' data above, to store orders data we will create an \texttt{orders} table inside a new migration:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ cd apps}\OperatorTok{/}\NormalTok{data\_warehouse}
\NormalTok{$ mix ecto}\OperatorTok{.}\NormalTok{gen}\OperatorTok{.}\NormalTok{migration create\_orders}
\OperatorTok{*}\NormalTok{ creating priv}\OperatorTok{/}\NormalTok{repo}\OperatorTok{/}\NormalTok{migrations}\OperatorTok{/}\DecValTok{20210222224522}\NormalTok{\_create\_orders}\OperatorTok{.}\NormalTok{exs}
\end{Highlighting}
\end{Shaded}

The list of columns for this table will be a copy of \href{https://github.com/dvcrn/binance.ex/blob/master/lib/binance/order.ex}{\texttt{Binance.Order}} struct returned from the Binance exchange:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/priv/repo/migrations/20210222224522\_create\_orders.exs}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateOrders} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
\NormalTok{    create table}\FunctionTok{(}\VariableTok{:orders}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:order\_id}\NormalTok{, }\VariableTok{:bigint}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{true}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:client\_order\_id}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:price}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:original\_quantity}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:executed\_quantity}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:cummulative\_quote\_quantity}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:time\_in\_force}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:type}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:side}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:stop\_price}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:iceberg\_quantity}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:time}\NormalTok{, }\VariableTok{:bigint}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:update\_time}\NormalTok{, }\VariableTok{:bigint}\FunctionTok{)}

\NormalTok{      timestamps}\FunctionTok{()}
    \KeywordTok{end}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We updated all of the shortened names like \texttt{orig\_qty} to full names like \texttt{original\_quantity}.

Let's run the migration so it will create a new \texttt{orders} table for us:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix ecto.migrate}
\end{Highlighting}
\end{Shaded}

We can copy the above fields list to create a schema module. First, let's create a new file called \texttt{order.ex} inside the \texttt{apps/data\_warehouse/lib/data\_warehouse/schema} directory:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/schema/order.ex}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Order} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Schema}

  \OtherTok{@primary\_key} \FunctionTok{\{}\VariableTok{:order\_id}\NormalTok{, }\VariableTok{:integer}\NormalTok{, }\VariableTok{autogenerate:} \ConstantTok{false}\FunctionTok{\}}

\NormalTok{  schema }\StringTok{"orders"} \KeywordTok{do}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:client\_order\_id}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:price}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:original\_quantity}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:executed\_quantity}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:cummulative\_quote\_quantity}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:time\_in\_force}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:type}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:side}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:stop\_price}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:iceberg\_quantity}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:time}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:update\_time}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}

\NormalTok{    timestamps}\FunctionTok{()}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

We can now add a handler to our \texttt{DataWarehouse.Subscriber.Worker} that will convert the \texttt{Binance.Order} struct to \texttt{DataWarehouse.Schema.Order} and store data inside the database:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/worker.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order, state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    data }\OperatorTok{=}
\NormalTok{      order}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}

\NormalTok{    struct}\FunctionTok{(}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Order}\NormalTok{, data}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
      \VariableTok{original\_quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{orig\_qty,}
      \VariableTok{executed\_quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{executed\_qty,}
      \VariableTok{cummulative\_quote\_quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{cummulative\_quote\_qty,}
      \VariableTok{iceberg\_quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{iceberg\_qty}
    \FunctionTok{\})}
    \OperatorTok{|\textgreater{}} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert}\FunctionTok{(}
      \VariableTok{on\_conflict:} \VariableTok{:replace\_all}\NormalTok{,}
      \VariableTok{conflict\_target:} \VariableTok{:order\_id}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

In the above code, we are copying the matching fields using the \texttt{struct/2} function but all other fields that aren't 1 to 1 between two structs won't be copied, so we need to merge them in the second step(using the \texttt{Map.merge/2} function). We are also using the \texttt{on\_conflict:\ :replace\_all} option to make the \texttt{insert/2} function act as it would be \texttt{upsert/2}(to avoid writing separate logic for inserting and updating the orders).

Having all of this in place we will now be able to store broadcasted orders' data in the database but there's nothing actually broadcasting them.

We need to modify the \texttt{Naive.Trader} module to broadcast the \texttt{Binance.Order} whenever it places buy/sell orders or fetches them again:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/lib/naive/trader.ex}
    \OperatorTok{...}
    \CommentTok{\# inside placing initial buy order callback}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"GTC"}\FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{order}\FunctionTok{)}
    \OperatorTok{...}

    \CommentTok{\# inside buy order (partially) filled callback}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_buy\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{current\_buy\_order}\FunctionTok{)}
    \OperatorTok{...}

        \CommentTok{\# inside the same callback in case of buy order filled}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
          \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, sell\_price, }\StringTok{"GTC"}\FunctionTok{)}
        
        \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{order}\FunctionTok{)}
    \OperatorTok{...}

    \CommentTok{\# inside sell order (partially) filled callback}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_sell\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}
    
    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{current\_sell\_order}\FunctionTok{)}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Above 4 places send both the \texttt{Binance.OrderResponse} and the \texttt{Binance.Order} structs - our \texttt{broadcast\_order/1} function needs to be able to handle them both. Add the following at the bottom of the \texttt{Naive.Trader} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{defp}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ response}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    response}
    \OperatorTok{|\textgreater{}}\NormalTok{ convert\_to\_order}\FunctionTok{()}
    \OperatorTok{|\textgreater{}}\NormalTok{ broadcast\_order}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"ORDERS:}\OtherTok{\#\{}\NormalTok{order}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      order}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ convert\_to\_order}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ response}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    data }\OperatorTok{=}
\NormalTok{      response}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}

\NormalTok{    struct}\FunctionTok{(}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\NormalTok{, data}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
      \VariableTok{cummulative\_quote\_qty:} \StringTok{"0.00000000"}\NormalTok{,}
      \VariableTok{stop\_price:} \StringTok{"0.00000000"}\NormalTok{,}
      \VariableTok{iceberg\_qty:} \StringTok{"0.00000000"}\NormalTok{,}
      \VariableTok{is\_working:} \ConstantTok{true}
    \FunctionTok{\})}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As \texttt{DataWarehouse.Subscriber.Worker} process expects only the \texttt{Binance.Order} structs to be broadcasted, we first check is it the \texttt{Binance.OrderResponse} struct and convert the passed value to the \texttt{Binance.Order} struct (if that's the case) and only then broadcast it to the PubSub topic.

The converting logic as previously uses the \texttt{struct/2} function but it also merges in default values that are missing from the much smaller \texttt{Binance.OrderResponse} struct(with comparison to the \texttt{Binance.Order}).

At this moment we will be able to store orders inside the database and we can check that by running:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.Subscriber.Worker.start\_link}\KeywordTok{(}\StringTok{"ORDERS:NEOUSDT"}\KeywordTok{)}
\ExtensionTok{22:37:43.043} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to ORDERS:XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.400.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{22:38:39.741} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Naive.SymbolSupervisor worker for NEOUSDT}
\ExtensionTok{22:38:39.832} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.402.0\textgreater{}\}}
\ExtensionTok{22:38:41.654} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1614119921653}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ NEOUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{22:39:23.786} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Streamer.Binance worker for NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.412.0\textgreater{}\}}
\ExtensionTok{22:39:27.187} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1614119921653}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for NEOUSDT @ 37.549,}
\ExtensionTok{quantity:}\NormalTok{ 5.326}
\ExtensionTok{22:39:27.449} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1614119921653}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a SELL order for NEOUSDT @ 37.578,}
\ExtensionTok{quantity:}\NormalTok{ 5.326.}
\end{Highlighting}
\end{Shaded}

\newpage

At this moment inside the DataWarehouse's database we should see orders:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ psql }\AttributeTok{{-}Upostgres} \AttributeTok{{-}h127.0.0.1}
\ExtensionTok{Password}\NormalTok{ for user postgres: }
\ExtensionTok{...}
\VariableTok{postgres}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}c}\NormalTok{ data\_warehouse}\KeywordTok{;}
\ExtensionTok{You}\NormalTok{ are now connected to database }\StringTok{"data\_warehouse"}\NormalTok{ as user }\StringTok{"postgres"}\NormalTok{.}
\VariableTok{data\_warehouse}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}x}
\ExtensionTok{Expanded}\NormalTok{ display is on.}
\VariableTok{data\_warehouse}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{SELECT} \PreprocessorTok{*}\NormalTok{ FROM orders}\KeywordTok{;}
\ExtensionTok{{-}[}\NormalTok{ RECORD 1 ]{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\ExtensionTok{order\_id}                   \KeywordTok{|} \ExtensionTok{1}
\ExtensionTok{client\_order\_id}            \KeywordTok{|} \ExtensionTok{C81E728D9D4C2F636F067F89CC14862C}
\ExtensionTok{symbol}                     \KeywordTok{|} \ExtensionTok{NEOUSDT}
\ExtensionTok{price}                      \KeywordTok{|} \ExtensionTok{38.16}
\ExtensionTok{original\_quantity}          \KeywordTok{|} \ExtensionTok{5.241}
\ExtensionTok{executed\_quantity}          \KeywordTok{|} \ExtensionTok{0.00000000}
\ExtensionTok{cummulative\_quote\_quantity} \KeywordTok{|} \ExtensionTok{0.00000000}
\ExtensionTok{status}                     \KeywordTok{|} \ExtensionTok{FILLED}
\ExtensionTok{time\_in\_force}              \KeywordTok{|} \ExtensionTok{GTC}
\BuiltInTok{type}                       \KeywordTok{|} \ExtensionTok{LIMIT}
\ExtensionTok{side}                       \KeywordTok{|} \ExtensionTok{BUY}
\ExtensionTok{stop\_price}                 \KeywordTok{|} \ExtensionTok{0.00000000}
\ExtensionTok{iceberg\_quantity}           \KeywordTok{|} \ExtensionTok{0.00000000}
\BuiltInTok{time}                       \KeywordTok{|} \ExtensionTok{1614120906320}
\ExtensionTok{update\_time}                \KeywordTok{|} \ExtensionTok{1614120906320}
\ExtensionTok{inserted\_at}                \KeywordTok{|} \ExtensionTok{2021{-}02{-}23}\NormalTok{ 22:55:10}
\ExtensionTok{updated\_at}                 \KeywordTok{|} \ExtensionTok{2021{-}02{-}23}\NormalTok{ 22:55:10}
\ExtensionTok{{-}[}\NormalTok{ RECORD 2 ]{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\ExtensionTok{order\_id}                   \KeywordTok{|} \ExtensionTok{2}
\ExtensionTok{client\_order\_id}            \KeywordTok{|} \ExtensionTok{ECCBC87E4B5CE2FE28308FD9F2A7BAF3}
\ExtensionTok{symbol}                     \KeywordTok{|} \ExtensionTok{NEOUSDT}
\ExtensionTok{price}                      \KeywordTok{|} \ExtensionTok{38.19}
\ExtensionTok{original\_quantity}          \KeywordTok{|} \ExtensionTok{5.241}
\ExtensionTok{executed\_quantity}          \KeywordTok{|} \ExtensionTok{0.00000000}
\ExtensionTok{cummulative\_quote\_quantity} \KeywordTok{|} \ExtensionTok{0.00000000}
\ExtensionTok{status}                     \KeywordTok{|} \ExtensionTok{NEW}
\ExtensionTok{time\_in\_force}              \KeywordTok{|} \ExtensionTok{GTC}
\BuiltInTok{type}                       \KeywordTok{|} \ExtensionTok{LIMIT}
\ExtensionTok{side}                       \KeywordTok{|} \ExtensionTok{SELL}
\ExtensionTok{stop\_price}                 \KeywordTok{|} \ExtensionTok{0.00000000}
\ExtensionTok{iceberg\_quantity}           \KeywordTok{|} \ExtensionTok{0.00000000}
\BuiltInTok{time}                       \KeywordTok{|} 
\ExtensionTok{update\_time}                \KeywordTok{|} 
\ExtensionTok{inserted\_at}                \KeywordTok{|} \ExtensionTok{2021{-}02{-}23}\NormalTok{ 22:55:10}
\ExtensionTok{updated\_at}                 \KeywordTok{|} \ExtensionTok{2021{-}02{-}23}\NormalTok{ 22:55:10}
\end{Highlighting}
\end{Shaded}

The first record above got inserted and updated as its state is ``FILLED'', the second one wasn't updated yet as it's still in ``NEW'' state - that confirms that the upsert trick works.

That finishes the implementation of storing orders inside the database.

\section{Implement supervision}\label{implement-supervision}

Currently, we have a \texttt{DataWarehouse.Subscriber.Worker} process that will take care of storing data into the database, but sadly if anything will go wrong inside our worker and it will crash there's no supervision in place to restart it.

The supervision tree for the \texttt{data\_warehouse} application will be similar to ones from the \texttt{naive} and \texttt{streamer} apps but different enough to \emph{not} use the \texttt{Core.ServiceSupervisor} abstraction.

For example, it doesn't use the \texttt{symbol} column, it works based on the \texttt{topic} column. This would require changes to the \texttt{Core.ServiceSupervisor}'s functions like \texttt{update\_status/4} or \texttt{fetch\_symbols\_to\_start/2}, we could update them to accept column name but that would need to be passed through other functions. We can see that this is probably not the best approach and the further we will get the more complex it will become. The second issue would be that we are registering all processes with names and that can be problematic as the list of processes will start to grow(as we can imagine in the case of the \texttt{data\_warehouse} application).

The better approach would be to mix the \href{https://hexdocs.pm/elixir/master/DynamicSupervisor.html}{DynamicSupervisor} together with \href{https://hexdocs.pm/elixir/master/Registry.html}{Registry}.

The \texttt{DynamicSupervisor} will supervise the \texttt{Subscriber.Worker}s and instead of keeping track of them by registering them using atoms we will start them \texttt{:via} Elixir \texttt{Registry}.

We will add all functionality that we implemented for \texttt{naive} and \texttt{streamer} applications. We will provide the functions to start and stop storing data on passed PubSub topics as well as store those topics inside the database so storing will be autostarted.

\subsection{\texorpdfstring{Create \texttt{subscriber\_settings} table}{Create subscriber\_settings table}}\label{create-subscriber_settings-table}

To provide autostarting function we need to create a new migration that will create the \texttt{subscriber\_settings} table:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps/data\_warehouse}
\ExtensionTok{$}\NormalTok{ mix ecto.gen.migration create\_subscriber\_settings}
\ExtensionTok{*}\NormalTok{ creating priv/repo/migrations/20210227230123\_create\_subscriber\_settings.exs}
\end{Highlighting}
\end{Shaded}

\newpage

At this moment we can copy the code to create the \texttt{settings} table(enum and index as well) from the \texttt{streamer} application and tweak it to fit the \texttt{data\_warehouse} application. So the first important change (besides updating namespaces from \texttt{Streamer} to \texttt{DataWarehouse}) will be to make a note that we have a setting per topic - not per symbol as for the \texttt{naive} and \texttt{streamer} applications:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/priv/repo/migrations/20210227230123\_create\_subscriber\_settings.exs}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateSubscriberSettings} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}

  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{SubscriberStatusEnum}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{SubscriberStatusEnum}\OperatorTok{.}\NormalTok{create\_type}\FunctionTok{()}

\NormalTok{    create table}\FunctionTok{(}\VariableTok{:subscriber\_settings}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:id}\NormalTok{, }\VariableTok{:uuid}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{true}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:topic}\NormalTok{, }\VariableTok{:text}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SubscriberStatusEnum}\OperatorTok{.}\NormalTok{type}\FunctionTok{()}\NormalTok{, }\VariableTok{default:} \StringTok{"off"}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
      
\NormalTok{      timestamps}\FunctionTok{()}
    \KeywordTok{end}

\NormalTok{    create}\FunctionTok{(}\NormalTok{unique\_index}\FunctionTok{(}\VariableTok{:subscriber\_settings}\NormalTok{, }\OtherTok{[}\VariableTok{:topic}\OtherTok{]}\FunctionTok{))}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Both schema and enum will be almost identical to the ones from the \texttt{streamer} application - we can simply copy those files and apply basic tweaks like updating the namespace:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cp apps/streamer/lib/streamer/schema/settings.ex }\DataTypeTok{\textbackslash{}}
\NormalTok{apps/data\_warehouse/lib/data\_warehouse/schema/subscriber\_settings.ex}
\ExtensionTok{$}\NormalTok{ cp apps/streamer/lib/streamer/schema/streaming\_status\_enum.ex }\DataTypeTok{\textbackslash{}}
\NormalTok{apps/data\_warehouse/lib/data\_warehouse/schema/subscriber\_status\_enum.ex}
\end{Highlighting}
\end{Shaded}

Remember about updating the \texttt{symbol} column to \texttt{topic} as well as table name inside the

\texttt{DataWarehouse.Schema.SubscriberSettings}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/schema/subscriber\_settings.ex}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{SubscriberSettings} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Schema}

  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{SubscriberStatusEnum}

  \OtherTok{@primary\_key} \FunctionTok{\{}\VariableTok{:id}\NormalTok{, }\VariableTok{:binary\_id}\NormalTok{, }\VariableTok{autogenerate:} \ConstantTok{true}\FunctionTok{\}}

\NormalTok{  schema }\StringTok{"subscriber\_settings"} \KeywordTok{do}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:topic}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SubscriberStatusEnum}\FunctionTok{)}

\NormalTok{    timestamps}\FunctionTok{()}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Inside \texttt{apps/data\_warehouse/lib/data\_warehouse/schema/subscriber\_status\_enum.ex} we need to swap references of \texttt{Streamer} to \texttt{DataWarehouse} and references of \texttt{StreamingStatusEnum} to \texttt{SubscriberStatusEnum}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/schema/subscriber\_status\_enum.ex}
\ImportTok{import} \ConstantTok{EctoEnum}

\NormalTok{defenum}\FunctionTok{(}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{SubscriberStatusEnum}\NormalTok{, }\VariableTok{:subscriber\_status}\NormalTok{, }\OtherTok{[}\VariableTok{:on}\NormalTok{, }\VariableTok{:off}\OtherTok{]}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Don't forget to run the migration:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix ecto.migrate}
\end{Highlighting}
\end{Shaded}

At this moment we have all pieces in place to execute queries on our new table. In this place, we can think about the seeding script. For the \texttt{data\_warehouse} specifically, we won't need to provide that script as we don't know in advance what topic names we will use. Instead of seeding settings in advance, our code will ``upsert''(using \texttt{insert} function) settings when \texttt{start\_storing/1} or \texttt{stop\_storing/1} are called.

\subsection{Redesign supervision using Registry}\label{redesign-supervision-using-registry}

We can now focus on drafting a supervision tree for the \texttt{data\_warehouse} application. At this moment we have only the \texttt{DataWarehouse.Subscriber.Worker} and the \texttt{DataWarehouse.Application} modules.

As it was with the case of \texttt{naive} and \texttt{streamer} applications, we will need an additional level of supervision to cater for ``autostarting'' \texttt{Task} as well as, in the case of the \texttt{data\_warehouse} application the \texttt{Registry}.

\newpage

The full supervision tree will look as follows:

\begin{center}\includegraphics[width=1\linewidth,height=0.4\textheight]{images/chapter_14_01_sup_diagram} \end{center}

Everything looks very similar to the supervision tree that we created in the \texttt{streamer} and the \texttt{naive} applications but there's an additional \texttt{Registry} that is supervised by the \texttt{SubscriberSupervisior} process.

The idea is that inside the \texttt{Worker} module's \texttt{start\_link/1} we will register worker processes using \href{https://hexdocs.pm/elixir/master/GenServer.html\#module-name-registration}{:via} tuple. Internally, GenServer will utilize \texttt{Registry}'s functions like \texttt{register\_name/2} to add process to the registry under the \texttt{topic} string. This way we will be able to retrieve PIDs assigned to topics using those topic strings instead of registering each worker process with an atom name.

Just as previously the \texttt{DynamicSupervisor} will be in charge of supervising the \texttt{Worker} processes and it won't be even aware that we are using the \texttt{Registry} to keep track of \texttt{topic\ =\textgreater{}\ PID} association.

\subsection{\texorpdfstring{Create the \texttt{DataWarehouse.Subscriber.DynamicSupervisor} module}{Create the DataWarehouse.Subscriber.DynamicSupervisor module}}\label{create-the-datawarehouse.subscriber.dynamicsupervisor-module}

Let's start by creating a new file called \texttt{dynamic\_supervisor.ex} inside the\\
\texttt{apps/data\_warehouse/lib/data\_warehouse/subscriber} directory and put default dynamic supervisor implementation inside:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/dynamic\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Subscriber}\OperatorTok{.}\ConstantTok{DynamicSupervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{DynamicSupervisor}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, }\OtherTok{[]}\NormalTok{, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we will put all our logic related to autostarting, starting and stopping inside this module we can already add aliases, import and require:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/dynamic\_supervisor.ex}
  \ImportTok{require} \ConstantTok{Logger}

  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}
  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{SubscriberSettings}
  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Subscriber}\OperatorTok{.}\ConstantTok{Worker}

  \ImportTok{import} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Query}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{from:} \DecValTok{2}\OtherTok{]}

  \OtherTok{@registry} \VariableTok{:subscriber\_workers}
\end{Highlighting}
\end{Shaded}

Additionally, we added the \texttt{@registry} module attribute that we will use to retrieve PID for the specific topic.

We can move on to implementing \texttt{autostart\_workers/0} which will look very similar to the ones that we implemented in the \texttt{streamer} and the \texttt{naive} applications:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/dynamic\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{all}\FunctionTok{(}
\NormalTok{      from}\FunctionTok{(}\NormalTok{s }\KeywordTok{in} \ConstantTok{SubscriberSettings}\NormalTok{,}
        \VariableTok{where:}\NormalTok{ s}\OperatorTok{.}\NormalTok{status }\OperatorTok{==} \StringTok{"on"}\NormalTok{,}
        \VariableTok{select:}\NormalTok{ s}\OperatorTok{.}\NormalTok{topic}
      \FunctionTok{)}
    \FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{start\_child}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ start\_child}\FunctionTok{(}\NormalTok{args}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Worker}\NormalTok{, args}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can see that we are querying the database for a list of \texttt{topic}s(not symbols) and we are calling \texttt{start\_child/2} for each result.

The \texttt{start\_worker/1} is where the \texttt{Registry} will shine as we won't need to check is there already a process running for that topic - we can leave that check to the \texttt{Registry}. If there's a process already running for that topic it will just return a tuple starting with \texttt{:error} atom:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/dynamic\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Starting storing data from }\OtherTok{\#\{}\NormalTok{topic}\OtherTok{\}}\StringTok{ topic"}\FunctionTok{)}
\NormalTok{    update\_status}\FunctionTok{(}\NormalTok{topic, }\StringTok{"on"}\FunctionTok{)}
\NormalTok{    start\_child}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{topic, status}\FunctionTok{)}
       \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{SubscriberSettings}\FunctionTok{\{}
      \VariableTok{topic:}\NormalTok{ topic,}
      \VariableTok{status:}\NormalTok{ status}
    \FunctionTok{\}}
    \OperatorTok{|\textgreater{}} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert}\FunctionTok{(}
      \VariableTok{on\_conflict:} \VariableTok{:replace\_all}\NormalTok{,}
      \VariableTok{conflict\_target:} \VariableTok{:topic}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we are not seeding the database with the default settings we will use the \texttt{insert/2} function with options(as previously) to make it work as it would be an ``upsert'' function.

Last function in this module will be \texttt{stop\_worker/1} which uses private \texttt{stop\_child/1} function. The \texttt{stop\_child/1} function shows how to retrieve \texttt{PID} of the process assigned to the passed \texttt{topic}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/dynamic\_supervisor.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Stopping storing data from }\OtherTok{\#\{}\NormalTok{topic}\OtherTok{\}}\StringTok{ topic"}\FunctionTok{)}
\NormalTok{    update\_status}\FunctionTok{(}\NormalTok{topic, }\StringTok{"off"}\FunctionTok{)}
\NormalTok{    stop\_child}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ stop\_child}\FunctionTok{(}\NormalTok{args}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Registry}\OperatorTok{.}\NormalTok{lookup}\FunctionTok{(}\OtherTok{@registry}\NormalTok{, args}\FunctionTok{)} \KeywordTok{do}
      \OtherTok{[}\FunctionTok{\{}\NormalTok{pid, \_}\FunctionTok{\}}\OtherTok{]} \OperatorTok{{-}\textgreater{}} \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{terminate\_child}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, pid}\FunctionTok{)}
\NormalTok{      \_ }\OperatorTok{{-}\textgreater{}} \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Unable to locate process assigned to }\OtherTok{\#\{}\NormalTok{inspect}\FunctionTok{(}\NormalTok{args}\FunctionTok{)}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That is a full implementation of the \texttt{DataWarehouse.Subscriber.DynamicSupervisor} module and it's almost as slim as one from the last chapter where we leveraged macros to achieve that lightness. Using the \texttt{Registry} is the preferred way to manage a list of identifiable processes. We won't run into an issue of overusing the atoms(as they are not garbage collected, we could hit that limit sooner or later).

\subsection{Register Worker processes using :via}\label{register-worker-processes-using-via}

The above \texttt{DynamicSupervisor} module assumes that Workers are registered inside the \texttt{Registry} - to make this happen we will need to update the \texttt{start\_link/1} function of the\\
\texttt{DataWarehouse.Subscriber.Worker} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/worker.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
\NormalTok{      topic,}
      \VariableTok{name:}\NormalTok{ via\_tuple}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ via\_tuple}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:via}\NormalTok{, }\ConstantTok{Registry}\NormalTok{, }\FunctionTok{\{}\VariableTok{:subscriber\_workers}\NormalTok{, topic}\FunctionTok{\}\}}
  \KeywordTok{end}
  \OperatorTok{...}    
\end{Highlighting}
\end{Shaded}

Passing the \texttt{:name} option to the \texttt{GenServer}'s \texttt{start\_link/3} function we instruct it to utilize the \texttt{Registry} module to register processes under topic names.

\subsection{Create a new supervision level for Registry, Task and the DynamicSupervisor}\label{create-a-new-supervision-level-for-registry-task-and-the-dynamicsupervisor}

We have the lowest level modules - the \texttt{Worker} and the \texttt{DynamicSupervisor} implemented - time to add a new \texttt{Supervisor} that will start the \texttt{Registry}, the \texttt{DynamicSupervisor}, and the autostart storing \texttt{Task}. First create a new file called \texttt{subscriber\_supervisor.ex} inside the \texttt{apps/data\_warehouse/lib/data\_warehouse} directory:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{SubscriberSupervisor} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Supervisor}

  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Subscriber}\OperatorTok{.}\ConstantTok{DynamicSupervisor}

  \OtherTok{@registry} \VariableTok{:subscriber\_workers}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{\_args}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, }\OtherTok{[]}\NormalTok{, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Registry}\NormalTok{, }\OtherTok{[}\VariableTok{keys:} \VariableTok{:unique}\NormalTok{, }\VariableTok{name:} \OtherTok{@registry]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{DynamicSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Task}\NormalTok{,}
       \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
         \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{()}
       \KeywordTok{end}\FunctionTok{\}}
    \OtherTok{]}

    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{init}\FunctionTok{(}\NormalTok{children, }\VariableTok{strategy:} \VariableTok{:rest\_for\_one}\FunctionTok{)}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The important part here will be to match the \texttt{Registry} name to the one defined inside the \texttt{DynamicSupervisor} and the \texttt{Worker} modules.

\subsection{\texorpdfstring{Link the \texttt{SubscriberSupervisor} to the \texttt{Application}}{Link the SubscriberSupervisor to the Application}}\label{link-the-subscribersupervisor-to-the-application}

We need to update the \texttt{DataWarehouse.Application} module to start our new\\
\texttt{DataWarehouse.SubscriberSupervisor} process as well as register itself under name matching to its module(just for consistency with other applications):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/application.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{SubscriberSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}} \CommentTok{\# \textless{}= new module added}
    \OtherTok{]}

    \CommentTok{\# See https://hexdocs.pm/elixir/Supervisor.html}
    \CommentTok{\# for other strategies and supported options}
\NormalTok{    opts }\OperatorTok{=} \OtherTok{[}\VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{, }\VariableTok{name:} \ConstantTok{\_\_MODULE\_\_}\OtherTok{]} \CommentTok{\# \textless{}= name updated}
    \ConstantTok{Supervisor}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\NormalTok{children, opts}\FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{Add interface}\label{add-interface}

The final step will be to add an interface to the \texttt{DataWarehouse} application to start and stop storing:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse.ex}
  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Subscriber}\OperatorTok{.}\ConstantTok{DynamicSupervisor}

  \KeywordTok{def}\NormalTok{ start\_storing}\FunctionTok{(}\NormalTok{stream, symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    to\_topic}\FunctionTok{(}\NormalTok{stream, symbol}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_storing}\FunctionTok{(}\NormalTok{stream, symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    to\_topic}\FunctionTok{(}\NormalTok{stream, symbol}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ to\_topic}\FunctionTok{(}\NormalTok{stream, symbol}\FunctionTok{)} \KeywordTok{do}
    \OtherTok{[}\NormalTok{stream, symbol}\OtherTok{]}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{join}\FunctionTok{(}\StringTok{":"}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Inside the above functions, we are just doing a couple of sanity checks on the case of the passed arguments assuming that both topics and stream are uppercase.

\subsection{Test}\label{test}

The interface above was the last step in our implementation, we can now test that all works as expected:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.start\_storing}\KeywordTok{(}\StringTok{"TRADE\_EVENTS"}\ExtensionTok{,} \StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{19:34:00.740} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting storing data from TRADE\_EVENTS:NEOUSDT topic}
\ExtensionTok{19:34:00.847} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to TRADE\_EVENTS:NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.429.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.start\_storing}\KeywordTok{(}\StringTok{"TRADE\_EVENTS"}\ExtensionTok{,} \StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{19:34:04.753} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting storing data from TRADE\_EVENTS:NEOUSDT topic}
\ExtensionTok{\{:error,}\NormalTok{ \{:already\_started, }\CommentTok{\#PID\textless{}0.459.0\textgreater{}\}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.start\_storing}\KeywordTok{(}\StringTok{"ORDERS"}\ExtensionTok{,} \StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{19:34:09.386} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting storing data from ORDERS:NEOUSDT topic}
\ExtensionTok{19:34:09.403} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to ORDERS:NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.431.0\textgreater{}\}}
\ExtensionTok{BREAK:} \ErrorTok{(}\ExtensionTok{a}\KeywordTok{)}\ExtensionTok{bort} \ErrorTok{(}\ExtensionTok{A}\KeywordTok{)}\ExtensionTok{bort}\NormalTok{ with dump }\ErrorTok{(}\ExtensionTok{c}\KeywordTok{)}\ExtensionTok{ontinue} \ErrorTok{(}\ExtensionTok{p}\KeywordTok{)}\ExtensionTok{roc}\NormalTok{ info }\ErrorTok{(}\ExtensionTok{i}\KeywordTok{)}\ExtensionTok{nfo}
       \KeywordTok{(}\ExtensionTok{l}\KeywordTok{)}\ExtensionTok{oaded} \ErrorTok{(}\ExtensionTok{v}\KeywordTok{)}\ExtensionTok{ersion} \ErrorTok{(}\ExtensionTok{k}\KeywordTok{)}\ExtensionTok{ill} \ErrorTok{(}\ExtensionTok{D}\KeywordTok{)}\ExtensionTok{b{-}tables} \ErrorTok{(}\ExtensionTok{d}\KeywordTok{)}\ExtensionTok{istribution}
\ExtensionTok{\^{}C\%}
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{19:35:30.058} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to TRADE\_EVENTS:NEOUSDT}
\ExtensionTok{19:35:30.062} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to ORDERS:NEOUSDT}
\CommentTok{\# autostart works \^{}\^{}\^{}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{19:36:45.316} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Naive.SymbolSupervisor worker for NEOUSDT}
\ExtensionTok{19:36:45.417} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.419.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}} 
\ExtensionTok{19:36:47.484} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1615221407466}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ NEOUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{16:37:39.660} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Streamer.Binance worker for NEOUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.428.0\textgreater{}\}}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.stop\_storing}\KeywordTok{(}\StringTok{"trade\_events"}\ExtensionTok{,} \StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{19:39:26.398} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Stopping storing data from trade\_events:NEOUSDT topic}
\ExtensionTok{:ok}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{4}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.stop\_storing}\KeywordTok{(}\StringTok{"trade\_events"}\ExtensionTok{,} \StringTok{"NEOUSDT"}\KeywordTok{)}
\ExtensionTok{19:39:28.151} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Stopping storing data from trade\_events:NEOUSDT topic}
\ExtensionTok{19:39:28.160} \PreprocessorTok{[}\SpecialStringTok{warn}\PreprocessorTok{]}\NormalTok{  Unable to locate process assigned to }\StringTok{"trade\_events:NEOUSDT"}
\ExtensionTok{:ok}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{5}\KeywordTok{)}\OperatorTok{\textgreater{}} \ExtensionTok{[\{pid,}\NormalTok{ nil\}] = Registry.lookup}\ErrorTok{(}\ExtensionTok{:subscriber\_workers,} \StringTok{"ORDERS:NEOUSDT"}\KeywordTok{)}
\ExtensionTok{[\{\#PID}\OperatorTok{\textless{}}\NormalTok{0.417.0}\OperatorTok{\textgreater{}}\NormalTok{, nil\}]}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{6}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Process.exit}\KeywordTok{(}\ExtensionTok{pid,}\NormalTok{ :crash}\KeywordTok{)}
\FunctionTok{true}
\ExtensionTok{16:43:40.812} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to ORDERS:NEOUSDT}
\end{Highlighting}
\end{Shaded}

As we can see even this simple implementation handles starting, autostarting, and stopping. It also gracefully handles starting workers when one is already running as well as stopping when there none running.

As a challenge, you could update the \texttt{naive} and the \texttt{streamer} application to use the \texttt{Registry} and remove \texttt{Core.ServiceSupervisor} module as it was superseded by the above solution - here's the \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/pull/7}{link to PR}(pull request) that sums up the required changes.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_14}{GitHub}

\chapter{Backtest trading strategy}\label{backtest-trading-strategy}

\section{Objectives}\label{objectives-14}

\begin{itemize}
\tightlist
\item
  overview of requirements
\item
  implement the storing task
\item
  test the backtesting
\end{itemize}

\section{Overview of requirements}\label{overview-of-requirements-2}

In the last chapter, we started storing trade events and orders in the database which will be crucial for backtesting, which we will focus on in this chapter.

Backtesting is a procedure of running historical data through the system and observing how our strategy would perform as if we would run it ``in the past''. Backtesting works on assumption that the market will behave in a similar fashion in the future as it was in the past.

\newpage

At this moment we are receiving the trade events from the Binance through WebSocket. The \texttt{Streamer.Binance} process is handling those messages by parsing them from JSON string to map, then converting them to structs and broadcasting them to the \texttt{TRADE\_EVENTS:\#\{symbol\}} PubSub topic. The \texttt{Naive.Trader} subscribes to the \texttt{TRADE\_EVENTS:\#\{symbol\}} topic and takes decisions based on incoming data. As it places buy and sell orders it broadcasts them to the \texttt{ORDERS:\#\{symbol\}} PubSub topic. The \texttt{DataWarehouse.Subscriber.Worker} processes subscribe to both trade events and orders topics and store incoming data inside the database.

We can visualize this flow like that:

\begin{center}\includegraphics[width=1\linewidth,height=0.6\textheight]{images/chapter_14_02_current_pubsub} \end{center}

\newpage

To backtest we can substitute the \texttt{Streamer.Binance} process with a \texttt{Task} that will \texttt{stream} trade events' data from the database and broadcasts it to the \texttt{TRADE\_EVENTS:\#\{symbol\}} PubSub topic(the same topic as the \texttt{Streamer.Binance} process).

From the perspective of the \texttt{Naive.Trader} it \emph{does not} make any difference who is broadcasting those trade events. This should be a clear indication of the value of publish/subscribe model that we implemented from the beginning. It allows us to swap producer and consumers freely to backtest our trading strategies:

\begin{center}\includegraphics[width=1\linewidth,height=0.6\textheight]{images/chapter_14_03_backtest_pubsub} \end{center}

\newpage

\section{Implement the storing task}\label{implement-the-storing-task}

We will start by creating a new file called \texttt{publisher.ex} inside the\\
\texttt{apps/data\_warehouse/lib/data\_warehouse} directory. We will start by implementing the basic \texttt{Task} behavior:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/publisher.ex}
\KeywordTok{defmodule} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Publisher} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{Task}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{arg}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Task}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, }\VariableTok{:run}\NormalTok{, }\OtherTok{[}\NormalTok{arg}\OtherTok{]}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ run}\FunctionTok{(}\NormalTok{arg}\FunctionTok{)} \KeywordTok{do}
    \CommentTok{\# ...}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

To be able to query the database we will import \texttt{Ecto} and require \texttt{Logger} for logging:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/publisher.ex}
  \OperatorTok{...}
  \ImportTok{import} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Query}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{from:} \DecValTok{2}\OtherTok{]}

  \ImportTok{require} \ConstantTok{Logger}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We can now modify the \texttt{run/1} function to expect specific \texttt{type}, \texttt{symbol}, \texttt{from}, \texttt{to} and \texttt{interval}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/publisher.ex  }
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ run}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
        \VariableTok{type:} \VariableTok{:trade\_events}\NormalTok{,}
        \VariableTok{symbol:}\NormalTok{ symbol,}
        \VariableTok{from:}\NormalTok{ from,}
        \VariableTok{to:}\NormalTok{ to,}
        \VariableTok{interval:}\NormalTok{ interval}
      \FunctionTok{\})} \KeywordTok{do}
    \OperatorTok{...}  
\end{Highlighting}
\end{Shaded}

\newpage

Inside the body of the \texttt{run/1} function, first, we will convert \texttt{from} and \texttt{to} Unix timestamps by using private helper functions as well as make sure that the passed symbol is uppercase:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/publisher.ex  }
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ run}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
        \OperatorTok{...}
      \FunctionTok{\})} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

\NormalTok{    from\_ts }\OperatorTok{=}
      \StringTok{"}\OtherTok{\#\{}\NormalTok{from}\OtherTok{\}}\StringTok{T00:00:00.000Z"}
      \OperatorTok{|\textgreater{}}\NormalTok{ convert\_to\_ms}\FunctionTok{()}

\NormalTok{    to\_ts }\OperatorTok{=}
      \StringTok{"}\OtherTok{\#\{}\NormalTok{to}\OtherTok{\}}\StringTok{T23:59:59.000Z"}
      \OperatorTok{|\textgreater{}}\NormalTok{ convert\_to\_ms}\FunctionTok{()}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ convert\_to\_ms}\FunctionTok{(}\NormalTok{iso8601DateString}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    iso8601DateString}
    \OperatorTok{|\textgreater{}} \ConstantTok{NaiveDateTime}\OperatorTok{.}\NormalTok{from\_iso8601!}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{DateTime}\OperatorTok{.}\NormalTok{from\_naive!}\FunctionTok{(}\StringTok{"Etc/UTC"}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{DateTime}\OperatorTok{.}\NormalTok{to\_unix}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{Kernel}\OperatorTok{.*}\FunctionTok{(}\DecValTok{1000}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Next, we will select data from the database but because of possibly hundreds of thousands of rows being selected and because we are broadcasting them to the PubSub every x ms it could take a substantial amount of time to \texttt{broadcast} all of them. Instead of \texttt{select}ing data and storing all of it in the memory, we will use \texttt{Repo.stream/1} function to keep \texttt{broadcast}ing it on the go. Additionally, we will add \texttt{index} to the data to be able to log info messages every 10k messages. The last thing that we need to define will be the timeout value - the default value is 5 seconds and we will change it to \texttt{:infinity}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/publisher.ex}
  \KeywordTok{def}\NormalTok{ run}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
        \OperatorTok{...}
      \FunctionTok{\})} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{transaction}\FunctionTok{(}
      \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
\NormalTok{        from}\FunctionTok{(}\NormalTok{te }\KeywordTok{in} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradeEvent}\NormalTok{,}
          \VariableTok{where:}
\NormalTok{            te}\OperatorTok{.}\NormalTok{symbol }\OperatorTok{==} \OperatorTok{\^{}}\NormalTok{symbol }\KeywordTok{and}
\NormalTok{              te}\OperatorTok{.}\NormalTok{trade\_time }\OperatorTok{\textgreater{}=} \OperatorTok{\^{}}\NormalTok{from\_ts }\KeywordTok{and}
\NormalTok{              te}\OperatorTok{.}\NormalTok{trade\_time }\OperatorTok{\textless{}} \OperatorTok{\^{}}\NormalTok{to\_ts,}
          \VariableTok{order\_by:}\NormalTok{ te}\OperatorTok{.}\NormalTok{trade\_time}
        \FunctionTok{)}
        \OperatorTok{|\textgreater{}} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{stream}\FunctionTok{()}
        \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{with\_index}\FunctionTok{()}
        \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\KeywordTok{fn} \FunctionTok{\{}\NormalTok{row, index}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
          \VariableTok{:timer}\OperatorTok{.}\NormalTok{sleep}\FunctionTok{(}\NormalTok{interval}\FunctionTok{)}

          \ControlFlowTok{if}\NormalTok{ rem}\FunctionTok{(}\NormalTok{index, }\DecValTok{10\_000}\FunctionTok{)} \OperatorTok{==} \DecValTok{0} \KeywordTok{do}
            \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Publisher broadcasted }\OtherTok{\#\{}\NormalTok{index}\OtherTok{\}}\StringTok{ events"}\FunctionTok{)}
          \KeywordTok{end}

\NormalTok{          publish\_trade\_event}\FunctionTok{(}\NormalTok{row}\FunctionTok{)}
        \KeywordTok{end}\FunctionTok{)}
      \KeywordTok{end}\NormalTok{,}
      \VariableTok{timeout:} \VariableTok{:infinity}
    \FunctionTok{)}

    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Publisher finished streaming trade events"}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Finally, the above code uses the \texttt{publish\_trade\_event/1} helper function which converts DataWarehouse's TradeEvent to the Streamer's TradeEvent to broadcast the same structs as the \texttt{streamer} application:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/publisher.ex}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ publish\_trade\_event}\FunctionTok{(}\NormalTok{\%}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    new\_trade\_event }\OperatorTok{=}
\NormalTok{      struct}\FunctionTok{(}
        \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}\NormalTok{,}
\NormalTok{        trade\_event }\OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{to\_list}\FunctionTok{()}
      \FunctionTok{)}

    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      new\_trade\_event}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

We also need to remember about keeping the interface tidy so we will add \texttt{publish\_data} to the \texttt{DataWarehouse} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse.ex}
\OperatorTok{...}
  \KeywordTok{def}\NormalTok{ publish\_data}\FunctionTok{(}\NormalTok{args}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Publisher}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\NormalTok{args}\FunctionTok{)}
  \KeywordTok{end}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

This finishes our implementation - we should be able to stream trade events from the database to the PubSub using the above Task which we will do below.

\section{Test the backtesting}\label{test-the-backtesting}

For consistency and ease of testing/use, I prepared an compressed single data of trade events for XRPUSDT(2019-06-03). We can download that file from GitHub using \texttt{wget}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd /tmp}
\ExtensionTok{$}\NormalTok{ wget https://github.com/Cinderella{-}Man/binance{-}trade{-}events }\DataTypeTok{\textbackslash{}}
\NormalTok{/raw/master/XRPUSDT/XRPUSDT{-}2019{-}06{-}03.csv.gz}
\end{Highlighting}
\end{Shaded}

We can now uncompress the archive and load those trade events into our database:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ gunzip XRPUSDT{-}2019{-}06{-}03.csv.gz}
\ExtensionTok{$}\NormalTok{ PGPASSWORD=hedgehogSecretPassword psql }\AttributeTok{{-}Upostgres} \AttributeTok{{-}h}\NormalTok{ localhost }\AttributeTok{{-}ddata\_warehouse} \DataTypeTok{\textbackslash{}}
\NormalTok{{-}c }\StringTok{"\textbackslash{}COPY trade\_events FROM \textquotesingle{}/tmp/XRPUSDT{-}2019{-}06{-}03.csv\textquotesingle{} WITH (FORMAT csv, delimiter \textquotesingle{};\textquotesingle{});"}
\ExtensionTok{COPY}\NormalTok{ 206115}
\end{Highlighting}
\end{Shaded}

The number after the word \texttt{COPY} in the response indicates the number of rows that got copied into the database.

We can now give it a try and run full backtesting but first let's clean the orders table:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ psql }\AttributeTok{{-}Upostgres} \AttributeTok{{-}h127.0.0.1}
\ExtensionTok{Password}\NormalTok{ for user postgres: }
\ExtensionTok{...}
\VariableTok{postgres}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}c}\NormalTok{ data\_warehouse}
\ExtensionTok{You}\NormalTok{ are now connected to database }\StringTok{"data\_warehouse"}\NormalTok{ as user }\StringTok{"postgres"}\NormalTok{.}
\VariableTok{data\_warehouse}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{DELETE}\NormalTok{ FROM orders}\KeywordTok{;}
\ExtensionTok{DELETE}\NormalTok{ ...}
\end{Highlighting}
\end{Shaded}

\newpage

We can now start a new iex session where we will start trading(the \texttt{naive} application) as well as storing orders(the \texttt{data\_warehouse} application) and instead of starting the \texttt{Streamer.Binance} worker we will start the \texttt{DataWarehouse.Publisher} task with arguments matching the imported day and symbol:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.start\_storing}\KeywordTok{(}\StringTok{"ORDERS"}\ExtensionTok{,} \StringTok{"XRPUSDT"}\KeywordTok{)}      
\ExtensionTok{19:17:59.596} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting storing data from ORDERS:XRPUSDT topic}
\ExtensionTok{19:17:59.632} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  DataWarehouse worker is subscribing to ORDERS:XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.417.0\textgreater{}\}}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{19:18:16.293} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting Elixir.Naive.SymbolSupervisor worker for XRPUSDT}
\ExtensionTok{19:18:16.332} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting new supervision tree to trade on XRPUSDT}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.419.0\textgreater{}\}}
\ExtensionTok{19:18:18.327} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Initializing new trader}\ErrorTok{(}\ExtensionTok{1615288698325}\KeywordTok{)} \ControlFlowTok{for}\NormalTok{ XRPUSDT}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ DataWarehouse.publish\_data}\KeywordTok{(}\ExtensionTok{\%\{}
  \ExtensionTok{type:}\NormalTok{ :trade\_events,}
  \ExtensionTok{symbol:} \StringTok{"XRPUSDT"}\NormalTok{,}
  \ExtensionTok{from:} \StringTok{"2019{-}06{-}02"}\NormalTok{,}
  \ExtensionTok{to:} \StringTok{"2019{-}06{-}04"}\NormalTok{,}
  \ExtensionTok{interval:}\NormalTok{ 5}
\ErrorTok{\}}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.428.0\textgreater{}\}}
\ExtensionTok{19:19:07.532} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Publisher broadcasted 0 events}
\ExtensionTok{19:19:07.534} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1615288698325}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a BUY order for}
\ExtensionTok{XRPUSDT}\NormalTok{ @ 0.44391, quantity: 450.5}
\ExtensionTok{19:19:07.749} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  The trader}\ErrorTok{(}\ExtensionTok{1615288698325}\KeywordTok{)} \ExtensionTok{is}\NormalTok{ placing a SELL order for}
\ExtensionTok{XRPUSDT}\NormalTok{ @ 0.44426, quantity: 450.5.}
\ExtensionTok{...}
\ExtensionTok{19:20:07.568} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Publisher broadcasted 10000 events}
\ExtensionTok{...}
\ExtensionTok{19:21:07.571} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Publisher broadcasted 20000 events}
\ExtensionTok{19:22:07.576} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Publisher broadcasted 30000 events}
\ExtensionTok{...}
\ExtensionTok{19:39:07.875} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Publisher broadcasted 200000 events}
\ExtensionTok{19:39:44.576} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Publisher finished streaming trade events}
\end{Highlighting}
\end{Shaded}

From the above log, we can see that it took about 20 minutes to run 206k records through the system(a lot of that time{[}17+ minutes{]} was indeed the 5ms \texttt{sleep}).

\newpage

After the streaming finished we can check out the orders table inside the database to figure out how many trades we made and what income have they generated.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ psql }\AttributeTok{{-}Upostgres} \AttributeTok{{-}h127.0.0.1}    
\ExtensionTok{Password}\NormalTok{ for user postgres: }
\ExtensionTok{...}
\VariableTok{postgres}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{\textbackslash{}c}\NormalTok{ data\_warehouse}
\ExtensionTok{You}\NormalTok{ are now connected to database }\StringTok{"data\_warehouse"}\NormalTok{ as user }\StringTok{"postgres"}\NormalTok{.}
\VariableTok{data\_warehouse}\OperatorTok{=}\NormalTok{\# }\ExtensionTok{SELECT}\NormalTok{ COUNT}\ErrorTok{(}\ExtensionTok{*}\KeywordTok{)} \ExtensionTok{FROM}\NormalTok{ orders}\KeywordTok{;}
 \ExtensionTok{count} 
\ExtensionTok{{-}{-}{-}{-}{-}{-}{-}}
   \ExtensionTok{224}
\KeywordTok{(}\ExtensionTok{1}\NormalTok{ row}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

By looking at the orders we can figure out some performance metrics but that's less than perfect to get answers to simple questions like ``what's the performance of my strategy?''. We will address that and other concerns in future chapters.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_15}{GitHub}

\chapter{End-to-end testing}\label{end-to-end-testing}

\section{Objectives}\label{objectives-15}

\begin{itemize}
\tightlist
\item
  decide on the tested functionality
\item
  implement basic test
\item
  introduce environment based config files
\item
  add convenience aliases
\item
  cache initial seed data inside a file
\item
  update seeding scripts to use the BinanceMock
\item
  introduce the core application
\end{itemize}

\section{Decide on the tested functionality}\label{decide-on-the-tested-functionality}

We've reached the stage where we have a decent solution in place, and to ensure that it's still working correctly after any future refactoring, we will add tests. We will start with the ``integration''/``end-to-end''(E2E) test, which will confirm that the whole ``trading'' works.

To perform tests at this level, we will need to orchestrate databases together with processes and broadcast trade events from within the test to cause our trading strategy to place orders. We will be able to confirm the right behavior by checking the database after running the test.

You should have the \textbf{least} amount of this type of test as they are very brittle and require substantial effort to set up and maintain. My personal rule of thumb is that only major ``happy paths'' should be tested this way.

\newpage

Let's look at the current flow of data through our system:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_16_01_current_flow} \end{center}

Currently, the \texttt{Streamer.Binance} establishes a WebSocket connection with Binance. It decodes the incoming trade events and broadcasts them to PubSub(\texttt{TRADE\_EVENTS:\#\{symbol\}} topics). PubSub then sends them to the \texttt{Naive.Trader} processes. As those processes place orders(or orders get filled), they broadcast orders to the PubSub(\texttt{ORDERS:\#\{symbol\}} topics). The \texttt{DataWarehouse.Subscriber.Worker} processes subscribe to the broadcasted orders and store them in the database.

\newpage

What we could do is to stop all the \texttt{Streamer.Binance} processes and broadcast trade events directly from the test. We would then be able to fine-tune the prices inside those events to run through the full trade cycle:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_16_02_test} \end{center}

This would allow us to fetch orders from the database to confirm that trading indeed happened.

\section{Implement basic test}\label{implement-basic-test}

We will place our test inside the \texttt{NaiveTest} module inside the \texttt{apps/naive/test/naive\_test.exs} file.
First, we will need to alias multiple modules that we will use to either initialize or confirm the results:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive\_test.exs}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Order}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{, }\VariableTok{as:} \ConstantTok{TradingSettings}
  \ImportTok{alias} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{TradeEvent}

  \ImportTok{import} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Query}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{from:} \DecValTok{2}\OtherTok{]}
\end{Highlighting}
\end{Shaded}

\newpage

Now we can update the generated test to have a tag in front of it:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive\_test.exs}
  \OperatorTok{...}
  \OtherTok{@tag} \VariableTok{integration:} \ConstantTok{true}
\end{Highlighting}
\end{Shaded}

We will use this tag to select only this test when we are running the integration tests.

The first step will be to update the trading settings to values that will cause trading activity:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive\_test.exs}
  \OperatorTok{...}
\NormalTok{  test }\StringTok{"Naive trader full trade(buy + sell) test"} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \StringTok{"XRPUSDT"}

    \CommentTok{\# Step 1 {-} Update trading settings}

\NormalTok{    settings }\OperatorTok{=} \OtherTok{[}
      \VariableTok{profit\_interval:} \FloatTok{0.001}\NormalTok{,}
      \VariableTok{buy\_down\_interval:} \FloatTok{0.0025}\NormalTok{,}
      \VariableTok{chunks:} \DecValTok{5}\NormalTok{,}
      \VariableTok{budget:} \FloatTok{100.0}
    \OtherTok{]}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_}\FunctionTok{\}} \OperatorTok{=}
      \ConstantTok{TradingSettings}
      \OperatorTok{|\textgreater{}} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{get\_by!}\FunctionTok{(}\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Changeset}\OperatorTok{.}\NormalTok{change}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{update}\FunctionTok{()}
\end{Highlighting}
\end{Shaded}

As we updated the trading settings, we can now start trading:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/test/naive\_test.exs}
    \CommentTok{\# \textasciigrave{}test\textasciigrave{} function continued}
    \OperatorTok{...}
    \CommentTok{\# Step 2 {-} Start trading on symbol}

    \ConstantTok{Naive}\OperatorTok{.}\NormalTok{start\_trading}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\newpage

Before we start broadcasting events, we need to ensure that the \texttt{DataWarehouse} application will store resulting orders into the database:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/test/naive\_test.exs}
    \CommentTok{\# \textasciigrave{}test\textasciigrave{} function continued}
    \OperatorTok{...}
    \CommentTok{\# Step 3 {-} Start storing orders}

    \ConstantTok{DataWarehouse}\OperatorTok{.}\NormalTok{start\_storing}\FunctionTok{(}\StringTok{"ORDERS"}\NormalTok{, }\StringTok{"XRPUSDT"}\FunctionTok{)}
    \VariableTok{:timer}\OperatorTok{.}\NormalTok{sleep}\FunctionTok{(}\DecValTok{5000}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Additionally, as seen in the above code, we need to allow some time(5 seconds above) to initialize trading and data storing processes.

We can now move on to broadcasting trade events:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/test/naive\_test.exs}
    \CommentTok{\# \textasciigrave{}test\textasciigrave{} function continued}
    \OperatorTok{...}
    \CommentTok{\# Step 4 {-} Broadcast 9 events}

    \OtherTok{[}
      \CommentTok{\# buy order placed @ 0.4307}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{1}\NormalTok{, }\StringTok{"0.43183010"}\NormalTok{, }\StringTok{"213.10000000"}\FunctionTok{)}\NormalTok{,}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\StringTok{"0.43183020"}\NormalTok{, }\StringTok{"56.10000000"}\FunctionTok{)}\NormalTok{,}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{3}\NormalTok{, }\StringTok{"0.43183030"}\NormalTok{, }\StringTok{"12.10000000"}\FunctionTok{)}\NormalTok{,}
      \CommentTok{\# event at the expected buy price}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{4}\NormalTok{, }\StringTok{"0.4307"}\NormalTok{, }\StringTok{"38.92000000"}\FunctionTok{)}\NormalTok{,}
      \CommentTok{\# event below the expected buy price}
      \CommentTok{\# it should trigger fake fill event for placed buy order}
      \CommentTok{\# and place sell order @ 0.4319}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{5}\NormalTok{, }\StringTok{"0.43065"}\NormalTok{, }\StringTok{"126.53000000"}\FunctionTok{)}\NormalTok{,}
      \CommentTok{\# event below the expected sell price}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{6}\NormalTok{, }\StringTok{"0.43189"}\NormalTok{, }\StringTok{"26.18500000"}\FunctionTok{)}\NormalTok{,}
      \CommentTok{\# event at exact the expected sell price}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{7}\NormalTok{, }\StringTok{"0.4319"}\NormalTok{, }\StringTok{"62.92640000"}\FunctionTok{)}\NormalTok{,}
      \CommentTok{\# event above the expected sell price}
      \CommentTok{\# it should trigger fake fill event for placed sell order}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{8}\NormalTok{, }\StringTok{"0.43205"}\NormalTok{, }\StringTok{"345.14235000"}\FunctionTok{)}\NormalTok{,}
      \CommentTok{\# this one should trigger buy order for a new trader process}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{9}\NormalTok{, }\StringTok{"0.43210"}\NormalTok{, }\StringTok{"3201.86480000"}\FunctionTok{)}
    \OtherTok{]}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{each}\FunctionTok{(}\KeywordTok{fn}\NormalTok{ event }\OperatorTok{{-}\textgreater{}}
      \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
        \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
        \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{        event}
      \FunctionTok{)}

      \VariableTok{:timer}\OperatorTok{.}\NormalTok{sleep}\FunctionTok{(}\DecValTok{10}\FunctionTok{)}
    \KeywordTok{end}\FunctionTok{)}

    \VariableTok{:timer}\OperatorTok{.}\NormalTok{sleep}\FunctionTok{(}\DecValTok{2000}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

The above code will broadcast trade events to the PubSub topic that the trader processes are subscribed to.
It should cause 3 orders to be placed at specific prices. In the last step, we will confirm this by querying the database:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/test/naive\_test.exs}
    \CommentTok{\# \textasciigrave{}test\textasciigrave{} function continued}
    \OperatorTok{...}
    \CommentTok{\# Step 5 {-} Check orders table}

\NormalTok{    query }\OperatorTok{=}
\NormalTok{      from}\FunctionTok{(}\NormalTok{o }\KeywordTok{in} \ConstantTok{Order}\NormalTok{,}
        \VariableTok{select:} \OtherTok{[}\NormalTok{o}\OperatorTok{.}\NormalTok{price, o}\OperatorTok{.}\NormalTok{side, o}\OperatorTok{.}\NormalTok{status}\OtherTok{]}\NormalTok{,}
        \VariableTok{order\_by:}\NormalTok{ o}\OperatorTok{.}\NormalTok{inserted\_at,}
        \VariableTok{where:}\NormalTok{ o}\OperatorTok{.}\NormalTok{symbol }\OperatorTok{==} \OperatorTok{\^{}}\NormalTok{symbol}
      \FunctionTok{)}

    \OtherTok{[}\NormalTok{buy\_1, sell\_1, buy\_2}\OtherTok{]} \OperatorTok{=} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{all}\FunctionTok{(}\NormalTok{query}\FunctionTok{)}

\NormalTok{    assert buy\_1 }\OperatorTok{==} \OtherTok{[}\StringTok{"0.43070000"}\NormalTok{, }\StringTok{"BUY"}\NormalTok{, }\StringTok{"FILLED"}\OtherTok{]}
\NormalTok{    assert sell\_1 }\OperatorTok{==} \OtherTok{[}\StringTok{"0.43190000"}\NormalTok{, }\StringTok{"SELL"}\NormalTok{, }\StringTok{"FILLED"}\OtherTok{]}
\NormalTok{    assert buy\_2 }\OperatorTok{==} \OtherTok{[}\StringTok{"0.43100000"}\NormalTok{, }\StringTok{"BUY"}\NormalTok{, }\StringTok{"NEW"}\OtherTok{]}
\end{Highlighting}
\end{Shaded}

That finishes the test function. The final addition inside the \texttt{NaiveTest} module will be to add a private helper function that generates trade event for the passed values:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive\_test.exs}
  \OperatorTok{...}
  
  \KeywordTok{defp}\NormalTok{ generate\_event}\FunctionTok{(}\NormalTok{id, price, quantity}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
      \VariableTok{event\_type:} \StringTok{"trade"}\NormalTok{,}
      \VariableTok{event\_time:} \DecValTok{1\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{symbol:} \StringTok{"XRPUSDT"}\NormalTok{,}
      \VariableTok{trade\_id:} \DecValTok{2\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{price:}\NormalTok{ price,}
      \VariableTok{quantity:}\NormalTok{ quantity,}
      \VariableTok{buyer\_order\_id:} \DecValTok{3\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{seller\_order\_id:} \DecValTok{4\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{trade\_time:} \DecValTok{5\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{buyer\_market\_maker:} \ConstantTok{false}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This finishes the implementation of the test, but as we are now using DataWarehouse's modules inside the Naive application, we need to add \texttt{data\_warehouse} to the dependencies:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:data\_warehouse}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\NormalTok{, }\VariableTok{only:} \VariableTok{:test}\FunctionTok{\}}\NormalTok{,}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We could now run our new integration test, but it would be run against our current(development) databases. In addition, as we will need to reset all the data inside them before every test run, it could mean losing data. To avoid all of those problems, we will use separate databases for testing.

\section{Introduce environment based config files}\label{introduce-environment-based-config-files}

Currently, our new test is running in the test environment (the \texttt{MIX\_ENV} environmental variable is set to \texttt{"test"} whenever we run \texttt{mix\ test}), but we do not leverage that fact to configure our application for example: to use test databases as mentioned above.

Configuration for our applications lives in \texttt{config/config.exs} configuration file. Inside it, we have access to the name of the environment, which we will utilize to place an environment based \texttt{import\_config/1} function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\CommentTok{\# add the below at the end of the file}
\OperatorTok{...}
\NormalTok{import\_config }\StringTok{"}\OtherTok{\#\{}\NormalTok{config\_env}\FunctionTok{()}\OtherTok{\}}\StringTok{.exs"}
\end{Highlighting}
\end{Shaded}

Now we will create multiple config files, one for each environment:

\begin{itemize}
\tightlist
\item
  \texttt{/config/dev.exs} for development:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/dev.exs}
\ImportTok{import} \ConstantTok{Config}
\end{Highlighting}
\end{Shaded}

\newpage

\begin{itemize}
\tightlist
\item
  \texttt{/config/test.exs} for future ``unit'' testing:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/test.exs}
\ImportTok{import} \ConstantTok{Config}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{/config/integration.exs} for end-to-end testing:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/integration.exs}
\ImportTok{import} \ConstantTok{Config}

\NormalTok{config }\VariableTok{:streamer}\NormalTok{, }\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\VariableTok{database:} \StringTok{"streamer\_test"}

\NormalTok{config }\VariableTok{:naive}\NormalTok{, }\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\VariableTok{database:} \StringTok{"naive\_test"}

\NormalTok{config }\VariableTok{:data\_warehouse}\NormalTok{, }\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\VariableTok{database:} \StringTok{"data\_warehouse\_test"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{/config/prod.exs} for production:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/prod.exs}
\ImportTok{import} \ConstantTok{Config}

\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{Binance}
\end{Highlighting}
\end{Shaded}

After adding the above environment-based configuration files, our test will use the test databases.

There's one more remaining problem - we need to set those test databases before each test run, and as this process requires multiple steps, it's a little bit cumbersome.

\section{Add convenience aliases}\label{add-convenience-aliases}

To be able to run our new integration test as easily as possible without bothering ourselves with all the database setup, we will introduce aliases in both the \texttt{streamer} and \texttt{naive} applications that will wrap seeding the databases:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/mix.exs \& /apps/streamer/mix.exs }
  \KeywordTok{def}\NormalTok{ project }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \VariableTok{aliases:}\NormalTok{ aliases}\FunctionTok{()}
    \OtherTok{]}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ aliases }\KeywordTok{do}
    \OtherTok{[}
      \VariableTok{seed:} \OtherTok{[}\StringTok{"run priv/seed\_settings.exs"}\OtherTok{]}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Inside the main \texttt{mix.exs} file of our umbrella, we will use those with usual \texttt{ecto}'s commands like \texttt{ecto.create} and \texttt{ecto.migrate}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /mix.exs }
  \KeywordTok{def}\NormalTok{ project }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \VariableTok{aliases:}\NormalTok{ aliases}\FunctionTok{()}
    \OtherTok{]}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ aliases }\KeywordTok{do}
    \OtherTok{[}
      \VariableTok{setup:} \OtherTok{[}
        \StringTok{"ecto.drop"}\NormalTok{,}
        \StringTok{"ecto.create"}\NormalTok{,}
        \StringTok{"ecto.migrate"}\NormalTok{,}
        \StringTok{"cmd {-}{-}app naive {-}{-}app streamer mix seed"}
      \OtherTok{]}\NormalTok{,}
      \StringTok{"test.integration"}\NormalTok{: }\OtherTok{[}
        \StringTok{"setup"}\NormalTok{,}
        \StringTok{"test {-}{-}only integration"}
      \OtherTok{]}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now safely run our test:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ MIX\_ENV=integration mix test.integration}
\end{Highlighting}
\end{Shaded}

Wait\ldots{} Why do we need to set the \texttt{MIX\_ENV} before calling our alias?

So, as I mentioned earlier, the \texttt{mix\ test} command automatically assigns the \texttt{"test"} environment when called. However, our alias contains other commands like \texttt{mix\ ecto.create}, which without specifying the environment explicitly, would be run using the dev database. So we would set up the dev databases(drop, create, migrate \& seed) and then run tests on the test databases.

So our test is now passing, but it relies on the database being setup upfront, which requires seeding using a couple of requests to the Binance API.

\section{Cache initial seed data inside a file}\label{cache-initial-seed-data-inside-a-file}

Relying on the 3rd party API to be able to seed our database to run tests is a horrible idea. However, we can fix that by cache the response JSON in a file.

How will this data be tunneled into the test database?

In the spirit of limiting the change footprint, we could update the \texttt{BinanceMock} module to serve the cached data dependent on the flag - let's add that flag first:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\CommentTok{\# add below lines under the \textasciigrave{}import Config\textasciigrave{} line }
\NormalTok{config }\VariableTok{:binance\_mock}\NormalTok{,}
  \VariableTok{use\_cached\_exchange\_info:} \ConstantTok{false}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/integration.exs}
\CommentTok{\# add below lines under the \textasciigrave{}import Config\textasciigrave{} line }
\NormalTok{config }\VariableTok{:binance\_mock}\NormalTok{,}
  \VariableTok{use\_cached\_exchange\_info:} \ConstantTok{true}
\end{Highlighting}
\end{Shaded}

We can see how convenient it is to have a configuration file per environment - we enabled cached exchange info data only for the test environment.

Inside the \texttt{BinanceMock} module, we can now update the \texttt{get\_exchange\_info/0} function to use this configuration value to serve either cached or live exchange info response:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ get\_exchange\_info}\FunctionTok{()} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Application}\OperatorTok{.}\NormalTok{get\_env}\FunctionTok{(}\VariableTok{:binance\_mock}\NormalTok{, }\VariableTok{:use\_cached\_exchange\_info}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{true} \OperatorTok{{-}\textgreater{}}\NormalTok{ get\_cached\_exchange\_info}\FunctionTok{()}
\NormalTok{      \_ }\OperatorTok{{-}\textgreater{}} \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
    \KeywordTok{end}
  \KeywordTok{end}

  \CommentTok{\# add this at the bottom of the module}
  \KeywordTok{defp}\NormalTok{ get\_cached\_exchange\_info }\KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, data}\FunctionTok{\}} \OperatorTok{=}
      \ConstantTok{File}\OperatorTok{.}\NormalTok{cwd!}\FunctionTok{()}
      \OperatorTok{|\textgreater{}} \ConstantTok{Path}\OperatorTok{.}\NormalTok{split}\FunctionTok{()}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{drop}\FunctionTok{(}\OperatorTok{{-}}\DecValTok{1}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Kernel}\OperatorTok{.++}\FunctionTok{(}\OtherTok{[}
        \StringTok{"binance\_mock"}\NormalTok{,}
        \StringTok{"test"}\NormalTok{,}
        \StringTok{"assets"}\NormalTok{,}
        \StringTok{"exchange\_info.json"}
      \OtherTok{]}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Path}\OperatorTok{.}\NormalTok{join}\FunctionTok{()}
      \OperatorTok{|\textgreater{}} \ConstantTok{File}\OperatorTok{.}\NormalTok{read}\FunctionTok{()}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\ConstantTok{Jason}\OperatorTok{.}\NormalTok{decode!}\FunctionTok{(}\NormalTok{data}\FunctionTok{)} \OperatorTok{|\textgreater{}} \ConstantTok{Binance}\OperatorTok{.}\ConstantTok{ExchangeInfo}\OperatorTok{.}\NormalTok{new}\FunctionTok{()\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As the \texttt{binance\_mock} app wasn't using the \texttt{jason} package before, we need to add it to dependencies:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/binance\_mock/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:jason}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.2"}\FunctionTok{\}}\NormalTok{,}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The above change will take care of flipping between serving the live/cached exchange info data, but we still need to manually save the current response to the file (to be used as a cached version later).

Let's open the IEx terminal to fetch the exchange info data and serialize it to JSON:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Binance.get\_exchange\_info}\KeywordTok{()} \KeywordTok{|}\OperatorTok{\textgreater{}}\NormalTok{ elem}\KeywordTok{(}\ExtensionTok{1}\KeywordTok{)} \KeywordTok{|}\OperatorTok{\textgreater{}}\NormalTok{ Jason.encode!}
\end{Highlighting}
\end{Shaded}

You should get the following error:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{...}\NormalTok{ of type Binance.ExchangeInfo }\ErrorTok{(}\ExtensionTok{a}\NormalTok{ struct}\KeywordTok{)}\ExtensionTok{,}\NormalTok{ Jason.Encoder protocol must always be}
\ExtensionTok{explicitly}\NormalTok{ implemented.}

\ExtensionTok{If}\NormalTok{ you own the struct, you can derive the implementation specifying which fields}
\ExtensionTok{should}\NormalTok{ be encoded to JSON:}

    \ExtensionTok{@derive}\NormalTok{ \{Jason.Encoder, only: }\PreprocessorTok{[}\SpecialStringTok{....}\PreprocessorTok{]}\NormalTok{\}}
    \ExtensionTok{defstruct}\NormalTok{ ...}

\ExtensionTok{It}\NormalTok{ is also possible to encode all fields, although this should be used carefully}
\ExtensionTok{to}\NormalTok{ avoid accidentally leaking private information when new fields are added:}

    \ExtensionTok{@derive}\NormalTok{ Jason.Encoder}
    \ExtensionTok{defstruct}\NormalTok{ ...}

\ExtensionTok{Finally,}\NormalTok{ if you dont own the struct you want to encode to JSON, you may use}
\ExtensionTok{Protocol.derive/3}\NormalTok{ placed outside of any module: }

    \ExtensionTok{Protocol.derive}\ErrorTok{(}\ExtensionTok{Jason.Encoder,}\NormalTok{ NameOfTheStruct, only: }\PreprocessorTok{[}\SpecialStringTok{...}\PreprocessorTok{]}\KeywordTok{)}
    \ExtensionTok{Protocol.derive}\ErrorTok{(}\ExtensionTok{Jason.Encoder,}\NormalTok{ NameOfTheStruct}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

In a nutshell, this means that the \texttt{jason} package doesn't know how to encode the \texttt{Binance.ExchangeInfo} struct. Ok, as we don't own this struct(it's a part of the \texttt{binance} package), we will follow the last suggestion and try to derive the \texttt{Jason.Encoder} module for the \texttt{Binance.ExchangeInfo} struct:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ require }\ExtensionTok{Protocol}
\ExtensionTok{Protocol}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Protocol.derive}\KeywordTok{(}\ExtensionTok{Jason.Encoder,}\NormalTok{ Binance.ExchangeInfo}\KeywordTok{)}
\ExtensionTok{warning:}\NormalTok{ the Jason.Encoder protocol has already been consolidated, an implementation for}
\ExtensionTok{Binance.ExchangeInfo}\NormalTok{ has no effect. If you want to implement protocols after compilation}
\ExtensionTok{or}\NormalTok{ during tests, check the }\StringTok{"Consolidation"}\NormalTok{ section in the Protocol module documentation}
  \ExtensionTok{iex:2:} \ErrorTok{(}\FunctionTok{file}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

Hmm\ldots{} This didn't work again. The reason for it is a mechanism called the ``Protocol consolidation''. Long story short, Elixir at compilation time knows upfront what structs derive which protocols, and to speed things up, it consolidates them at that moment. To avoid this process being run in development, we can modify the main \texttt{mix.exs} file to disable it:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /mix.exs }
  \KeywordTok{def}\NormalTok{ project }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \VariableTok{consolidate\_protocols:} \ConstantTok{Mix}\OperatorTok{.}\NormalTok{env}\FunctionTok{()} \OperatorTok{==} \VariableTok{:prod}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We should now be able to encode JSON using the \texttt{jason} module:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mkdir apps/binance\_mock/test/assets}
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ require }\ExtensionTok{Protocol}
\ExtensionTok{Protocol}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Protocol.derive}\KeywordTok{(}\ExtensionTok{Jason.Encoder,}\NormalTok{ Binance.ExchangeInfo}\KeywordTok{)}
\ExtensionTok{:ok}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ data }\ExtensionTok{=}\NormalTok{ Binance.get\_exchange\_info}\ErrorTok{(}\KeywordTok{)} \KeywordTok{|}\OperatorTok{\textgreater{}}\NormalTok{ elem}\KeywordTok{(}\ExtensionTok{1}\KeywordTok{)} \KeywordTok{|}\OperatorTok{\textgreater{}}\NormalTok{ Jason.encode}\PreprocessorTok{!(}\NormalTok{pretty: true}\PreprocessorTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{4}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ File.write}\KeywordTok{(}\StringTok{"apps/binance\_mock/test/assets/exchange\_info.json"}\ExtensionTok{,}\NormalTok{ data}\KeywordTok{)}
\ExtensionTok{:ok}
\end{Highlighting}
\end{Shaded}

So we have the BinanceMock updated to serve cached/live responses based on the configuration and cached exchange info response.

The last step is to ensure that seeding uses the BinanceMock module instead of using Binance directly to leverage the above implementation.

\section{Update seeding scripts to use the BinanceMock}\label{update-seeding-scripts-to-use-the-binancemock}

The seed settings script for the \texttt{Naive} application(apps/naive/priv/seed\_settings.exs) already uses the \texttt{BinanceMock}.

Inside the \texttt{Streamer} application (apps/streamer/priv/seed\_settings.exs) we can see that the \texttt{Binance} module is getting used. So we can update the fetching part of the script to the following to fix it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/priv/seed\_settings.exs}
\NormalTok{binance\_client }\OperatorTok{=} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:streamer}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)} \CommentTok{\# \textless{}= new}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Fetching exchange info from Binance to create streaming settings"}\FunctionTok{)}

\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbols:}\NormalTok{ symbols}\FunctionTok{\}\}} \OperatorTok{=}\NormalTok{ binance\_client}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()} \CommentTok{\# \textless{}= updated}
\end{Highlighting}
\end{Shaded}

We need to update the config to point to the \texttt{BinanceMock} for the \texttt{streamer} application in the same way as we do for the \texttt{naive} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\OperatorTok{...}
\NormalTok{config }\VariableTok{:streamer}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock}\NormalTok{, }\CommentTok{\# \textless{}= added}
  \VariableTok{ecto\_repos:} \OtherTok{[}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\OtherTok{]}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/prod.exs}
\OperatorTok{...}
\NormalTok{config }\VariableTok{:streamer}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{Binance}
\end{Highlighting}
\end{Shaded}

as well as swap the \texttt{binance} to the \texttt{BinanceMock} inside the list of dependencies of the \texttt{Streamer} app:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/mix.exs}
\OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:binance\_mock}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}\NormalTok{,}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

At this moment, we should be ready to run our test using the test database together with cached Binance response:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ MIX\_ENV=test mix test.integration}
\ExtensionTok{**} \ErrorTok{(}\ExtensionTok{Mix}\KeywordTok{)} \ExtensionTok{Could}\NormalTok{ not sort dependencies. There are cycles in the dependency graph}
\end{Highlighting}
\end{Shaded}

And this is the moment when we will pay for cutting corners in the past. Let me explain. When we started this project, as we implemented communication using the PubSub topics, we put both the \texttt{PubSub} process(in the supervision tree) and the \texttt{TradeEvent} struct inside the streamer application. The knock-on effect of this decision is that any other app in the umbrella that would like to use either \texttt{PubSub} or \texttt{TradeEvent} struct needs to depend on the \texttt{streamer} application:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_16_03_relying_on_streamer} \end{center}

As we added the \texttt{binance\_mock} application as a dependency of the streamer application, we created a dependency cycle.

This is quite typical in daily work as a software engineer. One of the common problems(besides naming things) is deciding where things belong. For example, do PubSub and TradeEvent belong in the Streamer app? Or maybe we should put it in the BinanceMock?

I believe that it should be neither of them as those applications use the PubSub and TradeEvent struct. I believe that they should be placed in neither of those applications as those applications are only
using the struct and PubSub process.

What we should do instead is to create a new supervised application where we can attach the PubSub to the supervision tree and hold the system-wide structs(like TradeEvent) so every app can depend on it instead of each other:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_16_04_core} \end{center}

\newpage

\section{Introduce the Core application}\label{introduce-the-core-application}

Let's start with create a new application:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps}
\ExtensionTok{$}\NormalTok{ mix new }\AttributeTok{{-}{-}sup}\NormalTok{ core}
\end{Highlighting}
\end{Shaded}

We can now create a new directory called \texttt{struct} inside the \texttt{apps/core/lib/core} directory and move the \texttt{TradeEvent} struct from the \texttt{streamer} app to it(in the same terminal or from the \texttt{apps} directory):

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mkdir core/lib/core/struct}
\ExtensionTok{$}\NormalTok{ mv streamer/lib/streamer/binance/trade\_event.ex core/lib/core/struct}
\end{Highlighting}
\end{Shaded}

Now we need to update the module to \texttt{Core.Struct.TradeEvent}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/struct/trade\_event.ex}
\OperatorTok{...}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Struct}\OperatorTok{.}\ConstantTok{TradeEvent} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

As we moved the \texttt{TradeEvent} struct over to the \texttt{Core} application, we need to:

\begin{itemize}
\tightlist
\item
  update all places that reference the \texttt{Streamer.Binance.TradeEvent} to \texttt{Core.Struct.TradeEvent}
\item
  add the \texttt{core} to the dependencies lists of all apps in the umbrella
\item
  remove the \texttt{streamer} from the dependencies lists of all apps in the umbrella
\end{itemize}

The final step will be to move the PubSub process from the supervision tree of the Streamer application to the supervision of the Core application.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/streamer/lib/streamer/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}
        \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
        \VariableTok{name:} \ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{, }\VariableTok{adapter\_name:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\ConstantTok{PG2}
      \FunctionTok{\}}\NormalTok{, }\CommentTok{\# \^{} remove it from here}
      \OperatorTok{...}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}
        \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
        \VariableTok{name:} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{, }\VariableTok{adapter\_name:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\ConstantTok{PG2}
      \FunctionTok{\}} \CommentTok{\# \^{} add it here}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

As we changed the module name of the PubSub process(from \texttt{Streamer.PubSub} to \texttt{Core.PubSub}), we need to update all the places where it's referenced as well as add the \texttt{phoenix\_pubsub} package to dependencies of the \texttt{core} application:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:phoenix\_pubsub}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now run our test that will use the test database as well as cached exchange info:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ MIX\_ENV=test mix test.integration}
\end{Highlighting}
\end{Shaded}

We should see a lot of setup log followed by a confirmation:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Finished}\NormalTok{ in 0.03 seconds }\ErrorTok{(}\ExtensionTok{0.00s}\NormalTok{ async, 0.03s sync}\KeywordTok{)}
\ExtensionTok{1}\NormalTok{ test, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

This wraps up our implementation of the end-to-end test. In the next chapter, we will see how we would implement a unit test for our trading strategy.

The additional benefit of all the time that we put in the implementation of this test is that we won't need to remember how to set up local environment anymore as it's as simple as:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{mix}\NormalTok{ setup}
\end{Highlighting}
\end{Shaded}

Yay! :)

It's worth reiterating the downsides of the end-to-end tests:

\begin{itemize}
\tightlist
\item
  lack of visibility over what's broken - most of the time, we will see the result of error but not the error itself
\item
  requirement of synchronous execution - they rely on the database(s), so they can't be run in parallel
\item
  randomness/flakiness - as there's no feedback loop, we wait for a hardcoded amount of time, that we assume it's enough to finish initialization/execution - this can randomly fail
\end{itemize}

It's possible to implement a feedback loop and run our tests inside ``sandbox'' (transaction), but it's not worth it as we can invest that time into developing reliable unit tests.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_16}{GitHub}

\chapter{Mox rocks}\label{mox-rocks}

\section{Objectives}\label{objectives-16}

\begin{itemize}
\tightlist
\item
  introduction to mock based tests
\item
  add the Mox package
\item
  investigate the \texttt{Naive.Trader} module

  \begin{itemize}
  \tightlist
  \item
    mock the \texttt{Binance} module
  \item
    mock the \texttt{NaiveLeader} module
  \item
    mock the \texttt{Phoenix.PubSub} module
  \item
    mock the \texttt{Logger} module
  \end{itemize}
\item
  implement a test of the \texttt{Naive.Trader} module
\item
  define an alias to run unit tests
\end{itemize}

\section{Introduction to mock based tests}\label{introduction-to-mock-based-tests}

In the previous chapter, we've implemented the end-to-end test. It required a lot of prep work as well as we were able to see the downsides of this type of test clearly:

\begin{itemize}
\tightlist
\item
  we will be unable to run more than one end-to-end test in parallel as they rely on the database's state
\item
  we need to set up the database before every test run
\item
  we need to start processes in the correct order with the suitable parameters
\item
  we need to wait a (guessed) hardcoded amount of time that it will take to finish the trading(this is extremely bad as it will cause randomly failing tests as people will make the time shorter to speed up tests)
\item
  we wouldn't be able to quickly pinpoint which part error originated from as the test spans over a vast amount of the system
\item
  logging was polluting our test output
\end{itemize}

\newpage

How could we fix the above issues?

The most common way is to limit the scope of the test. Instead of testing the whole trading flow, we could focus on testing a single \texttt{Naive.Trader} process.

Focusing on a single trader process would remove the requirement for starting multiple processes before testing, but it would also bring its own challenges.

Let's look at a concrete example:

When the \texttt{Naive.Trader} process starts, it subscribes to the \texttt{TRADE\_EVENTS:\#\{symbol\}} PubSub topic. It also broadcasts updates of the orders it placed to the \texttt{ORDERS:\#\{symbol\}} PubSub topic.

How could we break the link between the \texttt{Naive.Trader} and the PubSub(or any other module it depends on)?

We could utilize the trick that we used for the \texttt{Binance} module. We could create a module that provides the same functions as the \texttt{PubSub} module.

We know that the trader process calls \texttt{Phoenix.PubSub.subscribe/2} and \texttt{Phoenix.PubSub.broadcast/3} functions. We could implement a module that contains the same functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{defmodule} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSub} \KeywordTok{do}
    \KeywordTok{def}\NormalTok{ subscribe}\FunctionTok{(}\NormalTok{\_, \_}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:ok}
    \KeywordTok{def}\NormalTok{ broadcast}\FunctionTok{(}\NormalTok{\_, \_, \_}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:ok}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above module would satisfy the PubSub's functionality required by the \texttt{Naive.Trader} module, but this solution comes with a couple of drawbacks:

\begin{itemize}
\tightlist
\item
  it doesn't the passed values. It just ignores them, which is a missed opportunity to confirm that the PubSub module was called with the expected values.
\item
  we can't define a custom implemention specific to test. This is possible by extending the implemention with test related returns(hack!)
\end{itemize}

Using the \texttt{mox} module would fix both of the problems mentioned above. With the \texttt{mox} module we can define add-hoc function implemention per test:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# inside test file}
\NormalTok{    test }\OperatorTok{...}
        \ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSubMock}
        \OperatorTok{|\textgreater{}}\NormalTok{ expect}\FunctionTok{(}\VariableTok{:subscribe}\NormalTok{, }\KeywordTok{fn} \FunctionTok{(}\NormalTok{\_module, }\StringTok{"TRADE\_EVENTS:XRPUSDT"}\FunctionTok{)} \OperatorTok{{-}\textgreater{}} \VariableTok{:ok} \KeywordTok{end}\FunctionTok{)}
        \OperatorTok{|\textgreater{}}\NormalTok{ expect}\FunctionTok{(}\VariableTok{:broadcast}\NormalTok{, }\KeywordTok{fn} \FunctionTok{(}\NormalTok{\_module, }\StringTok{"ORDERS:XRPUSDT"}\NormalTok{, \_order}\FunctionTok{)} \OperatorTok{{-}\textgreater{}} \VariableTok{:ok} \KeywordTok{end}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\newpage

There are multiple benefits to using the \texttt{mox} module instead of handcrafting the implementation:

\begin{itemize}
\tightlist
\item
  it allows defining functions that will pattern match values specific to each test(as in the case of the ``usual'' pattern matching, they will break when called with unexpected values)
\item
  it allows defining implementations of the mocked functions based on incoming(test specific) values
\item
  it can validate that all defined mocked functions have been called by the test
\item
  it comes with its own tests, so we don't need to test it as it would need with our custom handcrafted mimicking module implementation
\end{itemize}

But there's a catch* ;)

For the \texttt{mox} to know what sort of functions the module provides, it needs to know its \texttt{behaviour}.

In Elixir, to define a behaviour of the module, we need to add the \texttt{@callback} attributes to it:

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSub} \KeywordTok{do}
    \OtherTok{@type}\NormalTok{ t :: atom}
    \OtherTok{@type}\NormalTok{ topic :: binary}
    \OtherTok{@type}\NormalTok{ message :: term}

    \OtherTok{@callback}\NormalTok{ subscribe}\FunctionTok{(}\NormalTok{t, topic}\FunctionTok{)}\NormalTok{ :: }\VariableTok{:ok} \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, term}\FunctionTok{\}}
    \OtherTok{@callback}\NormalTok{ broadcast}\FunctionTok{(}\NormalTok{t, topic, message}\FunctionTok{)}\NormalTok{ :: }\VariableTok{:ok} \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, term}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

A \texttt{behaviour} can be defined in a separate module if we are working with 3rd party module that doesn't provide it(like in the case of the \texttt{Phoenix.PubSub} module).

Note: The additional benefit of using the \texttt{behaviours} is that we could tell Elixir that our module \emph{implements} the behaviour by adding the \texttt{@behaviour} attribute:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \ConstantTok{MyPubSub} \KeywordTok{do}
    \OtherTok{@behaviour} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSub}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Using the above will cause Elixir to validate at compile time that the \texttt{MyPubSub} module implements all functions defined inside the \texttt{Core.Test.PubSub} module(otherwise it will raise compilation error).

Let's get back to the main topic. We figured out that we could mock all of the modules that the \texttt{Naive.Trader} depends on using the \texttt{mox} module.

But, how would we tell the \texttt{Naive.Trader} to use the mocked modules instead of the ``real'' ones when we run tests?

We could make all modules that the \texttt{Naive.Trader} depends on be dynamically injected from the configuration(based on the environment).

Another requirement to make \texttt{mox} work is to define the mocks upfront using the \texttt{Mox.defmock/2} function. It will dynamically define a new module that will be limited by the passed behaviour(we will only be able to mock{[}inside tests{]} functions defined as a part of that behaviour).

\newpage

To sum up, there are a few steps to get the \texttt{mox} running:

\begin{itemize}
\tightlist
\item
  implement behaviours that we would like to mock(as most of the packages{[}like \texttt{Phoenix.PubSub}{]} are not coming with those)
\item
  define mock modules using the \texttt{Mox.defmock} function
\item
  modify the application's configuration to use the mocked module(s)
\item
  specify mocked module's expectation inside the test
\end{itemize}

Let's move to the implementation.

\section{\texorpdfstring{Add the \texttt{mox} package}{Add the mox package}}\label{add-the-mox-package}

First let's add the \texttt{mox} package to the \texttt{naive} application's dependencies:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/mix.exs}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:mox}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{:test}\NormalTok{, }\VariableTok{:integration}\OtherTok{]}\FunctionTok{\}}\NormalTok{,}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We can now run \texttt{mix\ deps.get} to fetch the \texttt{mox} package.

{[}Note{]} As we will add the \texttt{mox}'s mocking code into the \texttt{test\_helper.exs} file, we need to
make \texttt{mox} available in all test environments(both \texttt{test} and \texttt{integration}).

\section{\texorpdfstring{Investigate the \texttt{Naive.Trader} module}{Investigate the Naive.Trader module}}\label{investigate-the-naive.trader-module}

Let's investigate the \texttt{Naive.Trader} module(\texttt{/apps/naive/lib/naive/trader.ex}). We are looking for all calls to other modules - we can see:

\begin{itemize}
\tightlist
\item
  \texttt{Logger.info/2}
\item
  \texttt{Phoenix.PubSub.subscribe/2}
\item
  \texttt{@binance\_client.order\_limit\_buy/4}
\item
  \texttt{Naive.Leader.notify/2}
\item
  \texttt{@binance\_client.get\_order/3}
\item
  \texttt{@binance\_client.order\_limit\_sell/4}
\item
  \texttt{Phoenix.PubSub.broadcast/3}
\end{itemize}

So the \texttt{Naive.Trader} relies on four modules:

\begin{itemize}
\tightlist
\item
  \texttt{Logger}
\item
  \texttt{Phoenix.PubSub}
\item
  \texttt{Naive.Leader}
\item
  \texttt{@binance\_client}(either \texttt{Binance} or \texttt{BinanceMock})
\end{itemize}

We will need to work through them one by one.

\subsection{\texorpdfstring{Mock the \texttt{Binance} module}{Mock the Binance module}}\label{mock-the-binance-module}

Let's start with the binance client, as it's already a dynamic value based on the configuration.

Neither the \texttt{Binance} nor the \texttt{BinanceMock}(our dummy implementation) module doesn't provide a behaviour - let's fix that by defining the \texttt{@callback} attributes at the top of the \texttt{BinanceMock} module before the structs:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}
  \ImportTok{alias} \ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Struct}\OperatorTok{.}\ConstantTok{TradeEvent}

  \OtherTok{@type}\NormalTok{ symbol :: binary}
  \OtherTok{@type}\NormalTok{ quantity :: binary}
  \OtherTok{@type}\NormalTok{ price :: binary}
  \OtherTok{@type}\NormalTok{ time\_in\_force :: binary}
  \OtherTok{@type}\NormalTok{ timestamp :: non\_neg\_integer}
  \OtherTok{@type}\NormalTok{ order\_id :: non\_neg\_integer}
  \OtherTok{@type}\NormalTok{ orig\_client\_order\_id :: binary}
  \OtherTok{@type}\NormalTok{ recv\_window :: binary}

  \OtherTok{@callback}\NormalTok{ order\_limit\_buy}\FunctionTok{(}
\NormalTok{              symbol,}
\NormalTok{              quantity,}
\NormalTok{              price,}
\NormalTok{              time\_in\_force}
            \FunctionTok{)}\NormalTok{ :: }\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{OrderResponse}\FunctionTok{\{\}\}} \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, term}\FunctionTok{\}}

  \OtherTok{@callback}\NormalTok{ order\_limit\_sell}\FunctionTok{(}
\NormalTok{              symbol,}
\NormalTok{              quantity,}
\NormalTok{              price,}
\NormalTok{              time\_in\_force}
            \FunctionTok{)}\NormalTok{ :: }\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{OrderResponse}\FunctionTok{\{\}\}} \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, term}\FunctionTok{\}}

  \OtherTok{@callback}\NormalTok{ get\_order}\FunctionTok{(}
\NormalTok{              symbol,}
\NormalTok{              timestamp,}
\NormalTok{              order\_id,}
\NormalTok{              orig\_client\_order\_id }\OperatorTok{|} \ConstantTok{nil}\NormalTok{,}
\NormalTok{              recv\_window }\OperatorTok{|} \ConstantTok{nil}
            \FunctionTok{)}\NormalTok{ :: }\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Order}\FunctionTok{\{\}\}} \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, term}\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

In the above code, we added three \texttt{@callback} attributes that define the binance client behaviour. For clarity, we defined a distinct type for each of the arguments.

As we now have a binance client behaviour defined, we can use it to define a mock using the \texttt{Mox.defmock/2} function inside the \texttt{test\_helper.exs} file of the \texttt{naive} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\ConstantTok{ExUnit}\OperatorTok{.}\NormalTok{start}\FunctionTok{()}

\ConstantTok{Application}\OperatorTok{.}\NormalTok{ensure\_all\_started}\FunctionTok{(}\VariableTok{:mox}\FunctionTok{)} \CommentTok{\#1}

\ConstantTok{Mox}\OperatorTok{.}\NormalTok{defmock}\FunctionTok{(}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{BinanceMock}\NormalTok{, }\KeywordTok{for}\NormalTok{: }\ConstantTok{BinanceMock}\FunctionTok{)} \CommentTok{\#2}
\end{Highlighting}
\end{Shaded}

First(\#1), we need to ensure that the \texttt{mox} application has been started. Then(\#2), we can tell the \texttt{mox} package to define the \texttt{Test.BinanceMock} module based on the \texttt{BinanceMock} behaviour.

As we defined the binance client behaviour and mock, we can update our configuration to use them. We want to keep using the \texttt{BinanceMock} module in the development environment, but for the \texttt{test} environment, we would like to set the mocked module generated by the \texttt{mox} package:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/test.exs}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{BinanceMock}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Mock the \texttt{NaiveLeader} module}{Mock the NaiveLeader module}}\label{mock-the-naiveleader-module}

We can now move back to the \texttt{Naive.Trader} module to update all the hardcoded references to the \texttt{Naive.Leader} module with a dynamic attribute called \texttt{@leader} and add this attribute at the top of the module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/trader.ex}
  \OperatorTok{...}
  \OtherTok{@leader} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:leader}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:rebuy\_triggered}\NormalTok{, new\_state}\FunctionTok{)}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

As it was in case of the \texttt{BinanceMock}(our dummy implementation) module, the \texttt{Naive.Leader} module doesn't provide a behaviour - let's fix that by defining the \texttt{@callback} attributes at the top of the module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/leader.ex}
  \OperatorTok{...}
  \OtherTok{@type}\NormalTok{ event\_type :: atom}
  \OtherTok{@callback}\NormalTok{ notify}\FunctionTok{(}\NormalTok{event\_type, \%}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\FunctionTok{\{\})}\NormalTok{ :: }\VariableTok{:ok}
\end{Highlighting}
\end{Shaded}

In the above code, we added a single \texttt{@callback} attribute that defines the naive leader behaviour. For clarity, we defined a distinct type for the \texttt{event\_type} arguments.

As we now have a naive leader behaviour defined, we can use it to define a mock using the \texttt{Mox.defmock/2} function inside the \texttt{test\_helper.exs} file of the \texttt{naive} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\ConstantTok{Mox}\OperatorTok{.}\NormalTok{defmock}\FunctionTok{(}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{LeaderMock}\NormalTok{, }\KeywordTok{for}\NormalTok{: }\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

In the above code, we've told the \texttt{mox} package to define the \texttt{Test.Naive.LeaderMock} module based on the \texttt{Naive.Leader} behaviour.

We are moving on to the configuration. As the \texttt{Naive.Leader} wasn't part of the configuration, we need to add it to the default config and test config file.

First, let's add the \texttt{:leader} key inside the \texttt{config\ :naive} in the default \texttt{/config/config.exs} configuration file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\OperatorTok{...}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock}\NormalTok{,}
  \VariableTok{leader:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\NormalTok{,        }\CommentTok{\# \textless{}= added}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

and then we need to apply the same update to the \texttt{/config/test.exs} configuration file(it will point to the module generated by the \texttt{mox} package - \texttt{Test.Naive.LeaderMock}):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/test.exs}
\OperatorTok{...}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{BinanceMock}\NormalTok{,}
  \VariableTok{leader:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{LeaderMock}     \CommentTok{\# \textless{}= added}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

\subsection{\texorpdfstring{Mock the \texttt{Phoenix.PubSub} module}{Mock the Phoenix.PubSub module}}\label{mock-the-phoenix.pubsub-module}

Mocking the \texttt{Phoenix.PubSub} dependency inside the \texttt{Naive.Trader} module will look very similar to the last two mocked modules.

Inside the \texttt{Naive.Trader} module we need to update all the references to the \texttt{Phoenix.PubSub} to an \texttt{@pubsub\_client} attribute with value dependent on the configuration:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/trader.ex}
  \OperatorTok{...}
  \OtherTok{@pubsub\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:pubsub\_client}\FunctionTok{)}
  \OperatorTok{...}
    \OtherTok{@pubsub\_client}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}
  \OperatorTok{...}
    \OtherTok{@pubsub\_client}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"ORDERS:}\OtherTok{\#\{}\NormalTok{order}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      order}
    \FunctionTok{)}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The \texttt{Phoenix.PubSub} module doesn't provide a behaviour. As we can't modify its source, we need to create a new module to define the PubSub behaviour. Let's create a new file called \texttt{test.ex} inside the \texttt{/apps/core/lib/core} directory with the following behaviour definition:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/test.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Test} \KeywordTok{do}
  \KeywordTok{defmodule} \ConstantTok{PubSub} \KeywordTok{do}
    \OtherTok{@type}\NormalTok{ t :: atom}
    \OtherTok{@type}\NormalTok{ topic :: binary}
    \OtherTok{@type}\NormalTok{ message :: term}

    \OtherTok{@callback}\NormalTok{ subscribe}\FunctionTok{(}\NormalTok{t, topic}\FunctionTok{)}\NormalTok{ :: }\VariableTok{:ok} \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, term}\FunctionTok{\}}
    \OtherTok{@callback}\NormalTok{ broadcast}\FunctionTok{(}\NormalTok{t, topic, message}\FunctionTok{)}\NormalTok{ :: }\VariableTok{:ok} \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, term}\FunctionTok{\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As previously, we defined a couple of callbacks and additional types for each of their arguments.

\newpage

Next, we will use the above behaviour to define a mock using the \texttt{Mox.defmock/2} function inside the \texttt{test\_helper.exs} file of the \texttt{naive} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\ConstantTok{Mox}\OperatorTok{.}\NormalTok{defmock}\FunctionTok{(}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSubMock}\NormalTok{, }\KeywordTok{for}\NormalTok{: }\ConstantTok{Core}\OperatorTok{.}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSub}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

In the above code, we've told the \texttt{mox} package to define the \texttt{Test.PubSubMock} module based on the \texttt{Core.Test.PubSub} behaviour.

The final step will be to append the \texttt{:core,\ :pubsub\_client} configuration to the \texttt{/config/config.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:core}\NormalTok{,                  }\CommentTok{\# \textless{}= added}
  \VariableTok{pubsub\_client:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub} \CommentTok{\# \textless{}= added}
\end{Highlighting}
\end{Shaded}

and the test \texttt{/config/test.exs} configuration file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/test.exs}
\NormalTok{config }\VariableTok{:core}\NormalTok{,                  }\CommentTok{\# \textless{}= added}
  \VariableTok{pubsub\_client:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSubMock} \CommentTok{\# \textless{}= added}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Mock the \texttt{Logger} module}{Mock the Logger module}}\label{mock-the-logger-module}

Before we dive in, we should ask ourselves why we would mock the \texttt{Logger} module?

We could raise the logging level to \texttt{error} and be done with it. Yes, that would fix all debug/info/warning logs, but we would also miss an opportunity to confirm a few details (depends on what's necessary for our use case):

\begin{itemize}
\tightlist
\item
  you can ensure that the log was called when the tested function was run
\item
  you can pattern match the logging level
\item
  you can check the message. This could be useful if you don't want to put sensitive information like banking details etc. inside log messages
\end{itemize}

Mocking the \texttt{Logger} dependency inside the \texttt{Naive.Trader} module will follow the same steps as the previous updates.

Inside the \texttt{Naive.Trader} module we need to update all the references to the \texttt{Logger} to an \texttt{@logger} attribute with value dependent on the configuration:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/trader.ex}
  \OperatorTok{...}
  \OtherTok{@logger} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:logger}\FunctionTok{)}
  \OperatorTok{...}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Initializing new trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
  \OperatorTok{...}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"The trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) is placing a BUY order "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}
  \OperatorTok{...}
        \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
          \StringTok{"The trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) is placing a SELL order for "} \OperatorTok{\textless{}\textgreater{}}
            \StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{sell\_price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{."}
        \FunctionTok{)}
  \OperatorTok{...}
        \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ buy order got partially filled"}\FunctionTok{)}
  \OperatorTok{...}
      \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) finished trade cycle for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
  \OperatorTok{...}
      \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ SELL order got partially filled"}\FunctionTok{)}
  \OperatorTok{...}
      \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Rebuy triggered for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ by the trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{)"}\FunctionTok{)}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The \texttt{Logger} module doesn't provide a behaviour. As we can't modify its source, we need to create a new module to define the Logger behaviour. Let's place it inside the \texttt{Core.Test} namespace in the \texttt{/apps/core/lib/core/test.ex} file side by side with the PubSub behaviour with the following definition:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/test.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Test} \KeywordTok{do}
  \OperatorTok{...}
  \KeywordTok{defmodule} \ConstantTok{Logger} \KeywordTok{do}
    \OtherTok{@type}\NormalTok{ message :: binary}

    \OtherTok{@callback}\NormalTok{ info}\FunctionTok{(}\NormalTok{message}\FunctionTok{)}\NormalTok{ :: }\VariableTok{:ok}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As previously, we defined a callback and additional type for the \texttt{message} argument.

Next, we will use the above behaviour to define a mock using the \texttt{Mox.defmock/2} function inside the \texttt{test\_helper.exs} file of the \texttt{naive} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\ConstantTok{Mox}\OperatorTok{.}\NormalTok{defmock}\FunctionTok{(}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{LoggerMock}\NormalTok{, }\KeywordTok{for}\NormalTok{: }\ConstantTok{Core}\OperatorTok{.}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{Logger}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

In the above code, we've told the \texttt{mox} package to define the \texttt{Test.LoggerMock} module based on the \texttt{Core.Test.Logger} behaviour.

\newpage

The final step will be to append the \texttt{:core,\ :logger} configuration to the \texttt{/config/config.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:core}\NormalTok{,                                   }
  \VariableTok{logger:} \ConstantTok{Logger}\NormalTok{,                }\CommentTok{\# \textless{}= added}
  \VariableTok{pubsub\_client:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}
\end{Highlighting}
\end{Shaded}

and the test \texttt{/config/test.exs} configuration file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/test.exs}
\NormalTok{config }\VariableTok{:core}\NormalTok{,                                   }
  \VariableTok{logger:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{LoggerMock}\NormalTok{,        }\CommentTok{\# \textless{}= added}
  \VariableTok{pubsub\_client:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSubMock}
\end{Highlighting}
\end{Shaded}

This finishes the updates to the \texttt{Naive.Trader} module. We made all dependencies based on the configuration values. We can now progress to writing the test.

\section{\texorpdfstring{Implement a test of the \texttt{Naive.Trader} module}{Implement a test of the Naive.Trader module}}\label{implement-a-test-of-the-naive.trader-module}

Finally, we can implement the unit test for the \texttt{Naive.Trader} module.

We will create a folder called \texttt{naive} inside the \texttt{/apps/naive/test} directory and a new file called \texttt{trader\_test.exs} inside it.

Let's start with an empty skeleton of the test tagged as \texttt{unit}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/trader\_test.exs}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{TraderTest} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{ExUnit}\OperatorTok{.}\ConstantTok{Case}
\NormalTok{  doctest }\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Placing buy order test"} \KeywordTok{do}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Let's add the \texttt{mox} related code above the \texttt{@tag\ :unit} line:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/trader\_test.exs}
  \ImportTok{import} \ConstantTok{Mox}                   \CommentTok{\# \textless{}= 1 }

\NormalTok{  setup }\VariableTok{:set\_mox\_from\_context}  \CommentTok{\# \textless{}= 2}
\NormalTok{  setup }\VariableTok{:verify\_on\_exit!}       \CommentTok{\# \textless{}= 3}
\end{Highlighting}
\end{Shaded}

\newpage

In the above code, we are:

\begin{itemize}
\tightlist
\item
  importing the \texttt{mox} module so we will be able to use functions like \texttt{expect/3}
\item
  allowing any process to consume mocks defined by the test. This is crucial as tests are run as separate processes that would normally be the only ones allowed to use mocks that they define. Inside our test, we will start a new \texttt{Naive.Trader} process that needs to be able to access mocks defined in the test - hence this update
\item
  telling \texttt{mox} to verify that all the mocks defined in the tests have been called from within those tests. Otherwise, it will flag such cases as test errors
\end{itemize}

Inside our test, we need to define implementation for all the functions that the \texttt{Naive.Trader} relies on:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/trader\_test.exs}
  \OperatorTok{...}
\NormalTok{  test }\StringTok{"Placing buy order test"} \KeywordTok{do}
    \ConstantTok{Test}\OperatorTok{.}\ConstantTok{PubSubMock}
    \OperatorTok{|\textgreater{}}\NormalTok{ expect}\FunctionTok{(}\VariableTok{:subscribe}\NormalTok{, }\KeywordTok{fn}\NormalTok{ \_module, }\StringTok{"TRADE\_EVENTS:XRPUSDT"} \OperatorTok{{-}\textgreater{}} \VariableTok{:ok} \KeywordTok{end}\FunctionTok{)} \CommentTok{\# \textless{}= 1}
    \OperatorTok{|\textgreater{}}\NormalTok{ expect}\FunctionTok{(}\VariableTok{:broadcast}\NormalTok{, }\KeywordTok{fn}\NormalTok{ \_module, }\StringTok{"ORDERS:XRPUSDT"}\NormalTok{, \_order }\OperatorTok{{-}\textgreater{}} \VariableTok{:ok} \KeywordTok{end}\FunctionTok{)}

    \ConstantTok{Test}\OperatorTok{.}\ConstantTok{BinanceMock}
    \OperatorTok{|\textgreater{}}\NormalTok{ expect}\FunctionTok{(}\VariableTok{:order\_limit\_buy}\NormalTok{, }\KeywordTok{fn} \StringTok{"XRPUSDT"}\NormalTok{, }\StringTok{"464.360"}\NormalTok{, }\StringTok{"0.4307"}\NormalTok{, }\StringTok{"GTC"} \OperatorTok{{-}\textgreater{}} \CommentTok{\# \textless{}= 2}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{,}
       \ConstantTok{BinanceMock}\OperatorTok{.}\NormalTok{generate\_fake\_order}\FunctionTok{(}
         \StringTok{"XRPUSDT"}\NormalTok{,}
         \StringTok{"464.360"}\NormalTok{,}
         \StringTok{"0.4307"}\NormalTok{,}
         \StringTok{"BUY"}
       \FunctionTok{)}
       \OperatorTok{|\textgreater{}} \ConstantTok{BinanceMock}\OperatorTok{.}\NormalTok{convert\_order\_to\_order\_response}\FunctionTok{()\}}
    \KeywordTok{end}\FunctionTok{)}

\NormalTok{    test\_pid }\OperatorTok{=}\NormalTok{ self}\FunctionTok{()} \CommentTok{\# \textless{}= 3}

    \ConstantTok{Test}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{LeaderMock}
    \OperatorTok{|\textgreater{}}\NormalTok{ expect}\FunctionTok{(}\VariableTok{:notify}\NormalTok{, }\KeywordTok{fn} \VariableTok{:trader\_state\_updated}\NormalTok{, \%}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{{-}\textgreater{}}
\NormalTok{      send}\FunctionTok{(}\NormalTok{test\_pid, }\VariableTok{:ok}\FunctionTok{)} \CommentTok{\# \textless{}= 3}
      \VariableTok{:ok}
    \KeywordTok{end}\FunctionTok{)}

    \ConstantTok{Test}\OperatorTok{.}\ConstantTok{LoggerMock}
    \OperatorTok{|\textgreater{}}\NormalTok{ expect}\FunctionTok{(}\VariableTok{:info}\NormalTok{, }\DecValTok{2}\NormalTok{, }\KeywordTok{fn}\NormalTok{ \_message }\OperatorTok{{-}\textgreater{}} \VariableTok{:ok} \KeywordTok{end}\FunctionTok{)} \CommentTok{\# \textless{}= 4}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

It's important to note that we defined the mocked function with expected values in the above code. We expect our test to subscribe to a specific topic and broadcast to the other(\#1). We are also expecting that process will place an order at the exact values that we calculated upfront. This way, our mock becomes an integral part of the test, asserting that the correct values will be passed to other parts of the system(dependencies of the \texttt{Naive.Trader} module).

Another ``trick''(\#3) that we can use in our mocks is to leverage the fact that we can send a message to the test process from within the mocked function. We will leverage this idea to know precisely when the trader process finished its work as the \texttt{notify/1} is the last function call inside the process' callback(\texttt{handle\_info/2} inside the \texttt{Naive.Trader} module). We will assert that we should receive the message, and the test will be waiting for it before exiting(the default timeout is 100ms) instead of using hardcoded \texttt{sleep} to ``hack'' it to work.

The final part(\#4) tells the \texttt{mox} package that \texttt{Logger.info/1} will be called twice inside the test. The \texttt{mox} will verify the number of calls to the mocked function and error if it doesn't much the expected amount.

The second part of the test is preparing the initial state for the \texttt{Naive.Trader} process, generating trade event and sending it to the process:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/trader\_test.exs}
  \OperatorTok{...}
\NormalTok{  test }\StringTok{"Placing buy order test"} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    trader\_state }\OperatorTok{=}\NormalTok{ dummy\_trader\_state}\FunctionTok{()}
\NormalTok{    trade\_event }\OperatorTok{=}\NormalTok{ generate\_event}\FunctionTok{(}\DecValTok{1}\NormalTok{, }\StringTok{"0.43183010"}\NormalTok{, }\StringTok{"213.10000000"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, trader\_pid}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\NormalTok{trader\_state}\FunctionTok{)}
\NormalTok{    send}\FunctionTok{(}\NormalTok{trader\_pid, trade\_event}\FunctionTok{)}
\NormalTok{    assert\_receive }\VariableTok{:ok}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As described above, the \texttt{assert\_receive/1} function will cause the test to wait for the message for 100ms before quitting.

Here are the helper functions that we used to generate the initial trader state and trade event:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/trader\_test.exs}
  \OperatorTok{...}
\NormalTok{  test }\StringTok{"Placing buy order test"} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ dummy\_trader\_state}\FunctionTok{()} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}\FunctionTok{\{}
      \VariableTok{id:} \DecValTok{100\_000\_000}\NormalTok{,}
      \VariableTok{symbol:} \StringTok{"XRPUSDT"}\NormalTok{,}
      \VariableTok{budget:} \StringTok{"200"}\NormalTok{,}
      \VariableTok{buy\_order:} \ConstantTok{nil}\NormalTok{,}
      \VariableTok{sell\_order:} \ConstantTok{nil}\NormalTok{,}
      \VariableTok{buy\_down\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\StringTok{"0.0025"}\FunctionTok{)}\NormalTok{,}
      \VariableTok{profit\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\StringTok{"0.001"}\FunctionTok{)}\NormalTok{,}
      \VariableTok{rebuy\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\StringTok{"0.006"}\FunctionTok{)}\NormalTok{,}
      \VariableTok{rebuy\_notified:} \ConstantTok{false}\NormalTok{,}
      \VariableTok{tick\_size:} \StringTok{"0.0001"}\NormalTok{,}
      \VariableTok{step\_size:} \StringTok{"0.001"}
    \FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ generate\_event}\FunctionTok{(}\NormalTok{id, price, quantity}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{Core}\OperatorTok{.}\ConstantTok{Struct}\OperatorTok{.}\ConstantTok{TradeEvent}\FunctionTok{\{}
      \VariableTok{event\_type:} \StringTok{"trade"}\NormalTok{,}
      \VariableTok{event\_time:} \DecValTok{1\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{symbol:} \StringTok{"XRPUSDT"}\NormalTok{,}
      \VariableTok{trade\_id:} \DecValTok{2\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{price:}\NormalTok{ price,}
      \VariableTok{quantity:}\NormalTok{ quantity,}
      \VariableTok{buyer\_order\_id:} \DecValTok{3\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{seller\_order\_id:} \DecValTok{4\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{trade\_time:} \DecValTok{5\_000} \OperatorTok{+}\NormalTok{ id }\OperatorTok{*} \DecValTok{10}\NormalTok{,}
      \VariableTok{buyer\_market\_maker:} \ConstantTok{false}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above code finishes the implementation of the test, but inside it, we used functions from the \texttt{BinanceMock} module that are private. We need to update the module by making the \texttt{generate\_fake\_order/4} and\\
\texttt{convert\_order\_to\_order\_response/1} function public(and moving them up in the module, so they are next to other public functions):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ get\_order}\FunctionTok{(}\NormalTok{symbol, time, order\_id}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ generate\_fake\_order}\FunctionTok{(}\NormalTok{symbol, quantity, price, side}\FunctionTok{)} \CommentTok{\# \textless{}= updated to public}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ convert\_order\_to\_order\_response}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= updated to public}
    \OperatorTok{...}
  \KeywordTok{end}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We updated both of the methods to public and moved them up after the \texttt{get\_order/3} function.

\section{Define an alias to run unit tests}\label{define-an-alias-to-run-unit-tests}

Our unit test should be run without running the whole application, so we need to run them with the \texttt{-\/-no-start} argument. We should also select unit tests by tag(\texttt{-\/-only\ unit}). Let's create an alias that will hide those details:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /mix.exs}
  \KeywordTok{defp}\NormalTok{ aliases }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \StringTok{"test.unit"}\NormalTok{: }\OtherTok{[}
        \StringTok{"test {-}{-}only unit {-}{-}no{-}start"}
      \OtherTok{]}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now run our test using a terminal:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{MIX\_ENV}\OperatorTok{=}\NormalTok{test }\ExtensionTok{mix}\NormalTok{ test.unit}
\end{Highlighting}
\end{Shaded}

We should see the following error:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{21:22:03.811} \PreprocessorTok{[}\SpecialStringTok{error}\PreprocessorTok{]}\NormalTok{ GenServer }\CommentTok{\#PID\textless{}0.641.0\textgreater{} terminating}
\ExtensionTok{**} \ErrorTok{(}\ExtensionTok{stop}\KeywordTok{)} \ExtensionTok{exited}\NormalTok{ in: GenServer.call}\ErrorTok{(}\ExtensionTok{BinanceMock,}\NormalTok{ :generate\_id, 5000}\KeywordTok{)}
    \ExtensionTok{**} \ErrorTok{(}\ExtensionTok{EXIT}\KeywordTok{)} \ExtensionTok{no}\NormalTok{ process: the process is not alive or there}\StringTok{\textquotesingle{}s no process currently}
\StringTok{       associated with the given name, possibly because its application isn\textquotesingle{}}\NormalTok{t started}
\end{Highlighting}
\end{Shaded}

One of the \texttt{BinanceMock} module's functions is sending a message to generate a unique id to the process that doesn't exist(as we are running our tests without starting the supervision tree{[}the \texttt{-\/-no-start} argument{]}).

There are two ways to handle this issue:

\begin{itemize}
\tightlist
\item
  inside the \texttt{/apps/naive/test/test\_helper.exs} file we could ensure that the \texttt{BinanceMock} is up and running by adding \texttt{Application.ensure\_all\_started(:binance\_mock)} function call - this is a hack
\item
  we could refactor the \texttt{BinanceMock.generate\_fake\_order/4} to accept \texttt{order\_id} as an argument instead of sending the message internally - this should be a much better solution. Let's give it a shot.
\end{itemize}

First, let's update the \texttt{BinanceMock} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ generate\_fake\_order}\FunctionTok{(}\NormalTok{order\_id, symbol, quantity, price, side}\FunctionTok{)} \CommentTok{\# \textless{}= order\_id added}
    \OperatorTok{...}
    \CommentTok{\# remove the call to GenServer from the body}
    \OperatorTok{...}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ order\_limit}\FunctionTok{(}\NormalTok{symbol, quantity, price, side}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{      generate\_fake\_order}\FunctionTok{(}
        \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{call}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, }\VariableTok{:generate\_id}\FunctionTok{)}\NormalTok{, }\CommentTok{\# \textless{}= order\_id generation added}
\NormalTok{        symbol,}
\NormalTok{        quantity,}
\NormalTok{        price,}
\NormalTok{        side}
      \FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Now we need to update our test to pass some dummy order id from the mocked function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/trader\_test.exs}
  \OperatorTok{...}
\NormalTok{  test }\StringTok{"Placing buy order test"} \KeywordTok{do}
    \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\ConstantTok{BinanceMock}\OperatorTok{.}\NormalTok{generate\_fake\_order}\FunctionTok{(}
        \StringTok{"12345"}\NormalTok{,                        }\CommentTok{\# \textless{}= order\_id added}
        \StringTok{"XRPUSDT"}\NormalTok{,}
        \StringTok{"464.360"}\NormalTok{,}
        \StringTok{"0.4307"}\NormalTok{,}
        \StringTok{"BUY"}
      \FunctionTok{)}
   \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now rerun our test:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{MIX\_ENV}\OperatorTok{=}\NormalTok{test }\ExtensionTok{mix}\NormalTok{ test.unit}
\ExtensionTok{...}
\ExtensionTok{Finished}\NormalTok{ in 0.1 seconds }\ErrorTok{(}\ExtensionTok{0.00s}\NormalTok{ async, 0.1s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

Congrats! We just successfully tested placing an order without any dependencies. To avoid explicitly passing the \texttt{MIX\_ENV=test} environment variable, we will add the preferred environment for our alias inside the \texttt{mix.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /mix.exs}
  \KeywordTok{def}\NormalTok{ project }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \VariableTok{preferred\_cli\_env:} \OtherTok{[}
        \StringTok{"test.unit"}\NormalTok{: }\VariableTok{:test}
      \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we can run our tests by:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{mix}\NormalTok{ test.unit}
\ExtensionTok{...}
\ExtensionTok{Finished}\NormalTok{ in 0.06 seconds }\ErrorTok{(}\ExtensionTok{0.00s}\NormalTok{ async, 0.06s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

That's all for this chapter - to sum up, the main advantages from the \texttt{mox} based tests:

\begin{itemize}
\tightlist
\item
  we were able to test a standalone process/module ignoring all of its dependencies
\item
  we were able to confirm that dependent functions were called and expected values were passed to them
\item
  we were able to create a feedback loop where mock was sending a message back to the test, because of which, we didn't need to use \texttt{sleep}, and that resulted in a massive speed gains
\end{itemize}

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_17}{GitHub}

\chapter{Functional Elixir}\label{functional-elixir}

\section{Objectives}\label{objectives-17}

\begin{itemize}
\tightlist
\item
  the reasoning behind the functional approach
\item
  simplifying by splitting
\item
  abstracting the ``pure'' logic
\item
  dealing with dirty code
\item
  making dirty code testable
\item
  the power \texttt{with}-in
\item
  do or not to do
\item
  final thoughts
\end{itemize}

\section{The reasoning behind the functional approach}\label{the-reasoning-behind-the-functional-approach}

Across the last 17 chapters, we focused on learning OTP by building a trading system. On the way, we omitted (for a very good reason - a clear focus on OTP) the conversation about functional programming.

But wait, what? We are already using concepts like higher-order functions - isn't that enough?

We indeed use some functional patterns, but we never dug deeper into what Elixir developers \textbf{should} know(and apply) and, most importantly, \textbf{why}.

In a nutshell, the selling point of functional programming is that applying it will make your code easier to reason about and test. Tests dramatically improve software quality. The easier they are to write, there's less excuse not to write them - as simple as that.

We will start from the basics and look into different ways of implementing functional concepts, considering Elixir's strengths and weaknesses.

\section{Simplifying by splitting}\label{simplifying-by-splitting}

Note: This section could appear to be a bit ``random'', but I added it to aid continuity of refactoring steps(refactoring those callbacks later would cause a fair amount of complexity).

Let's look at our strategy inside the \texttt{Naive.Trader} module. In this section, we will focus on its (\texttt{handle\_info/2}) callback function.

We are looking for clauses that do more than ``one thing'' to split them into multiple clauses:

\begin{itemize}
\tightlist
\item
  The first callback places a buy order - it has a single responsibility and is easy to follow.
\item
  The second callback takes care of race conditions - the same story, easy to understand.
\item
  The third callback is the one we will focus on. It branches using the \texttt{if} statement, and we could describe it as ``fetch and maybe place a sell order'' function. The ``and'' in the description clearly indicates that it's really two functions glued together. We will split it into ``fetch buy order'' and ``place a sell order'' functions(below code replaces the 3rd \texttt{handle\_info/2} callback):
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{price:}\NormalTok{ buy\_price,}
            \VariableTok{orig\_qty:}\NormalTok{ quantity,}
            \VariableTok{status:} \StringTok{"FILLED"}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{sell\_order:} \ConstantTok{nil}\NormalTok{,}
          \VariableTok{profit\_interval:}\NormalTok{ profit\_interval,}
          \VariableTok{tick\_size:}\NormalTok{ tick\_size}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    sell\_price }\OperatorTok{=}\NormalTok{ calculate\_sell\_price}\FunctionTok{(}\NormalTok{buy\_price, profit\_interval, tick\_size}\FunctionTok{)}

    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"The trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) is placing a SELL order for "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{sell\_price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{."}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, sell\_price, }\StringTok{"GTC"}\FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{order}\FunctionTok{)}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{sell\_order:}\NormalTok{ order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{buyer\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{buy\_order:}
\NormalTok{            \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
              \VariableTok{order\_id:}\NormalTok{ order\_id,}
              \VariableTok{transact\_time:}\NormalTok{ timestamp}
            \FunctionTok{\}} \OperatorTok{=}\NormalTok{ buy\_order}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ buy order got partially filled"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_buy\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{current\_buy\_order}\FunctionTok{)}

\NormalTok{    buy\_order }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{buy\_order }\OperatorTok{|} \VariableTok{status:}\NormalTok{ current\_buy\_order}\OperatorTok{.}\NormalTok{status}\FunctionTok{\}}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ buy\_order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The first function takes care of placing a sell order. The second one fetches the buy order.

\begin{itemize}
\tightlist
\item
  We can now move to the next clause, similar to the last one we could describe as ``fetch the sell order and maybe terminate the trader''. We will split it into two callbacks: ``fetch the sell order'' and ``terminate trader''.
\end{itemize}

\newpage

The code below replaces the 5th \texttt{handle\_info/2} callback:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{status:} \StringTok{"FILLED"}
          \FunctionTok{\}}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) finished trade cycle for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:stop}\NormalTok{, }\VariableTok{:normal}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{seller\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \VariableTok{symbol:}\NormalTok{ symbol,}
          \VariableTok{sell\_order:}
\NormalTok{            \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
              \VariableTok{order\_id:}\NormalTok{ order\_id,}
              \VariableTok{transact\_time:}\NormalTok{ timestamp}
            \FunctionTok{\}} \OperatorTok{=}\NormalTok{ sell\_order}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
      \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ SELL order got partially filled"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_sell\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{current\_sell\_order}\FunctionTok{)}

\NormalTok{    sell\_order }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{sell\_order }\OperatorTok{|} \VariableTok{status:}\NormalTok{ current\_sell\_order}\OperatorTok{.}\NormalTok{status}\FunctionTok{\}}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{sell\_order:}\NormalTok{ sell\_order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The first function takes care of terminating the trader. The second function is fetching the sell order.

That finishes our first refactoring round, but I need to admit that our change has impacted the behaviour of our strategy. Each time a buy or sell order gets filled, we will fetch that order from Binance, but we \textbf{won't} immediately place a sell order nor terminate as it was happening before. Instead, only when another event arrives will the trader place a sell order or terminate.

Changes like this require approval from the business in a work situation, but it's a good showcase of the situation where we can propose a solution that will simplify the code(the benefits will become evident in the following sections).

We can confirm that we have broken our tests by running our integration testsuite:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ MIX\_ENV=integration mix test.integration}
\ExtensionTok{...}
  \ExtensionTok{1}\ErrorTok{)} \BuiltInTok{test}\NormalTok{ Naive trader full trade}\ErrorTok{(}\ExtensionTok{buy}\NormalTok{ + sell}\KeywordTok{)} \BuiltInTok{test} \ErrorTok{(}\ExtensionTok{NaiveTest}\KeywordTok{)}
     \ExtensionTok{apps/naive/test/naive\_test.exs:12}
     \ExtensionTok{**} \ErrorTok{(}\ExtensionTok{MatchError}\KeywordTok{)} \ExtensionTok{no}\NormalTok{ match of right hand side value: [[}\StringTok{"0.43070000"}\NormalTok{, }\StringTok{"BUY"}\NormalTok{, }\StringTok{"FILLED"}\NormalTok{]...}
     \ExtensionTok{code:}\NormalTok{ [buy\_1, sell\_1, buy\_2] = DataWarehouse.Repo.all}\ErrorTok{(}\ExtensionTok{query}\KeywordTok{)}
     \ExtensionTok{stacktrace:}
       \ExtensionTok{test/naive\_test.exs:83:} \ErrorTok{(}\BuiltInTok{test}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

(Subject to acceptance by the business) we will fix the integration test in the following way:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive\_test.exs}
\NormalTok{  test }\StringTok{"Naive trader full trade(buy + sell) test"} \KeywordTok{do}
    \OperatorTok{...}
    \CommentTok{\# Step 4 {-} Broadcast 10 events \# \textless{}= updated comment}
    \OtherTok{[}
       \OperatorTok{...}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{8}\NormalTok{, }\StringTok{"0.43205"}\NormalTok{, }\StringTok{"345.14235000"}\FunctionTok{)}\NormalTok{,}
      \CommentTok{\# this one should trigger buy order for a new trader process}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{9}\NormalTok{, }\StringTok{"0.43205"}\NormalTok{, }\StringTok{"345.14235000"}\FunctionTok{)}\NormalTok{, }\CommentTok{\# \textless{}= added line}
\NormalTok{      generate\_event}\FunctionTok{(}\DecValTok{10}\NormalTok{, }\StringTok{"0.43210"}\NormalTok{, }\StringTok{"3201.86480000"}\FunctionTok{)} \CommentTok{\# \textless{}= updated id}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

We added an event at the same price(as the sell order's price) that will trigger placing a buy order by the new trader and make our test green again.

\newpage

\section{Abstracting the ``pure'' logic}\label{abstracting-the-pure-logic}

In our adventure to make our code more functional, we should strive to separate(as much as possible) pure business logic from side effects and boilerplate.

The \texttt{Naive.Trader} module is a GenServer that receives trade events via messages. Based on them and the current state, using pattern-matching, it decides what action should be performed(place a buy order, fetch a buy order, place a sell order, fetch sell order, terminate trader, trigger rebuy or ignore event).

Each of the pattern-matches inside the callback functions' headers is a \textbf{strategy} specific business logic that got mixed with the fact that it's executed by a GenServer that receives messages.

We will create a new file called \texttt{strategy.exs} inside the \texttt{apps/naive/lib/naive/} directory, where we will \textbf{copy} all of the \texttt{handle\_info/2} callback functions from the \texttt{Naive.Trader} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy} \KeywordTok{do}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= place a buy order logic}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= race condition fix logic}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= place a sell order logic}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= fetch the buy order logic}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= terminate trader logic}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= fetch the sell order logic}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= trigger rebuy order logic}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...} \CommentTok{\# \textless{}= ignore trade event logic}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

First, we will rename all of the \texttt{handle\_info/2} functions inside the \texttt{Naive.Strategy} module to \texttt{generate\_decision/2}. Next, we will go through them one by one, leaving the pure parts and limiting them to returning the decision.

\subsection{Place a buy order rules}\label{place-a-buy-order-rules}

The first function decides should the trader place a buy order. We can see that price and quantity calculations are pure functions based on the incoming data. We will remove everything below those two as it's causing side effects.

As now we are dealing with a function generating a decision, we will return a tuple with data that, together with state, will be used to place a buy order.

After removing some of the pattern-matching that we used to retrieve data(no longer needed), our first function should look like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the first clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}\VariableTok{price:}\NormalTok{ price}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{budget:}\NormalTok{ budget,}
          \VariableTok{buy\_order:} \ConstantTok{nil}\NormalTok{,}
          \VariableTok{buy\_down\_interval:}\NormalTok{ buy\_down\_interval,}
          \VariableTok{tick\_size:}\NormalTok{ tick\_size,}
          \VariableTok{step\_size:}\NormalTok{ step\_size}
        \FunctionTok{\}}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    price }\OperatorTok{=}\NormalTok{ calculate\_buy\_price}\FunctionTok{(}\NormalTok{price, buy\_down\_interval, tick\_size}\FunctionTok{)}

\NormalTok{    quantity }\OperatorTok{=}\NormalTok{ calculate\_quantity}\FunctionTok{(}\NormalTok{budget, price, step\_size}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:place\_buy\_order}\NormalTok{, price, quantity}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

\subsection{Race condition rules}\label{race-condition-rules}

The second function deals with the race condition when multiple transactions fill the buy order. The original callback ignores those trade events, so the \texttt{generate\_decision/2} function should return the same ``decision'':

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the second clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{buyer\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{order\_id:}\NormalTok{ order\_id,}
            \VariableTok{status:} \StringTok{"FILLED"}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}}
        \FunctionTok{\}}
      \FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_number}\FunctionTok{(}\NormalTok{order\_id}\FunctionTok{)} \KeywordTok{do}
    \VariableTok{:skip}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Fetch the buy order rules}\label{fetch-the-buy-order-rules}

For the 3th clause, we will return only an atom as there's no pure logic besides the pattern-match in the header itself:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the third clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{buyer\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{order\_id:}\NormalTok{ order\_id}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{sell\_order:} \ConstantTok{nil}
        \FunctionTok{\}}
      \FunctionTok{)}
      \KeywordTok{when}\NormalTok{ is\_number}\FunctionTok{(}\NormalTok{order\_id}\FunctionTok{)} \KeywordTok{do}
    \VariableTok{:fetch\_buy\_order}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Place a sell order rules}\label{place-a-sell-order-rules}

We will follow the same logic for the 4th clause of the \texttt{generate\_decision/2} function. We will leave only the sell price calculation as it's pure and return a tuple together with the decision:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the fourth clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{status:} \StringTok{"FILLED"}\NormalTok{,}
            \VariableTok{price:}\NormalTok{ buy\_price}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{sell\_order:} \ConstantTok{nil}\NormalTok{,}
          \VariableTok{profit\_interval:}\NormalTok{ profit\_interval,}
          \VariableTok{tick\_size:}\NormalTok{ tick\_size}
        \FunctionTok{\}}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    sell\_price }\OperatorTok{=}\NormalTok{ calculate\_sell\_price}\FunctionTok{(}\NormalTok{buy\_price, profit\_interval, tick\_size}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:place\_sell\_order}\NormalTok{, sell\_price}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Terminate trader rules}\label{terminate-trader-rules}

For the 5th clause, we will indicate that trader needs to terminate:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the fifth clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{status:} \StringTok{"FILLED"}
          \FunctionTok{\}}
        \FunctionTok{\}}
      \FunctionTok{)} \KeywordTok{do}
    \VariableTok{:exit}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Fetch the sell order rules}\label{fetch-the-sell-order-rules}

For the 6th clause, we will indicate that trader needs to fetch the sell order:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the sixth clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{seller\_order\_id:}\NormalTok{ order\_id}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{order\_id:}\NormalTok{ order\_id}
          \FunctionTok{\}}
        \FunctionTok{\}}
      \FunctionTok{)} \KeywordTok{do}
    \VariableTok{:fetch\_sell\_order}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Trigger rebuy rules}\label{trigger-rebuy-rules}

Inside the 7th clause, we are dealing with triggering the rebuy. Here, we can decide whether rebuy should be triggered and get rid of conditional logic inside further steps. We couldn't refactor this function by splitting it (as we've done in the first section) as we need to call the \texttt{trigger\_rebuy?/3} function to check should rebuy be triggered. The functions that we refactored in the first section of this chapter were splittable as they relied on pattern-matching in the function headers where calling local functions is not allowed):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the seventh clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{price:}\NormalTok{ current\_price}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{price:}\NormalTok{ buy\_price}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{rebuy\_interval:}\NormalTok{ rebuy\_interval,}
          \VariableTok{rebuy\_notified:} \ConstantTok{false}
        \FunctionTok{\}}
      \FunctionTok{)} \KeywordTok{do}
    \ControlFlowTok{if}\NormalTok{ trigger\_rebuy?}\FunctionTok{(}\NormalTok{buy\_price, current\_price, rebuy\_interval}\FunctionTok{)} \KeywordTok{do}
      \VariableTok{:rebuy}
    \ControlFlowTok{else}
      \VariableTok{:skip}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

\subsection{The final clause rules}\label{the-final-clause-rules}

The final (8th) clause will just ignore the trade event as it's of no interest:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# the final(8th) clause}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{, \%}\ConstantTok{State}\FunctionTok{\{\})} \KeywordTok{do}
    \VariableTok{:skip}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This finishes the changes to the \texttt{generate\_decision/2} clauses. We extracted a fair amount of logic into an easily testable pure function. We now need to use it inside the \texttt{Naive.Trader} module.

\subsection{\texorpdfstring{Changes to the \texttt{Naive.Trader} module}{Changes to the Naive.Trader module}}\label{changes-to-the-naive.trader-module}

We will start by moving all of the calculation functions to the \texttt{Naive.Strategy} module as we are using them from the \texttt{generate\_decision/2} function. Those will be:

\begin{itemize}
\tightlist
\item
  \texttt{calculate\_sell\_price/3}
\item
  \texttt{calculate\_buy\_price/3}
\item
  \texttt{calculate\_quantity/3}
\item
  \texttt{trigger\_rebuy?/3}
\end{itemize}

They can now be changed to public functions as they are pure and fit the ``interface'' of the \texttt{Naive.Strategy} module(it feels ok{[}and it's safe as they are pure{]} to ``expose'' them to be called from other modules).

We need to remember about moving the \texttt{Decimal} alias into the \texttt{Naive.Strategy} module together with a copy of the \texttt{TradeEvent} struct alias and add the alias for the \texttt{Naive.Trader.State} struct:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \ImportTok{alias} \ConstantTok{Decimal}\NormalTok{, }\VariableTok{as:}\NormalTok{ D}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Struct}\OperatorTok{.}\ConstantTok{TradeEvent}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}\OperatorTok{.}\ConstantTok{State}
\end{Highlighting}
\end{Shaded}

The next step will be to rename all the \texttt{handle\_info/2} callback functions inside the \texttt{Naive.Trader} module to \texttt{execute\_decision/2}, which we will get back to in a moment.

First, we need to add a single \texttt{handle\_info/2} callback under the \texttt{init/1} function that will pattern match only the fact that the received message contains the \texttt{TradeEvent} struct and the state is the correct \texttt{State} struct:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
\CommentTok{\# add after the \textasciigrave{}init/1\textasciigrave{} function}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, \%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}\NormalTok{trade\_event, state}\FunctionTok{)}
    \OperatorTok{|\textgreater{}}\NormalTok{ execute\_decision}\FunctionTok{(}\NormalTok{state}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

So, the \texttt{Naive.Strategy} module will decide what the trader server should do based on its pure business logic. That decision will be passed forward with the state to the \texttt{execute\_decision/2} function (at this moment, it's just the old \texttt{handle\_info/2} function renamed, but we will update it next).

\subsection{\texorpdfstring{\texttt{Naive.Trader} - place buy order}{Naive.Trader - place buy order}}\label{naive.trader---place-buy-order}

We will update the \texttt{execute\_decision/2} function to take a decision + state and execute the correct action based on pattern-match of the decision. Starting with the 1st clause, we need to pattern match a tuple:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
\CommentTok{\# the first execute clause}
  \KeywordTok{def}\NormalTok{ execute\_decision}\FunctionTok{(}
         \FunctionTok{\{}\VariableTok{:place\_buy\_order}\NormalTok{, price, quantity}\FunctionTok{\}}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{State}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol}
         \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"The trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) is placing a BUY order "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"GTC"}\FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{order}\FunctionTok{)}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The amount of pattern matching will be much smaller as part of the original callback has been moved inside the \texttt{Naive.Strategy}'s logic(to calculate the price and quantity).

\subsection{\texorpdfstring{\texttt{Naive.Trader} - Race condition clause}{Naive.Trader - Race condition clause}}\label{naive.trader---race-condition-clause}

As we are using the \texttt{:skip} ``decision'' for both the race condition events and the ``non interesting'' events, we can safely remove this clause as we will implement skipping as the last clause.

\subsection{\texorpdfstring{\texttt{Naive.Trader} - Place a sell order}{Naive.Trader - Place a sell order}}\label{naive.trader---place-a-sell-order}

In case of placing a sell order, we will pattern match on a tuple containing the \texttt{:place\_sell\_order} atom and slim down on pattern matching:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ execute\_decision}\FunctionTok{(}
         \FunctionTok{\{}\VariableTok{:place\_sell\_order}\NormalTok{, sell\_price}\FunctionTok{\}}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{State}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol,}
           \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
             \VariableTok{orig\_qty:}\NormalTok{ quantity}
           \FunctionTok{\}}
         \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"The trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) is placing a SELL order for "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ @ }\OtherTok{\#\{}\NormalTok{sell\_price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{."}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, sell\_price, }\StringTok{"GTC"}\FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{order}\FunctionTok{)}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{sell\_order:}\NormalTok{ order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{Naive.Trader} - Fetch the buy order}{Naive.Trader - Fetch the buy order}}\label{naive.trader---fetch-the-buy-order}

In case of fetching the buy order, we will pattern match on a \texttt{:fetch\_buy\_order} atom and slim down on pattern matching:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:fetch\_buy\_order}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{State}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol,}
           \VariableTok{buy\_order:}
\NormalTok{             \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
               \VariableTok{order\_id:}\NormalTok{ order\_id,}
               \VariableTok{transact\_time:}\NormalTok{ timestamp}
             \FunctionTok{\}} \OperatorTok{=}\NormalTok{ buy\_order}
         \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ buy order got partially filled"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_buy\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{current\_buy\_order}\FunctionTok{)}

\NormalTok{    buy\_order }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{buy\_order }\OperatorTok{|} \VariableTok{status:}\NormalTok{ current\_buy\_order}\OperatorTok{.}\NormalTok{status}\FunctionTok{\}}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ buy\_order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{Naive.Trader} - Terminate the trader}{Naive.Trader - Terminate the trader}}\label{naive.trader---terminate-the-trader}

In case of terminating the trader, we will pattern match on a \texttt{:exit} atom and slim down on pattern matching:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:exit}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{State}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol}
         \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{) finished trade cycle for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:stop}\NormalTok{, }\VariableTok{:normal}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

\subsection{\texorpdfstring{\texttt{Naive.Trader} - Fetch the sell order}{Naive.Trader - Fetch the sell order}}\label{naive.trader---fetch-the-sell-order}

In case of fetching the sell order, we will pattern match on a \texttt{:fetch\_sell\_order} atom and slim down on pattern matching:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:fetch\_sell\_order}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{State}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol,}
           \VariableTok{sell\_order:}
\NormalTok{             \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
               \VariableTok{order\_id:}\NormalTok{ order\_id,}
               \VariableTok{transact\_time:}\NormalTok{ timestamp}
             \FunctionTok{\}} \OperatorTok{=}\NormalTok{ sell\_order}
         \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trader\textquotesingle{}s(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{ }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ SELL order got partially filled"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ current\_sell\_order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}
\NormalTok{        symbol,}
\NormalTok{        timestamp,}
\NormalTok{        order\_id}
      \FunctionTok{)}

    \VariableTok{:ok} \OperatorTok{=}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{current\_sell\_order}\FunctionTok{)}

\NormalTok{    sell\_order }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{sell\_order }\OperatorTok{|} \VariableTok{status:}\NormalTok{ current\_sell\_order}\OperatorTok{.}\NormalTok{status}\FunctionTok{\}}

\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{sell\_order:}\NormalTok{ sell\_order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{Naive.Trader} - Triggering rebuy}{Naive.Trader - Triggering rebuy}}\label{naive.trader---triggering-rebuy}

In case of triggering the rebuy procedure, we will pattern match on a \texttt{:rebuy} atom, slim down on pattern matching and simplify the function a fair bit(no branching required anymore - yay!):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:rebuy}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{State}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol}
         \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Rebuy triggered for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ by the trader(}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{)"}\FunctionTok{)}
\NormalTok{    new\_state }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{rebuy\_notified:} \ConstantTok{true}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:rebuy\_triggered}\NormalTok{, new\_state}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{Naive.Trader} - The final ignore clause}{Naive.Trader - The final ignore clause}}\label{naive.trader---the-final-ignore-clause}

The final ignore clause will \texttt{:skip} all events:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ execute\_decision}\FunctionTok{(}\VariableTok{:skip}\NormalTok{, state}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The ignore clause finishes our current refactoring round, which showcased that sometimes abstracting pattern matching into a separate function is a valid strategy to increase the amount of pure code.

Note: The fact that we could abstract the logic from pattern matches is quite a unique situation to our application. I would not advise abstracting GenServer pattern matching into a separate module if dealing with different structs/actions(in our case, all our pattern matches were ``making a trading decision'', it's a single ``action'', that's why we abstracted them).

\section{Dealing with dirty code}\label{dealing-with-dirty-code}

In the last section, we've split the \texttt{handle\_info/2} clauses into the \texttt{generate\_decision/2} and \texttt{execute\_decision/2} functions. That's excellent progress, but we still have the strategy logic inside the \texttt{Naive.Trader} module.

Let's move the \texttt{execute\_decision/2} function(together with all the code that it depends on, like the \texttt{broadcast\_order/1} and \texttt{convert\_to\_order/1} functions as well as a copy of the \texttt{require\ Logger}) from the \texttt{Naive.Trader} module to the \texttt{Naive.Strategy} module.

As the \texttt{generate\_decision/2} function is causing side effects, we don't want it to be called directly from the outside of the module, so we will need to make it private.

Changing the \texttt{execute\_decision/2} function(now inside the \texttt{Naive.Strategy} module) to private will cause a problem with the \texttt{handle\_info/2} callback function inside the \texttt{Naive.Trader} module as it relies on the \texttt{execute\_decision/2} function to be public. The fact that our strategy makes a decision and then executes code based on it is an implementation detail that we shouldn't share with the \texttt{Naive.Trader} module. That's why we will move the \textbf{body} of the \texttt{handle\_info/2} callback function into a new function called \texttt{execute/2} inside the \texttt{Naive.Strategy} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ execute}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, \%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    generate\_decision}\FunctionTok{(}\NormalTok{trade\_event, state}\FunctionTok{)}
    \OperatorTok{|\textgreater{}}\NormalTok{ execute\_decision}\FunctionTok{(}\NormalTok{state}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Before updating the \texttt{Naive.Trader} module to use the \texttt{execute/2} function, we need to address another issue that moving the \texttt{execute\_decision/2} caused. At this moment, all of the clauses return GenServer specific tuples. What we really need to return to the trader is an atom indicating should it continue or terminate together with the updated state:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# last lines inside the \textasciigrave{}execute\_decision/2\textasciigrave{} clauses}
\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_state}\FunctionTok{\}} \CommentTok{\# \textless{}= previously \{:noreply, new\_state\} (5 times)}
\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, state}\FunctionTok{\}} \CommentTok{\# \textless{}= previously \{:noreply, state\} (once)}
\VariableTok{:exit} \CommentTok{\# \textless{}= previously \{:stop, :normal, state\} + remove \textasciigrave{}state\textasciigrave{} pattern match (once)}
\end{Highlighting}
\end{Shaded}

We can now update the \texttt{handle\_info/2} callback function to call the new ``interface'' of the \texttt{Naive.Strategy} module that we just created and act accordingly to the result:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, \%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{execute}\FunctionTok{(}\NormalTok{trade\_event, state}\FunctionTok{)} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_state}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}} \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, new\_state}\FunctionTok{\}}
      \VariableTok{:exit} \OperatorTok{{-}\textgreater{}} \FunctionTok{\{}\VariableTok{:stop}\NormalTok{, }\VariableTok{:normal}\NormalTok{, state}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment, we could just copy/move module attributes from the \texttt{Naive.Trader} module to the \texttt{Naive.Strategy} module and our code would start to work again. Still, before we will do that, we will use this opportunity to look into how to make our dirty code testable.

\section{Making dirty code testable}\label{making-dirty-code-testable}

Making dirty code testable is very closely linked to injecting dependencies. In the testing environment, we would like to use dummy implementations instead of executing the side-effect-causing code to simplify the tests. We will look into the different ways that we can pass side-effect-causing ``code'' into impure functions.

\subsection{Passing functions arguments}\label{passing-functions-arguments}

Functions are first-class citizens in Elixir, which means that we can pass them as arguments to functions. This way, we can pass side-effect causing functions into our \texttt{Naive.Strategy} module.

Let's look at how this would look in practice. We need to look into the \texttt{execute\_decision/2} function, as it's where the place side effects happen. Looking at the 1st clause(responsible for placing a buy order), we can see that it's calling the \texttt{Logger.info/1}, \texttt{Binance.order\_limit\_buy/4}, \texttt{PubSub.broadcast/3}(via the \texttt{broadcast\_order/1} function) and \texttt{Leader.notify/2} functions. To make our code easily testable, we would need to be able to pass dummy implementations for all of those.

As we aren't calling the \texttt{execute\_decision/2} directly, we need to pass all of the above functions as arguments to the \texttt{execute/2} function, which will pass them onward to the \texttt{execute\_decision/2}.

We can see that even with default values pointing to the ``real'' implementation, that's still \textbf{a lot} of noise to make testing easier. It will negatively impact the maintenance of the code - here's an example of what this would look like(don't bother typing it):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# injecting dummy implementation, fallback to real implementation}
\KeywordTok{def}\NormalTok{ execute}\FunctionTok{(}
\NormalTok{  \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event,}
\NormalTok{  \%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state,}
\NormalTok{  logger\_info \textbackslash{}\textbackslash{} }\OperatorTok{\&}\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\OperatorTok{/}\DecValTok{1}\NormalTok{, }\CommentTok{\# \textless{}= function injected}
\NormalTok{  order\_limit\_buy \textbackslash{}\textbackslash{} }\OperatorTok{\&}\ConstantTok{Binance}\OperatorTok{.}\NormalTok{order\_limit\_buy}\OperatorTok{/}\DecValTok{4}\NormalTok{, }\CommentTok{\# \textless{}= function injected}
\NormalTok{  pubsub\_broadcast \textbackslash{}\textbackslash{} }\OperatorTok{\&}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\OperatorTok{/}\DecValTok{3}\NormalTok{, }\CommentTok{\# \textless{}= function injected}
\NormalTok{  notify\_leader \textbackslash{}\textbackslash{} }\OperatorTok{\&}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\OperatorTok{/}\DecValTok{2} \CommentTok{\# \textless{}= function injected}
\FunctionTok{)} \KeywordTok{do}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

There are already four functions, and we only took care of side-effects causing functions from the first \texttt{execute\_decision/2} clause. We can easily see how this very quickly becomes just unmanageable as there would be 10+ ``injected'' arguments going from the \texttt{execute/2} to \texttt{execute\_decision/2}, and only some of them would be used in each clause.

Additional downsides:

\begin{itemize}
\tightlist
\item
  when passing a function as an argument, we need to specify the arity, so when we would like to use more than one arity, we need to pass the function \textbf{multiple times with different arities}. An example could be passing \texttt{Logger.info/1} and \texttt{Logger.info/2}
\item
  we need to give a name to every passed function, sometimes multiple arities (again, how should variables for \texttt{Logger.info/1} and \texttt{Logger.info/2} be called? \texttt{logger\_info\_2}?)
\item
  share amount of arguments negatively impacts code readability
\end{itemize}

We can see that passing functions as arguments is just a bad idea in case of making our code testable. It will have the opposite effect, decreasing readability making our code difficult to maintain and follow.

Important note: Passing functions as arguments is not always bad! A good example could be when different actions need to be performed based on runtime data.

\newpage

\subsection{Passing grouped functions as a context}\label{passing-grouped-functions-as-a-context}

The natural next step would be to put all of those functions into some structure like Map or Keyword list. Whichever we would choose, we will end up with the same problems of naming keys(this time inside the map/keyword list), multiple functions because of different arity but also default values inside each clause of the \texttt{execute\_decision/2} function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:place\_buy\_order}\NormalTok{, price, quantity}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \VariableTok{symbol:}\NormalTok{ symbol}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state,}
\NormalTok{        \%}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ context }\CommentTok{\# \textless{}= context added}
      \FunctionTok{)} \KeywordTok{do}
    \CommentTok{\# vvv fetch from context vvv}
\NormalTok{    logger\_info }\OperatorTok{=} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\NormalTok{context, }\VariableTok{:logger\_info}\NormalTok{, }\OperatorTok{\&}\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
\NormalTok{    order\_limit\_buy }\OperatorTok{=} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\NormalTok{context, }\VariableTok{:order\_limit\_buy}\NormalTok{, }\OperatorTok{\&}\ConstantTok{Binance}\OperatorTok{.}\NormalTok{order\_limit\_buy}\OperatorTok{/}\DecValTok{4}\FunctionTok{)}
\NormalTok{    leader\_notify }\OperatorTok{=} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\NormalTok{context, }\VariableTok{:leader\_notify}\NormalTok{, }\OperatorTok{\&}\ConstantTok{Leader}\OperatorTok{.}\NormalTok{notify}\OperatorTok{/}\DecValTok{2}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Again this looks like a bad idea. It's probably marginally better than just sending functions one by one, but not much.

\subsection{Passing grouped modules as a context}\label{passing-grouped-modules-as-a-context}

The significant advantage of passing modules as arguments instead of functions is that we no longer have a problem with naming keys or caring about different functions' arities. There will also be substantially fewer modules used in comparison to functions.

Sadly we still need to use the \texttt{Map} function to get the modules out of \texttt{"context"}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:place\_buy\_order}\NormalTok{, price, quantity}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{State}\FunctionTok{\{}
          \VariableTok{id:}\NormalTok{ id,}
          \VariableTok{symbol:}\NormalTok{ symbol}
        \FunctionTok{\}} \OperatorTok{=}\NormalTok{ state,}
\NormalTok{        \%}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ context }\CommentTok{\# \textless{}= context added}
      \FunctionTok{)} \KeywordTok{do}
\NormalTok{    logger }\OperatorTok{=} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\NormalTok{context, }\VariableTok{:logger}\NormalTok{, }\OperatorTok{\&}\ConstantTok{Logger}\FunctionTok{)} \CommentTok{\# \textless{}= fetch from context}
\NormalTok{    binance }\OperatorTok{=} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\NormalTok{context, }\VariableTok{:binance}\NormalTok{, }\ConstantTok{Binance}\FunctionTok{)} \CommentTok{\# \textless{}= fetch from context}
\NormalTok{    leader }\OperatorTok{=} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\NormalTok{context, }\VariableTok{:leader}\NormalTok{, }\OperatorTok{\&}\ConstantTok{Leader}\FunctionTok{)} \CommentTok{\# \textless{}= fetch from context}
\end{Highlighting}
\end{Shaded}

This is much better, but we will still need to do a fair amount of additional work to get the modules out. Also, our code will be full of the ``default'' modules(as \textbf{each} of the clauses retrieving them from the context will need to specify defaults).

\subsection{Injecting modules to module's attributes based on the configuration}\label{injecting-modules-to-modules-attributes-based-on-the-configuration}

And we finally got there - we have come a full circle. This is the approach that we previously used inside the \texttt{Naive.Trader} module(you can go ahead and add them to the \texttt{Naive.Strategy} module):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy} \KeywordTok{do}
  \OperatorTok{...}

  \OtherTok{@binance\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}
  \OtherTok{@leader} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:leader}\FunctionTok{)}
  \OtherTok{@logger} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:logger}\FunctionTok{)}
  \OtherTok{@pubsub\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:pubsub\_client}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

We looked into different ways to inject dependencies to understand their downsides.

Sometimes, injecting values(like modules) as module attributes can feel like a ``global state'', ``singleton'', or similar antipattern. We need to understand that each programming language provides different ways to solve common programming problems. Dependency injection is one of those common concerns that every language needs to solve, and Elixir solves it by using compile-time modules' attributes.

As long as you are using module attributes to be able to inject compile-time dependencies to test your code, there's just \textbf{no better way} to do it in Elixir, and now we know why(based on the issues with the alternative approaches).

Together with the module attributes, our code should be now fully functional.

\section{\texorpdfstring{The power \texttt{with}-in}{The power with-in}}\label{the-power-with-in}

In the last section, we looked into different ways to inject modules' dependencies to avoid side-effects causing functions inside the tests. Besides side-effect causing functions, in functional programming, error handling is also done in a specific manner.

Many languages introduced concepts like \texttt{Either}, which is a struct that can be either \texttt{Left}(error result) or \texttt{Right}(success result). Those quite nicely fit to the standard Elixir results like \texttt{\{:error,\ reason\}} and \texttt{\{:ok,\ result\}}. Further, those languages provide multiple functions to work with the \texttt{Either}, like \texttt{map}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{safeDivide}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{0}\FunctionTok{)} \CommentTok{\# \textless{}= returns Left("Dividing error")}
\OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\ConstantTok{Either}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1} \OperatorTok{*} \DecValTok{2}\FunctionTok{)))} \CommentTok{\# \textless{}= still Left("Dividing error")}

\NormalTok{safeDivide}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\FunctionTok{)} \CommentTok{\# \textless{}= returns Right(2)}
\OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\ConstantTok{Either}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1} \OperatorTok{*} \DecValTok{2}\FunctionTok{)))} \CommentTok{\# \textless{}= returns Right(4)}
\end{Highlighting}
\end{Shaded}

The above code will use hypothetical \texttt{Left(\textquotesingle{}Dividing\ error\textquotesingle{})} or \texttt{Right(result)}. The \texttt{Either.map/2} is a special \texttt{map} function that runs the passed function if it's \texttt{Right} or completely ignores it when it's \texttt{Left} - it could be visualized as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ map}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Either}\OperatorTok{.}\ConstantTok{Left}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ left, \_fun}\FunctionTok{)}\NormalTok{, }\VariableTok{do:}\NormalTok{ left}
\KeywordTok{def}\NormalTok{ map}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Either}\OperatorTok{.}\ConstantTok{Right}\FunctionTok{\{}\VariableTok{result:}\NormalTok{ v}\FunctionTok{\}}\NormalTok{, fun}\FunctionTok{)}\NormalTok{, }\VariableTok{do:}\NormalTok{ \%}\ConstantTok{Either}\OperatorTok{.}\ConstantTok{Right}\FunctionTok{\{}\VariableTok{result:}\NormalTok{ fun}\OperatorTok{.}\FunctionTok{(}\NormalTok{v}\FunctionTok{)\}}
\end{Highlighting}
\end{Shaded}

This is nice and great, but what if the function inside the \texttt{Either.map/2} returns another \texttt{Either}? Like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{safeDivide}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\FunctionTok{)} \CommentTok{\# \textless{}= returns Right(2)}
\OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\ConstantTok{Either}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\NormalTok{safeDivide}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\DecValTok{1}\FunctionTok{))))} \CommentTok{\# \textless{}= now Right(Right(2))!?}
\end{Highlighting}
\end{Shaded}

Now we need to understand those abstractions to be able to decide should we \texttt{map} or \texttt{flatMap}(that's the function that will not wrap the function result into the \texttt{Right}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{safeDivide}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\FunctionTok{)} \CommentTok{\# \textless{}= returns Right(2)}
\OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\ConstantTok{Either}\OperatorTok{.}\NormalTok{flatMap}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\NormalTok{safeDivide}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\DecValTok{1}\FunctionTok{))))} \OperatorTok{\textless{}=}\NormalTok{ still }\ConstantTok{Right}\FunctionTok{(}\DecValTok{2}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

And that is just the beginning of the complexities that those abstractions bring.

Furthermore, let's say that inside the first \texttt{Either.map/2} callback, we will have some variable(s) that we would like to use later on. We are now deep inside closures world like the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{safeDivide}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\FunctionTok{)} \CommentTok{\# \textless{}= returns Right(2)}
\OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\ConstantTok{Either}\OperatorTok{.}\NormalTok{flatMap}\FunctionTok{(}\KeywordTok{fn}\NormalTok{ res }\OperatorTok{{-}\textgreater{}}
    \CommentTok{\# x = some data generated here}
\NormalTok{    safeDivide}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\FunctionTok{)}
    \OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\ConstantTok{Either}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1} \OperatorTok{*} \DecValTok{2}\FunctionTok{)))}
    \OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\ConstantTok{Either}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1} \OperatorTok{*}\NormalTok{ x}\FunctionTok{)))} \CommentTok{\# \textless{}= a clause to have access to x}
  \KeywordTok{end}\FunctionTok{))}
\end{Highlighting}
\end{Shaded}

The above example is obviously simplified and silly but should give us a gist of what sort of complexity we will very soon get involved in. And, again, we just scratched the surface - there are so many more functions that the \texttt{Either} provides. Besides, writing code in this fashion in Elixir would cause a lot of friction in the team as it's difficult to find any advantages of using it.

\subsection{Idiomatic error handling}\label{idiomatic-error-handling}

To achieve the same results, Elixir provides the \texttt{with} statement:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  with }\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, divide\_result}\FunctionTok{\}} \OperatorTok{\textless{}{-}}\NormalTok{ safeDiv}\FunctionTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\FunctionTok{)}\NormalTok{,}
       \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, divide\_result\_2}\FunctionTok{\}} \OperatorTok{\textless{}{-}}\NormalTok{ safeDivide}\FunctionTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\FunctionTok{)}
  \KeywordTok{do}
\NormalTok{    divide\_result\_2 }\OperatorTok{*} \DecValTok{2} \OperatorTok{*}\NormalTok{ divide\_result}
  \ControlFlowTok{else}
\NormalTok{    err }\OperatorTok{{-}\textgreater{}}\NormalTok{ err}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above code provides \textbf{the same} functionality as the one before with \texttt{Either}. We can clearly understand it \textbf{without} any knowledge about how \texttt{Either} works, \texttt{mapping}, \texttt{flatMapping} etc. It's just standard Elixir.

Again, as in the case of modules' attributes. Elixir provides a pragmatic way of dealing with errors - just return a tuple with an \texttt{:error} atom. It also provides utility functions like \texttt{with} to deal with errors in an idiomatic way. There's \textbf{no reason} to introduce concepts like \texttt{Either} as language has built-in concepts/patterns taking care of error situations.

\section{Do or not to do}\label{do-or-not-to-do}

In the last section, we discussed wrapping the results in the \texttt{Either} structs to be able to map, flatMap on them regardless of the function result. What if we could apply the same principle to avoid executing any code(side effects) at all?

That's the basic idea behind all the category theory related abstractions like the infamous IO Monad.

I won't go into a vast amount of details. Still, we can think about it as every time we are calling a \emph{special} \texttt{map} or \texttt{flatMap}, instead of executing anything, it would just wrap whatever was passed to it inside another function and return it like:

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{def}\NormalTok{ map}\FunctionTok{(}\NormalTok{acc, function}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
      \KeywordTok{case}\NormalTok{ acc}\OperatorTok{.}\FunctionTok{()} \KeywordTok{do}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, data}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}} \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, function}\OperatorTok{.}\FunctionTok{(}\NormalTok{data}\FunctionTok{)\}}
        \FunctionTok{\{}\VariableTok{:error}\NormalTok{, error}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, error}\FunctionTok{\}}
      \KeywordTok{end}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

In a nutshell, what we would end up with is a function containing a function containing a function\ldots{} At this moment, I find it very difficult to find any practical reason why somebody would want to do something like this in a dynamically typed language.

In statically typed languages, there's an argument that instead of a function of function etc., we could have a typed object which would indicate what actions can be performed on that future result. This is very often praised as a compile-time guarantee of side effectfull code.

In the Elixir, without strong typing and with a massive impact on how the code is written and how easy it is to understand, there's just \textbf{no practical} reason to use those concepts beyond toy programs. The resulting function would be an untestable blob without introspection support from the BEAM VM.

\newpage

\section{Final thoughts}\label{final-thoughts}

Every programming language needs to provide tools to handle common concerns like error handling or dependency injection.

Elixir provides excellent tools to handle both of those concerns using the \texttt{with} statement and modules' attributes.

Without a type system, there's no practical reason why anybody would introduce category theory-based abstractions like Monads. The resulting code will be complicated to deal with, and as in the case of many other \textbf{functional} programming languages like Ocaml or Clojure, the pragmatic way is to execute side effects.

\textbf{It's the developers' responsibility to design code in a way that maximizes the amount of pure code and push side effects to ``the edge''.} The typical pattern would be to ``prepare'' (group all logic before side effects) or to ``post process'' the results of multiple side effects (group pure logic after side effects).

That's all in regards to functional programming in Elixir. In the next chapter, we will look into what the idiomatic Elixir code looks like.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_18}{GitHub}

\chapter{Idiomatic OTP}\label{idiomatic-otp}

\section{Objectives}\label{objectives-18}

\begin{itemize}
\tightlist
\item
  the concept
\item
  initial implementation
\item
  idiomatic solution
\end{itemize}

\section{The concept}\label{the-concept}

In this chapter, we will look into building an OHLC(open-high-low-close) indicator. We will discuss different potential implementations, which will give us an excellent example to understand the idiomatic usage of the OTP framework.

The OHLC indicator consists of four prices that could be used to draw a candle on the chart:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_19_01_ohlc_candle} \end{center}

The OHLC indicators get created by collecting the first price (the ``open'' price), lowest price(the ``low'' price), highest price(the ``high'' price) and the last price(the ``close'' price) within a specific timeframe like 1 minute. Our code will need to be able to generate those for multiple timeframes at once - 1m, 5m, 15m, 1h, 4h and 24h.

\section{Initial implementation}\label{initial-implementation}

What we could do is to have multiple GenServer processes subscribed to the trade events topic in the PubSub where each one would update their own OHLC numbers:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_19_02_multi_workers} \end{center}

Let's start by creating a new application inside our umbrella called ``indicators''(run below inside terminal):

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cd apps }
\ExtensionTok{$}\NormalTok{ mix new indicator }\AttributeTok{{-}{-}sup}
\end{Highlighting}
\end{Shaded}

We can now create a new directory called ``ohlc'' inside the ``/apps/indicator/lib/indicator'' directory, where we will create the GenServer ``worker.ex'' file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc/worker.ex}
\KeywordTok{defmodule} \ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{Ohlc}\OperatorTok{.}\ConstantTok{Worker} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{GenServer}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(\{}\NormalTok{symbol, duration}\FunctionTok{\})} \KeywordTok{do}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, }\FunctionTok{\{}\NormalTok{symbol, duration}\FunctionTok{\})}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(\{}\NormalTok{symbol, duration}\FunctionTok{\})} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\FunctionTok{\{}\NormalTok{symbol, duration}\FunctionTok{\}\}}
  \KeywordTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

As each worker will need to subscribe to the PubSub's \texttt{"TRADE\_EVENTS:\#\{symbol\}"} topic, we can update the \texttt{init/1} function to do that:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc/worker.ex}

  \CommentTok{\# add those at the top of the worker module}
  \ImportTok{require} \ConstantTok{Logger}

  \OtherTok{@logger} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:logger}\FunctionTok{)}
  \OtherTok{@pubsub\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:pubsub\_client}\FunctionTok{)}

  \OperatorTok{...}

  \CommentTok{\# updated \textasciigrave{}init/1\textasciigrave{} function}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(\{}\NormalTok{symbol, duration}\FunctionTok{\})} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Initializing a new OHLC worker(}\OtherTok{\#\{}\NormalTok{duration}\OtherTok{\}}\StringTok{ minutes) for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

    \OtherTok{@pubsub\_client}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\FunctionTok{\{}\NormalTok{symbol, duration}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Following the pattern established by the \texttt{Naive.Trader}, we use the module's attributes(with values based on the configuration) instead of hardcoded module names.

Additionally, we've used the \texttt{Core.PubSub} and \texttt{Phoenix.PubSub}(indirectly) modules so we need to add them to the dependencies list of the \texttt{indicator} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \FunctionTok{\{}\VariableTok{:core}\NormalTok{, }\VariableTok{in\_umbrella:} \ConstantTok{true}\FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= added}
      \FunctionTok{\{}\VariableTok{:phoenix\_pubsub}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}} \CommentTok{\# \textless{}= added}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

As we subscribed to the PubSub, we need to provide a callback that will handle the incoming trade events:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc/worker.ex}
  \CommentTok{\# add this at the top}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Struct}\OperatorTok{.}\ConstantTok{TradeEvent}


  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, ohlc}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, }\ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{Ohlc}\OperatorTok{.}\NormalTok{process}\FunctionTok{(}\NormalTok{ohlc, trade\_event}\FunctionTok{)\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

To avoid mixing our business logic with the GenServer boilerplate(as discussed in the last chapter), we will place it in a new module. First, we need to create a new file \texttt{/apps/indicator/lib/indicator/ohlc.ex} and the \texttt{Indicator.Ohlc} module inside it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
\KeywordTok{defmodule} \ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{Ohlc} \KeywordTok{do}

\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The \texttt{Indicator.Ohlc} module will define a struct that the \texttt{Indicator.Ohlc.Worker} will use as a state:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
  \OtherTok{@enforce\_keys} \OtherTok{[}
    \VariableTok{:symbol}\NormalTok{,}
    \VariableTok{:start\_time}\NormalTok{,}
    \VariableTok{:duration}
  \OtherTok{]}
  \KeywordTok{defstruct} \OtherTok{[}
    \VariableTok{:symbol}\NormalTok{,}
    \VariableTok{:start\_time}\NormalTok{,}
    \VariableTok{:duration}\NormalTok{,}
    \VariableTok{:open}\NormalTok{,}
    \VariableTok{:high}\NormalTok{,}
    \VariableTok{:low}\NormalTok{,}
    \VariableTok{:close}
  \OtherTok{]}
\end{Highlighting}
\end{Shaded}

Most of the above are self-descriptive, besides the \texttt{start\_time}(a Unix timestamp) and the \texttt{duration}(the timeframe in minutes).

We can now progress to the implementation of the \texttt{process/2} function, but instead of focusing on it, we will start from the ``deepest''/``bottom'' function that it will rely on and work our way up. As we discussed in the last chapter, we will try to maximize the amount of pure code.

We can imagine that the bottom function will be involved in merging of the trade event's data with the current OHLC data. Two things can happen, either:

\begin{itemize}
\tightlist
\item
  trade event's \texttt{trade\_time} is \textbf{within} the current OHLC timeframe. Trade event's price will get merged to the current OHLC
\item
  trade event's \texttt{trade\_time} is \textbf{outside} the current OHLC timeframe. The current(now old) OHLC will be returned together with a new OHLC based on the trade event's price
\end{itemize}

\newpage

Here's the implementation:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
  \KeywordTok{def}\NormalTok{ merge\_price}\FunctionTok{(}\NormalTok{\%}\ConstantTok{\_\_MODULE\_\_}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ ohlc, price, trade\_time}\FunctionTok{)} \KeywordTok{do}
    \ControlFlowTok{if}\NormalTok{ within\_current\_timeframe}\FunctionTok{(}\NormalTok{ohlc}\OperatorTok{.}\NormalTok{start\_time, ohlc}\OperatorTok{.}\NormalTok{duration, trade\_time}\FunctionTok{)} \KeywordTok{do}
      \FunctionTok{\{}\ConstantTok{nil}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{ohlc }\OperatorTok{|} \VariableTok{low:}\NormalTok{ min}\FunctionTok{(}\NormalTok{ohlc}\OperatorTok{.}\NormalTok{low, price}\FunctionTok{)}\NormalTok{, }\VariableTok{high:}\NormalTok{ max}\FunctionTok{(}\NormalTok{ohlc}\OperatorTok{.}\NormalTok{high, price}\FunctionTok{)}\NormalTok{, }\VariableTok{close:}\NormalTok{ price}\FunctionTok{\}\}}
    \ControlFlowTok{else}
      \FunctionTok{\{}\NormalTok{ohlc, generate\_ohlc}\FunctionTok{(}\NormalTok{ohlc}\OperatorTok{.}\NormalTok{symbol, ohlc}\OperatorTok{.}\NormalTok{duration, price, trade\_time}\FunctionTok{)\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

together with the \texttt{within\_current\_timeframe/3} and \texttt{generate\_ohlc/3} function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
  \KeywordTok{def}\NormalTok{ within\_current\_timeframe}\FunctionTok{(}\NormalTok{start\_time, duration, trade\_time}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    end\_time }\OperatorTok{=}\NormalTok{ start\_time }\OperatorTok{+}\NormalTok{ duration }\OperatorTok{*} \DecValTok{60}
\NormalTok{    trade\_time }\OperatorTok{=}\NormalTok{ div}\FunctionTok{(}\NormalTok{trade\_time, }\DecValTok{1000}\FunctionTok{)}

\NormalTok{    start\_time }\OperatorTok{\textless{}=}\NormalTok{ trade\_time }\OperatorTok{\&\&}\NormalTok{ trade\_time }\OperatorTok{\textless{}}\NormalTok{ end\_time}
  \KeywordTok{end}
  
  \KeywordTok{def}\NormalTok{ generate\_ohlc}\FunctionTok{(}\NormalTok{symbol, duration, price, trade\_time}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    start\_time }\OperatorTok{=}\NormalTok{ div}\FunctionTok{(}\NormalTok{div}\FunctionTok{(}\NormalTok{div}\FunctionTok{(}\NormalTok{trade\_time, }\DecValTok{1000}\FunctionTok{)}\NormalTok{, }\DecValTok{60}\FunctionTok{)}\NormalTok{, duration}\FunctionTok{)} \OperatorTok{*}\NormalTok{ duration }\OperatorTok{*} \DecValTok{60}

\NormalTok{    \%}\ConstantTok{\_\_MODULE\_\_}\FunctionTok{\{}
      \VariableTok{symbol:}\NormalTok{ symbol,}
      \VariableTok{start\_time:}\NormalTok{ start\_time,}
      \VariableTok{duration:}\NormalTok{ duration,}
      \VariableTok{open:}\NormalTok{ price,}
      \VariableTok{high:}\NormalTok{ price,}
      \VariableTok{low:}\NormalTok{ price,}
      \VariableTok{close:}\NormalTok{ price}
    \FunctionTok{\}}
  \KeywordTok{end}  
\end{Highlighting}
\end{Shaded}

Moving up the call chain, besides merging the trade event's data into OHLC data, we need to deal with the initial state of the worker(the \texttt{\{symbol,\ duration\}} tuple). Let's add a \texttt{process/2} function with two clauses handling each of those cases:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
  \CommentTok{\# add the below line at the top of the module}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Struct}\OperatorTok{.}\ConstantTok{TradeEvent}

  \KeywordTok{def}\NormalTok{ process}\FunctionTok{(}\NormalTok{\%}\ConstantTok{\_\_MODULE\_\_}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ ohlc, \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\NormalTok{old\_ohlc, new\_ohlc}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ merge\_price}\FunctionTok{(}\NormalTok{ohlc, trade\_event}\OperatorTok{.}\NormalTok{price, trade\_event}\OperatorTok{.}\NormalTok{trade\_time}\FunctionTok{)}
\NormalTok{    maybe\_broadcast}\FunctionTok{(}\NormalTok{old\_ohlc}\FunctionTok{)}
\NormalTok{    new\_ohlc}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ process}\FunctionTok{(\{}\NormalTok{symbol, duration}\FunctionTok{\}}\NormalTok{, \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    generate\_ohlc}\FunctionTok{(}\NormalTok{symbol, duration, trade\_event}\OperatorTok{.}\NormalTok{price, trade\_event}\OperatorTok{.}\NormalTok{trade\_time}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The second clause takes care of the initial state of the OHLC worker(happens upon receiving the first trade event - once in the lifetime of the worker process).

The first clause handles all the other trade events.

This order of clauses could appear weird, but it makes a lot of sense as Elixir will try pattern match clauses from the top, and in our case, the first(top) clause will be used for almost all of the calls.

\subsection{Maybe functions}\label{maybe-functions}

Let's get back to the first clause of the \texttt{process/2} function as it uses another Elixir/Erlang pattern that we didn't discuss before - the \texttt{maybe\_do\_x} functions.

In case of the incoming trade event's \texttt{trade\_time} \textbf{outside} of the current OHLC's timeframe, we would like to \textbf{broadcast} the current OHLC and return a new OHLC(based on the trade event's data). Otherwise(trade event's \texttt{trade\_time} \textbf{within} the current OHLC), the trade event's \texttt{price} is merged into the current OHLC, and it's \textbf{not} broadcasted.

This sounds very similar to the if-else, but it's most of the time achieved using the pattern matching:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
 \CommentTok{\# add below lines at the top of the module}
 \ImportTok{require} \ConstantTok{Logger}

 \OtherTok{@pubsub\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:pubsub\_client}\FunctionTok{)}

  \KeywordTok{defp}\NormalTok{ maybe\_broadcast}\FunctionTok{(}\ConstantTok{nil}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:ok}

  \KeywordTok{defp}\NormalTok{ maybe\_broadcast}\FunctionTok{(}\NormalTok{\%}\ConstantTok{\_\_MODULE\_\_}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ ohlc}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{debug}\FunctionTok{(}\StringTok{"Broadcasting OHLC: }\OtherTok{\#\{}\NormalTok{inspect}\FunctionTok{(}\NormalTok{ohlc}\FunctionTok{)}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

    \OtherTok{@pubsub\_client}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"OHLC:}\OtherTok{\#\{}\NormalTok{ohlc}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      ohlc}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

By using a separate function, we avoided branching using if-else inside the \texttt{process/2} function. The idea is not necessarily to avoid if statements but to keep the code at the consistent level of abstraction, so it's easier to understand. Inside the \texttt{process/2} function, we can understand what's going on just by reading the function names inside - there's no ``logic''.

Sometimes people advise that ``code should be like well written prose'' and \texttt{maybe\_do\_x} functions are one of the ways to achieve this ``nirvana'' state.

\subsection{Testing}\label{testing}

At this moment, our code should compile, and we should already be able to test it. First, let's change the logging level to \texttt{debug} inside \texttt{config/config.exs} to see what OHLC structs got broadcasted:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:logger}\NormalTok{,}
  \VariableTok{level:} \VariableTok{:debug} \CommentTok{\# \textless{}= updated}
\end{Highlighting}
\end{Shaded}

We can now progress with testing:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Indicator.Ohlc.Worker.start\_link}\KeywordTok{(}\ExtensionTok{\{}\StringTok{"XRPUSDT"}\ExtensionTok{,}\NormalTok{ 1\}}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.447.0\textgreater{}\}}
\ExtensionTok{...}
\ExtensionTok{22:45:00.335} \PreprocessorTok{[}\SpecialStringTok{debug}\PreprocessorTok{]}\NormalTok{ Broadcasting OHLC: \%Indicator.Ohlc\{close: }\StringTok{"0.63880000"}\NormalTok{, duration: 1,}
\ExtensionTok{high:} \StringTok{"0.63890000"}\NormalTok{, low: }\StringTok{"0.63840000"}\NormalTok{, open: }\StringTok{"0.63860000"}\NormalTok{, start\_time: 1644014640,}
\ExtensionTok{symbol:} \StringTok{"XRPUSDT"}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The above test confirms that we can manually start a single OHLC worker that will aggregate data over a single minute timeframe.

\subsection{Supervision}\label{supervision}

To supervise multiple \texttt{Indicators.Worker}s we will use the \texttt{DynamicSupervisor}.
We need to update the Indicators application's supervision tree to start a dynamic supervisor:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/application.ex}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{DynamicSupervisor}\NormalTok{, }\VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{, }\VariableTok{name:} \ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{DynamicSupervisor}\FunctionTok{\}}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

\newpage

We can now add \texttt{aggregate\_ohlcs/1} function that will start all workers:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator.ex}
  \KeywordTok{def}\NormalTok{ aggregate\_ohlcs}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OtherTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{4} \OperatorTok{*} \DecValTok{60}\NormalTok{, }\DecValTok{24} \OperatorTok{*} \DecValTok{60}\OtherTok{]}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{each}\FunctionTok{(}
      \OperatorTok{\&}\ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
        \ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{DynamicSupervisor}\NormalTok{,}
        \FunctionTok{\{}\ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{Ohlc}\OperatorTok{.}\ConstantTok{Worker}\NormalTok{, }\FunctionTok{\{}\NormalTok{symbol, }\OperatorTok{\&}\DecValTok{1}\FunctionTok{\}\}}
      \FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now start multiple OHLC workers just by running a single function:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Indicator.aggregate\_ohlcs}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{\{:ok,} \CommentTok{\#PID\textless{}0.447.0\textgreater{}\}}
\end{Highlighting}
\end{Shaded}

The above calls will start six OHLC worker processes supervised under the \texttt{Indicator.DynamicSupervisor} process.

We could continue with this exercise, add a Registry to be able to stop the indicators and a database to be able to autostart them. Those improvements would get the ``indicators'' application in line with the other applications, but that's not the goal of this chapter.

\section{Idiomatic solution}\label{idiomatic-solution}

What we will focus on is the \textbf{usage of processes}(in our case the GenServers) in our solution. We've split our logic between multiple processes, each aggregating a single timeframe. All of those processes work in the same way. They subscribe to the PubSub topic, merge the incoming data into OHLC structs, and potentially broadcast them. The only difference is the timeframe that they use for merging data.

The solution feels very clean, but also we are using multiple processes to aggregate data for each symbol. In a situation like this, we should always ask ourselves:

\begin{itemize}
\tightlist
\item
  do we need that many processes?
\item
  are we using them to achieve parallelism? Is it required?
\item
  could we reorganize our code to use fewer processes?
\end{itemize}

The main idea is to keep our code as simple as possible and only use processes when it's absolutely required.

\newpage

Instead of a single worker being responsible for aggregation within a single timeframe, we could restructure our code to make it responsible for all timeframes of the symbol.

This improvement would:

\begin{itemize}
\tightlist
\item
  make our merging code a little bit complex(it would merge multiple timeframes at once)
\item
  decrease the amount of PubSub subscribers by six (instead of six processes per symbol, we would have just one)
\item
  potentially decrease the amount of broadcasted messages (we could group OHLC structs into a single message)
\item
  allow a single worker single worker to decide what to do with all current OHLCs in case of errors, \textbf{without} need for any additional symbol supervision level(like \texttt{one\_for\_all})
\item
  make it \textbf{impossible} to aggregate nor broadcast OHLCS of the same symbol in \textbf{parallel}
\end{itemize}

We can see that the solution based on processes could get really complex really quickly(multiple processes per symbol, growing supervision tree, multiple subscriptions, multiple messages etc).

Just to be clear - processes \textbf{do} have their place, they are a really powerful tool, but as with every tool, the responsibility lies on us developers to use them wisely - they \textbf{must not} be used for code organization.

Enough theory - let's look into how we could update our \texttt{Indicator.Ohlc} module to be able to deal with multiple timeframes at once.

Initially, we could be tempted to update the \texttt{process/2} function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
  \KeywordTok{def}\NormalTok{ process}\FunctionTok{(}\OtherTok{[}\NormalTok{\_ }\OperatorTok{|}\NormalTok{ \_}\OtherTok{]} \OperatorTok{=}\NormalTok{ ohlcs, \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    results }\OperatorTok{=}
\NormalTok{      ohlcs}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{merge\_price}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, trade\_event}\OperatorTok{.}\NormalTok{price, trade\_event}\OperatorTok{.}\NormalTok{trade\_time}\FunctionTok{))}

\NormalTok{    results }\OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{maybe\_broadcast}\FunctionTok{(}\NormalTok{elem}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\DecValTok{0}\FunctionTok{)))}
\NormalTok{    results }\OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{elem}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\DecValTok{1}\FunctionTok{))}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ process}\FunctionTok{(}\NormalTok{symbol, \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
    \OtherTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{4} \OperatorTok{*} \DecValTok{60}\NormalTok{, }\DecValTok{24} \OperatorTok{*} \DecValTok{60}\OtherTok{]}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}
      \OperatorTok{\&}\NormalTok{generate\_ohlc}\FunctionTok{(}
\NormalTok{        symbol,}
        \OperatorTok{\&}\DecValTok{1}\NormalTok{,}
\NormalTok{        trade\_event}\OperatorTok{.}\NormalTok{price,}
\NormalTok{        trade\_event}\OperatorTok{.}\NormalTok{trade\_time}
      \FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We added some logic to both clauses. At this moment, it maybe doesn't look that bad, but it's a great place to mix even more logic with dirty code. This is a great example where we should stop and rethink how we could maximize the amount of pure code.

Instead of expanding the \texttt{process/2} function, we could built on top of the \texttt{merge\_price/3} and \texttt{generate\_ohlc/4} functions, which deal with a single OHLC data. We could add plural versions of those functions that will understand that we now deal with multiple OHLC structs:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc.ex}
  \KeywordTok{def}\NormalTok{ merge\_prices}\FunctionTok{(}\NormalTok{ohlcs, price, trade\_time}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    results }\OperatorTok{=}
\NormalTok{      ohlcs}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{merge\_price}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, price, trade\_time}\FunctionTok{))}

    \FunctionTok{\{}
\NormalTok{      results }\OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{elem}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\DecValTok{0}\FunctionTok{))} \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{filter}\FunctionTok{(}\OperatorTok{\&} \OperatorTok{\&}\DecValTok{1}\FunctionTok{)}\NormalTok{,}
\NormalTok{      results }\OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{elem}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\DecValTok{1}\FunctionTok{))}
    \FunctionTok{\}}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ generate\_ohlcs}\FunctionTok{(}\NormalTok{symbol, price, trade\_time}\FunctionTok{)} \KeywordTok{do}
    \OtherTok{[}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{4} \OperatorTok{*} \DecValTok{60}\NormalTok{, }\DecValTok{24} \OperatorTok{*} \DecValTok{60}\OtherTok{]}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}
      \OperatorTok{\&}\NormalTok{generate\_ohlc}\FunctionTok{(}
\NormalTok{        symbol,}
        \OperatorTok{\&}\DecValTok{1}\NormalTok{,}
\NormalTok{        price,}
\NormalTok{        trade\_time}
      \FunctionTok{)}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now the \texttt{process/2} function got back to its almost original shape:

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{def}\NormalTok{ process}\FunctionTok{(}\OtherTok{[}\NormalTok{\_ }\OperatorTok{|}\NormalTok{ \_}\OtherTok{]} \OperatorTok{=}\NormalTok{ ohlcs, \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\NormalTok{old\_ohlcs, new\_ohlcs}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ merge\_prices}\FunctionTok{(}\NormalTok{ohlcs, trade\_event}\OperatorTok{.}\NormalTok{price, trade\_event}\OperatorTok{.}\NormalTok{trade\_time}\FunctionTok{)}

\NormalTok{    old\_ohlcs }\OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{each}\FunctionTok{(}\OperatorTok{\&}\NormalTok{maybe\_broadcast}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
\NormalTok{    new\_ohlcs}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ process}\FunctionTok{(}\NormalTok{symbol, \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    generate\_ohlcs}\FunctionTok{(}\NormalTok{symbol, trade\_event}\OperatorTok{.}\NormalTok{price, trade\_event}\OperatorTok{.}\NormalTok{trade\_time}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

By introducing the \texttt{merge\_prices/3} and \texttt{generate\_ohlcs/3} functions, we were able to keep the dirty part of our code small(it grew only to accommodate multiple broadcasts). The new functions are pure and can be easily tested.

As we modified the interface of the \texttt{process/2} function (by removing the \texttt{duration}), we need to update the \texttt{Indicator.Ohlc.Worker} module to be blissfully not aware that we have different durations:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator/ohlc/worker.ex}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= duration removed}
    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}\ConstantTok{\_\_MODULE\_\_}\NormalTok{, symbol}\FunctionTok{)}  \CommentTok{\# \textless{}= duration removed}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}  \CommentTok{\# \textless{}= duration removed}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}

    \OtherTok{@logger}\OperatorTok{.}\NormalTok{debug}\FunctionTok{(}\StringTok{"Initializing new a OHLC worker for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)} \CommentTok{\# \textless{}= duration skipped}

    \OperatorTok{...}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, symbol}\FunctionTok{\}}  \CommentTok{\# \textless{}= duration removed}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The final update will be to simplify the \texttt{Indicator.aggregate\_ohlcs/1} function just to start a single OHLC worker:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/indicator/lib/indicator.ex}
  \KeywordTok{def}\NormalTok{ aggregate\_ohlcs}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
      \ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{DynamicSupervisor}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Indicator}\OperatorTok{.}\ConstantTok{Ohlc}\OperatorTok{.}\ConstantTok{Worker}\NormalTok{, symbol}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now test our implementation by running the following once again:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Indicator.Ohlc.Worker.start\_link}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{23:23:00.416} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Broadcasting OHLC: \%Indicator.Ohlc\{close: }\StringTok{"0.68230000"}\NormalTok{, duration: 1,}
\ExtensionTok{high:} \StringTok{"0.68330000"}\NormalTok{, low: }\StringTok{"0.68130000"}\NormalTok{, open: }\StringTok{"0.68160000"}\NormalTok{, start\_time: 1644189720,}
\ExtensionTok{symbol:} \StringTok{"XRPUSDT"}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The logged message(s) confirms that our OHLC aggregator logic works as expected using a single process.

In the case of the OHLC aggregator, we've seen that there are some trade-off between running multiple processes(simpler code) vs single process(more complex merging) - it could be unclear what's the benefit of limiting the usage of processes(especially that they are ``almost free'').

I totally understand. Please treat this chapter as an introduction to the idiomatic Elixir. In the next chapter, we will apply this concept when refactoring the Naive trading strategy to see its practical benefits.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_19}{GitHub}

\chapter{Idiomatic trading strategy}\label{idiomatic-trading-strategy}

\section{Objectives}\label{objectives-19}

\begin{itemize}
\tightlist
\item
  Following the OHLC footsteps
\item
  Simplifying the Naive supervision tree
\item
  Supporting multiple positions
\item
  Retrofitting the ``shutdown'' functionality
\item
  Updating the Strategy to handle rebuys
\item
  Fetching active positions
\item
  Tidying up
\end{itemize}

\section{Following the OHLC footsteps}\label{following-the-ohlc-footsteps}

In the last chapter, we looked into the idiomatic Elixir. We refactored our initial implementation of OHLC aggregation to maximise the amount of pure code by limiting the number of processes running per symbol. It was a nice standalone functionality to showcase the concept.

In this chapter, we will look into how could we refactor our naive strategy's code to achieve the same result. At this moment, the naive strategy uses multiple processes per symbol, including \texttt{Trader} processes, dedicated \texttt{Leader} and \texttt{SymbolSupervisor}. We will update the \texttt{Trader} process to be responsible for multiple trades(we will call them ``positions'' from now on) on a single symbol. This way, we will have a single \texttt{Trader} process per symbol as well, as we will get rid of both the \texttt{Leader}(we will move rebuy/shutdown logic to our strategy - where it belongs) and the \texttt{SymbolSupervisor}:

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_20_01_current_hierarchy} \end{center}

There are multiple benefits of simplifying the supervision hierarchy, and we will look at them closely as we refactor the code - let's get to it.

\section{Simplifying the Naive supervision tree}\label{simplifying-the-naive-supervision-tree}

Starting from the top of the tree, the first module we need to update will be the \texttt{Naive.DynamicSymbolSupervisor} module.

\subsection{\texorpdfstring{The \texttt{Naive.DynamicTraderSupervisor} module}{The Naive.DynamicTraderSupervisor module}}\label{the-naive.dynamictradersupervisor-module}

The filename needs to be updated to \texttt{dynamic\_trader\_supervisor.ex} and the module name to \texttt{Naive.DynamicTraderSupervisor}.

Next, there's the \texttt{@registry} attribute that we will rename to \texttt{:naive\_traders}.

Finally, update the alias to the \texttt{Naive.SymbolSupervisor} to the \texttt{Naive.Trader} and use it inside the \texttt{start\_child/1} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_trader\_supervisor.ex}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader} 
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ start\_child}\FunctionTok{(}\NormalTok{args}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Trader}\NormalTok{, args}\FunctionTok{\}}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{The \texttt{Naive} module}{The Naive module}}\label{the-naive-module}

The \texttt{Naive} module heavily depends on the \texttt{Naive.DynamicSymbolSupervisor}(now called the

\texttt{Naive.DynamicTraderSupervisor}), we need to update all the references to it:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive.ex}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicTraderSupervisor}
  \OperatorTok{...}
  \OperatorTok{|\textgreater{}} \ConstantTok{DynamicTraderSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{()}
  \OperatorTok{...}
  \OperatorTok{|\textgreater{}} \ConstantTok{DynamicTraderSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{()}
  \OperatorTok{...}
  \OperatorTok{|\textgreater{}} \ConstantTok{DynamicTraderSupervisor}\OperatorTok{.}\NormalTok{shutdown\_worker}\FunctionTok{()}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{The \texttt{Naive.Supervisor} module}{The Naive.Supervisor module}}\label{the-naive.supervisor-module}

The \texttt{Naive.Supervisor} supervises the \texttt{Naive.DynamicSymbolSupervisor}(now called the

\texttt{Naive.DynamicTraderSupervisor}) and the registry that stores the traders' PIDs - we need to update both:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/supervisor.ex}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicTraderSupervisor} \CommentTok{\# \textless{}= updated}

  \OtherTok{@registry} \VariableTok{:naive\_traders} \CommentTok{\# \textless{}= updated}
  \OperatorTok{...}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Registry}\NormalTok{, }\OtherTok{[}\VariableTok{keys:} \VariableTok{:unique}\NormalTok{, }\VariableTok{name:} \OtherTok{@registry]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{DynamicTradersSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= updated}
      \FunctionTok{\{}\ConstantTok{Task}\NormalTok{,}
       \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
         \ConstantTok{DynamicTradersSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{()} \CommentTok{\# \textless{}= updated}
       \KeywordTok{end}\FunctionTok{\}}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{The \texttt{Naive.Trader} module}{The Naive.Trader module}}\label{the-naive.trader-module}

The final module to be updated will be the \texttt{Naive.Trader}. It needs to register process' PID inside the Registry:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \OtherTok{@registry} \VariableTok{:naive\_traders} \CommentTok{\# \textless{}= added}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{\%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{state}\OperatorTok{.}\NormalTok{symbol}\FunctionTok{)} \CommentTok{\# \textless{}= updated}

    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
\NormalTok{      state,}
      \VariableTok{name:}\NormalTok{ via\_tuple}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}  \CommentTok{\# \textless{}= updated}
    \FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ via\_tuple}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:via}\NormalTok{, }\ConstantTok{Registry}\NormalTok{, }\FunctionTok{\{}\OtherTok{@registry}\NormalTok{, symbol}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That finishes the changes to the supervision tree - the \texttt{Naive.Leader} and the \texttt{Naive.SymbolSupervisor} aren't used anymore. At this moment, our codebase won't work as we need to retrofit the functionality that the \texttt{Naive.Leader} was offering into our \texttt{Naive.Trader} and \texttt{Naive.Strategy} modules, which we will focus on in the next section.

\section{Supporting multiple positions}\label{supporting-multiple-positions}

The current \texttt{State} struct inside the \texttt{Naive.Trader} was geared toward a single trade cycle. As we now need to handle multiple positions inside a single \texttt{Trader} process, we will need to update this struct. We will start by moving the current \texttt{State} struct from the \texttt{Naive.Trader} into the \texttt{Naive.Strategy} and renaming it to \texttt{Position}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy} \KeywordTok{do}
  \OperatorTok{...}
  \KeywordTok{defmodule} \ConstantTok{Position} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}
    \CommentTok{\# keys copied from \textasciigrave{}Naive.Trader.State\textasciigrave{} struct}
    \OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}
    \CommentTok{\# keys copied from \textasciigrave{}Naive.Trader.State\textasciigrave{} struct}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This will break all the references to \texttt{Naive.Trader.State} inside the \texttt{Naive.Strategy}, which we need to update to \texttt{Position}(and remove the alias of \texttt{Naive.Trader.State}):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ execute}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, \%}\ConstantTok{Position}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ position }\KeywordTok{do}
\NormalTok{    generate\_decision}\FunctionTok{(}\NormalTok{trade\_event, position}\FunctionTok{)}
    \OperatorTok{|\textgreater{}}\NormalTok{ execute\_decision}\FunctionTok{(}\NormalTok{position}\FunctionTok{)}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \OperatorTok{...}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{} \CommentTok{\# \textless{}= in all 8 clauses}
        \OperatorTok{...}

  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
    \FunctionTok{\{}\OperatorTok{....} \CommentTok{\# decision \},}
\NormalTok{    \%}\ConstantTok{Position}\FunctionTok{\{} \CommentTok{\# \textless{}= updated}
      \OperatorTok{...}
    \FunctionTok{\}} \OperatorTok{=}\NormalTok{ position }\CommentTok{\# \textless{}= updated}
  \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    new\_position }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{position }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ order}\FunctionTok{\}} \CommentTok{\# \textless{}= updated}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_position}\FunctionTok{)} \CommentTok{\# \textless{}= updated}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_position}\FunctionTok{\}} \CommentTok{\# \textless{}\^{}= similar changes in all execute\_decision}
\end{Highlighting}
\end{Shaded}

We will ignore the fact that we are still calling the \texttt{@leader} and still dealing with a single position(inside the strategy) - we will fix that in the following section. One step at a time ;)

As we are already changing strategy to work with positions, we will update all the logger messages:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \FunctionTok{\{}\VariableTok{:place\_buy\_order}\NormalTok{, price, quantity}\FunctionTok{\}}\NormalTok{,}
         \OperatorTok{...}
  \FunctionTok{)} \KeywordTok{do}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"Placing a BUY order @ }\OtherTok{\#\{}\NormalTok{price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)} \CommentTok{\# \^{} updated message}
  \OperatorTok{...}

    \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \FunctionTok{\{}\VariableTok{:place\_sell\_order}\NormalTok{, sell\_price}\FunctionTok{\}}\NormalTok{,}
         \OperatorTok{...}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}
      \StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): The BUY order is now filled. "} \OperatorTok{\textless{}\textgreater{}}
        \StringTok{"Placing a SELL order @ }\OtherTok{\#\{}\NormalTok{sell\_price}\OtherTok{\}}\StringTok{, quantity: }\OtherTok{\#\{}\NormalTok{quantity}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)} \CommentTok{\# \^{} updated message}
    \OperatorTok{...}

  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:fetch\_buy\_order}\NormalTok{,}
         \OperatorTok{...}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): The BUY order is now partially filled"}\FunctionTok{)}
    \OperatorTok{...} \CommentTok{\# \^{}\^{}\^{} updated message}

  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:exit}\NormalTok{,}
         \OperatorTok{...}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): Trade cycle finished"}\FunctionTok{)}
    \OperatorTok{...} \CommentTok{\# \^{}\^{}\^{} updated message}

  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:fetch\_sell\_order}\NormalTok{,}
         \OperatorTok{...}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): The SELL order is now partially filled"}\FunctionTok{)}
     \OperatorTok{...} \CommentTok{\# \^{}\^{}\^{} updated message}

  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:rebuy}\NormalTok{,}
         \OperatorTok{...}
       \FunctionTok{)} \KeywordTok{do}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): Rebuy triggered"}\FunctionTok{)}
     \OperatorTok{...} \CommentTok{\# \^{}\^{}\^{} updated message}
\end{Highlighting}
\end{Shaded}

Our code is still far from working, but we are incrementally updating it to work with multiple positions.

\subsection{Initialization}\label{initialization}

At this moment, the \texttt{Naive.Trader} expects the \texttt{state} to be injected on start (using the \texttt{start\_link/1} function). We were able to do that because the \texttt{Naive.Leader} was fetching the settings and building the fresh trader state.

First, let's update the \texttt{State} of the \texttt{Naive.Trader} - it will now hold the symbol's settings(previously held in the leader) and list of positions(list of the \texttt{Naive.Strategy.Position} structs):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{defmodule} \ConstantTok{State} \KeywordTok{do}
    \OtherTok{@enforce\_keys} \OtherTok{[}\VariableTok{:settings}\NormalTok{, }\VariableTok{:positions}\OtherTok{]}
    \KeywordTok{defstruct} \OtherTok{[}\VariableTok{:settings}\NormalTok{, }\VariableTok{positions:} \OtherTok{[]]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we need to update the \texttt{start\_link/1} and \texttt{init/1} functions as well as add the \texttt{handle\_continue/2} callback to fetch settings and store them together with an initial position in the state:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
   \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}
   \OperatorTok{...}

  \KeywordTok{def}\NormalTok{ start\_link}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= now expecting symbol}
\NormalTok{    symbol }\OperatorTok{=} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \CommentTok{\# \textless{}= updated}

    \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{start\_link}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
\NormalTok{      symbol,   }\CommentTok{\# \textless{}= updated}
      \VariableTok{name:}\NormalTok{ via\_tuple}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
    \FunctionTok{)}
    \OperatorTok{...}

  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= updated}
    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Initializing new trader for }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)} \CommentTok{\# \textless{}= updated}

    \OtherTok{@pubsub\_client}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"TRADE\_EVENTS:}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}
    \FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\ConstantTok{nil}\NormalTok{, }\FunctionTok{\{}\VariableTok{:continue}\NormalTok{, }\FunctionTok{\{}\VariableTok{:start\_position}\NormalTok{, symbol}\FunctionTok{\}\}\}} \CommentTok{\# \textless{}= updated}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_continue}\FunctionTok{(\{}\VariableTok{:start\_position}\NormalTok{, symbol}\FunctionTok{\}}\NormalTok{, \_state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    settings }\OperatorTok{=} \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
\NormalTok{    positions }\OperatorTok{=} \OtherTok{[}\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_fresh\_position}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)}\OtherTok{]}

    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\ConstantTok{State}\FunctionTok{\{}\VariableTok{settings:}\NormalTok{ settings, }\VariableTok{positions:}\NormalTok{ positions}\FunctionTok{\}\}}
  \KeywordTok{end} \CommentTok{\# \^{}\^{}\^{} new function/callback}
\end{Highlighting}
\end{Shaded}

As the \texttt{Naive.Trader} starts, it returns the \texttt{\{:continue,\ ...\}} tuple from the \texttt{init/1} function. This will cause the \texttt{handle\_continue/2} callback to be called asynchronously. Inside it, we fetch settings and add a single fresh position to the list of positions - both stored in Trader's state.

Both functions inside the \texttt{handle\_continue/2} callback previously were part of the \texttt{Naive.Leader} - we need to move them across to the \texttt{Naive.Strategy}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Settings}
  \OperatorTok{...}
  \OtherTok{@repo} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:repo}\FunctionTok{)}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    exchange\_info }\OperatorTok{=} \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
\NormalTok{    db\_settings }\OperatorTok{=} \OtherTok{@repo}\OperatorTok{.}\NormalTok{get\_by!}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)}

\NormalTok{    merge\_filters\_into\_settings}\FunctionTok{(}\NormalTok{exchange\_info, db\_settings, symbol}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ merge\_filters\_into\_settings}\FunctionTok{(}\NormalTok{exchange\_info, db\_settings, symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol\_filters }\OperatorTok{=}
\NormalTok{      exchange\_info}
      \OperatorTok{|\textgreater{}}\NormalTok{ elem}\FunctionTok{(}\DecValTok{1}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\VariableTok{:symbols}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]} \OperatorTok{==}\NormalTok{ symbol}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"filters"}\FunctionTok{)}

\NormalTok{    tick\_size }\OperatorTok{=}
\NormalTok{      symbol\_filters}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"PRICE\_FILTER"}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"tickSize"}\FunctionTok{)}

\NormalTok{    step\_size }\OperatorTok{=}
\NormalTok{      symbol\_filters}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"LOT\_SIZE"}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"stepSize"}\FunctionTok{)}

    \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}
\NormalTok{      \%}\FunctionTok{\{}
        \VariableTok{tick\_size:}\NormalTok{ tick\_size,}
        \VariableTok{step\_size:}\NormalTok{ step\_size}
      \FunctionTok{\}}\NormalTok{,}
\NormalTok{      db\_settings }\OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}
    \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ generate\_fresh\_position}\FunctionTok{(}\NormalTok{settings, id \textbackslash{}\textbackslash{} }\VariableTok{:os}\OperatorTok{.}\NormalTok{system\_time}\FunctionTok{(}\VariableTok{:millisecond}\FunctionTok{))} \KeywordTok{do}
\NormalTok{    \%}\FunctionTok{\{}
\NormalTok{      struct}\FunctionTok{(}\ConstantTok{Position}\NormalTok{, settings}\FunctionTok{)}
      \OperatorTok{|} \VariableTok{id:}\NormalTok{ id,}
        \VariableTok{budget:}\NormalTok{ D}\OperatorTok{.}\NormalTok{div}\FunctionTok{(}\NormalTok{settings}\OperatorTok{.}\NormalTok{budget, settings}\OperatorTok{.}\NormalTok{chunks}\FunctionTok{)}\NormalTok{,}
        \VariableTok{rebuy\_notified:} \ConstantTok{false}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Inside the above code, we modified the \texttt{fetch\_symbol\_settings/1} function to fetch settings from binance and DB first and then progress with the ``pure'' part. This update allows us to test most of the logic easily without using mocks.

The \texttt{generate\_fresh\_position/2} was previously called \texttt{fresh\_trader\_state/1} inside the \texttt{Naive.Leader}. It had an \texttt{id} assigned inside the function based on the current system time. That made it a bit more difficult to test as we don't know what should we expect there as a value. By moving the \texttt{id} to the arguments and assigning the current time there, we are now able to test it by passing our dummy value.

We are now using \texttt{@repo} inside the \texttt{Naive.Strategy} so we need to add it to configuration files(including test configuration):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \OperatorTok{...}
  \VariableTok{repo:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/test.exs}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \OperatorTok{...}
  \VariableTok{repo:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{RepoMock}\NormalTok{,}
\end{Highlighting}
\end{Shaded}

\subsection{Parallelising the strategy}\label{parallelising-the-strategy}

We can now move on to the strategy, but first, let's update the \texttt{Naive.Trader} to pass positions and settings separately:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, \%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{execute}\FunctionTok{(}\NormalTok{trade\_event, state}\OperatorTok{.}\NormalTok{positions, state}\OperatorTok{.}\NormalTok{settings}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= updated}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, updated\_positions}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}} \CommentTok{\# \textless{}= updated}
        \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{positions:}\NormalTok{ updated\_positions}\FunctionTok{\}\}} \CommentTok{\# \textless{}= updated}

      \VariableTok{:exit} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:stop}\NormalTok{, }\VariableTok{:normal}\NormalTok{, state}\FunctionTok{\}}
    \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We need all the \texttt{positions} to iterate through them, deciding and executing appropriate actions. The \texttt{settings} will be used inside the strategy later, but we will pass it on now to avoid going back and forward later.

Additionally, we updated the \texttt{case} match to expect a list of updated positions which we will assign to the \texttt{Trader}'s state.

Now we can modify the \texttt{Naive.Strategy} to handle multiple positions:

\begin{Shaded}
\begin{Highlighting}[]
   \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ execute}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, positions, settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    generate\_decisions}\FunctionTok{(}\NormalTok{positions, }\OtherTok{[]}\NormalTok{, trade\_event, settings}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\KeywordTok{fn} \FunctionTok{\{}\NormalTok{decision, position}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
      \ConstantTok{Task}\OperatorTok{.}\NormalTok{async}\FunctionTok{(}\KeywordTok{fn} \OperatorTok{{-}\textgreater{}}\NormalTok{ execute\_decision}\FunctionTok{(}\NormalTok{decision, position, settings}\FunctionTok{)} \KeywordTok{end}\FunctionTok{)}
    \KeywordTok{end}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Task}\OperatorTok{.}\NormalTok{await\_many}\FunctionTok{()}
    \OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\OperatorTok{\&}\NormalTok{parse\_results}\OperatorTok{/}\DecValTok{1}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

We need to write most of the functions used above, but we can already see the idea. We will map each of the decisions that we generate to async tasks that execute them. Next, we wait for all of them to finish and parse the results.

First, we are calling a new function \texttt{generate\_decisions/4}, which is a recursive function on top of the existing \texttt{generate\_decision/2}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decisions}\FunctionTok{(}\OtherTok{[]}\NormalTok{, generated\_results, \_trade\_event, \_settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    generated\_results}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ generate\_decisions}\FunctionTok{(}\OtherTok{[}\NormalTok{position }\OperatorTok{|}\NormalTok{ rest}\OtherTok{]} \OperatorTok{=}\NormalTok{ positions, generated\_results, trade\_event, settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    current\_positions }\OperatorTok{=}\NormalTok{ positions }\OperatorTok{++} \FunctionTok{(}\NormalTok{generated\_results }\OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\NormalTok{elem}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\DecValTok{0}\FunctionTok{)))}

    \KeywordTok{case}\NormalTok{ generate\_decision}\FunctionTok{(}\NormalTok{trade\_event, position, current\_positions, settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      decision }\OperatorTok{{-}\textgreater{}}
\NormalTok{        generate\_decisions}\FunctionTok{(}
\NormalTok{          rest,}
          \OtherTok{[}\FunctionTok{\{}\NormalTok{decision, position}\FunctionTok{\}} \OperatorTok{|}\NormalTok{ generated\_results}\OtherTok{]}\NormalTok{,}
\NormalTok{          trade\_event,}
\NormalTok{          settings}
        \FunctionTok{)}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment, the \texttt{generate\_decisions/4} can look like overengineered \texttt{Enum.map/2} function, but we are actually preparing the ground for the consequent updates later in this chapter(to get the rest of the functionality running).

It's important to note that we are now passing four arguments into the \texttt{generate\_decision} function - we added \texttt{current\_positions} and \texttt{settings} - those will be required in the further updates as it was mentioned above. At this moment though, we will update \textbf{all} the \texttt{generate\_decision/2} clauses to include two additional arguments:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}\OperatorTok{...}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{}
          \OperatorTok{...}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_positions, }\CommentTok{\# \textless{}= add this 8 times}
\NormalTok{       \_settings    }\CommentTok{\# \textless{}= add this 8 times}
      \FunctionTok{)} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

\newpage

Now back to the main \texttt{execute/3} function where we are calling \texttt{execute\_decision/3}, which we need to update as well(\textbf{all} clauses):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \FunctionTok{\{}\OperatorTok{...}\FunctionTok{\}}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{Position}\FunctionTok{\{}
           \OperatorTok{...}
         \FunctionTok{\}} \OperatorTok{=}\NormalTok{ position,}
\NormalTok{         \_settings  }\CommentTok{\# \textless{}= added 7 times}
       \FunctionTok{)} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

The final function that gets called from the \texttt{execute/3} function is \texttt{parse\_results/1}, which will aggregate all the results into a single tuple:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ parse\_results}\FunctionTok{(}\OtherTok{[}\NormalTok{\_ }\OperatorTok{|}\NormalTok{ \_}\OtherTok{]} \OperatorTok{=}\NormalTok{ results}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    results}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\KeywordTok{fn} \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_position}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}\NormalTok{ new\_position }\KeywordTok{end}\FunctionTok{)}
    \OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\OperatorTok{\&}\DecValTok{1}\FunctionTok{\})}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment, we should be able to run our code:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{21:29:17.998} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Starting streaming XRPUSDT trade events}
\ExtensionTok{...}
\ExtensionTok{21:29:21.037} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{XRPUSDT/1651696014179}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Placing a BUY order @ 0.64010000,}
\ExtensionTok{quantity:}\NormalTok{ 31.00000000}
\ExtensionTok{21:29:21.037} \PreprocessorTok{[}\SpecialStringTok{error}\PreprocessorTok{]}\NormalTok{ Task }\CommentTok{\#PID\textless{}0.10293.0\textgreater{} started from \#PID\textless{}0.480.0\textgreater{} terminating}
\ExtensionTok{**} \ErrorTok{(}\ExtensionTok{stop}\KeywordTok{)} \ExtensionTok{exited}\NormalTok{ in: GenServer.call}\ErrorTok{(}\ExtensionTok{:}\StringTok{"Elixir.Naive.Leader{-}XRPUSDT"}\ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

So we have a trader that start and places a buy order but then it tries to update the leader with it's new state - we can update the \texttt{execute\_decision/3} function to drop the updates(in \textbf{all} of the clauses):

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
    \OperatorTok{...}
       \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \CommentTok{\# convert the below:}
\NormalTok{    new\_position }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}\NormalTok{position }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ order}\FunctionTok{\}}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:trader\_state\_updated}\NormalTok{, new\_position}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_position}\FunctionTok{\}}
    \CommentTok{\# to:}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{position }\OperatorTok{|} \VariableTok{buy\_order:}\NormalTok{ order}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Apply similar changes to all the clauses of the \texttt{execute\_decision/3} to get rid of the references to the \texttt{@leader} - remember to remove the module's attribute as well, as we won't need it anymore.

Important note - one of those references to the \texttt{@leader} will be the notification that rebuy was triggered:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
    \OtherTok{@leader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:rebuy\_triggered}\NormalTok{, new\_position}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

At this moment, remove that reference as well. We will get back to the rebuy functionality in the next section.

We can now rerun our code:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{21:59:19.836} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651697959836}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Placing a BUY order @ 2945.31000000,}
\ExtensionTok{quantity:}\NormalTok{ 0.06790000}
 \ExtensionTok{21:59:46.997} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651697959836}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ The BUY order is now partially}
 \ExtensionTok{filled}
 \ExtensionTok{21:59:46.997} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651697959836}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ The BUY order is now filled.}
 \ExtensionTok{Placing}\NormalTok{ a SELL order @ 2947.66000000, quantity: 0.06790000}
 \ExtensionTok{22:00:21.631} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651697959836}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ The SELL order is now partially}
 \ExtensionTok{filled}
 \ExtensionTok{22:00:21.734} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651697959836}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Trade cycle finished}
\ExtensionTok{22:00:21.737} \PreprocessorTok{[}\SpecialStringTok{error}\PreprocessorTok{]}\NormalTok{ GenServer \{:naive\_traders, }\StringTok{"ETHUSDT"}\NormalTok{\} terminating}
\ExtensionTok{**} \ErrorTok{(}\ExtensionTok{FunctionClauseError}\KeywordTok{)} \ExtensionTok{no}\NormalTok{ function clause matching in anonymous fn/1 in}
\ExtensionTok{Naive.Strategy.parse\_results/1}
    \KeywordTok{(}\ExtensionTok{naive}\NormalTok{ 0.1.0}\KeywordTok{)} \ExtensionTok{lib/naive/strategy.ex:56:}\NormalTok{ anonymous fn}\ErrorTok{(}\ExtensionTok{:exit}\KeywordTok{)} \ErrorTok{in}
    \ExtensionTok{Naive.Strategy.parse\_results/1}
\end{Highlighting}
\end{Shaded}

We can see that our trader process can now go through the whole trade cycle, but it fails to start a new position after the first trade cycle finishes and returns \texttt{:exit}.

To fix this issue, we need to return \texttt{:finished} instead of \texttt{:exit} from the \texttt{generate\_decision/3} clause responsible for matching end of the trade cycle:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{status:} \StringTok{"FILLED"}
          \FunctionTok{\}}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_positions,}
\NormalTok{        \_settings}
      \FunctionTok{)} \KeywordTok{do}
    \VariableTok{:finished} \CommentTok{\# \textless{}= updated}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This decision will end up inside the \texttt{execute\_decision/3} where previously we were returning \texttt{:exit} atom, which was causing an error - let's move this clause to be the last clause and update its body to generate a fresh state instead of returning a dummy atom:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:finished}\NormalTok{, }\CommentTok{\# \textless{}= previously :exit; updated}
\NormalTok{         \%}\ConstantTok{Position}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol}
         \FunctionTok{\}}\NormalTok{,}
\NormalTok{         settings }\CommentTok{\# \textless{}= now used}
       \FunctionTok{)} \KeywordTok{do}
\NormalTok{    new\_position }\OperatorTok{=}\NormalTok{ generate\_fresh\_position}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)} \CommentTok{\# \textless{}= added}

    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): Trade cycle finished"}\FunctionTok{)}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_position}\FunctionTok{\}} \CommentTok{\# \textless{}= updated}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment, our trader process should be able to run across multiple trade cycles one after another:

\begin{verbatim}
$ iex -S mix
...
iex(1)> Streamer.start_streaming("ETHUSDT")
...
iex(2)> Naive.start_trading("ETHUSDT")
...
22:46:46.568 [info]  Position (ETHUSDT/1651697959836): Trade cycle finished
22:46:46.577 [info]  Position (ETHUSDT/1651697959836): Placing a BUY order @ 2945.31000000,
  quantity: 0.06790000
\end{verbatim}

This finishes direct changes related to making the trader/strategy work with multiple positions, but it lacks all the features that the \texttt{Naive.Leader} offered. We will now iterate on this code to bring that missing functionality.

\section{Retrofitting the ``shutdown'' functionality}\label{retrofitting-the-shutdown-functionality}

Previously, the shutdown logic was scattered around in multiple places inside the \texttt{Naive.Leader}, for example, when the rebuy was triggered - making sure that new Trader processes won't get started in the ``shutdown'' state.

Now, we have an opportunity to make the shutdown functionality part of our strategy.

We will start by modifying the \texttt{DynamicTraderSupervisor} where we will update the \texttt{shutdown\_worker/1} function to call the \texttt{Naive.Trader} instead of the \texttt{Naive.Leader}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_trader\_supervisor.ex}
  \KeywordTok{def}\NormalTok{ shutdown\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Shutdown of trading on }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{ initialized"}\FunctionTok{)}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"shutdown"}\FunctionTok{)}
    \ConstantTok{Trader}\OperatorTok{.}\NormalTok{notify}\FunctionTok{(}\VariableTok{:settings\_updated}\NormalTok{, settings}\FunctionTok{)} \CommentTok{\# \textless{}= updated}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now, the Trader will handle updating the settings, which we will add next, but before we do that, we should move the \texttt{update\_status/2} function into the \texttt{Naive.Strategy} as it will be used from both the \texttt{DynamicTraderSupervisor} and the \texttt{Naive.Strategy}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{symbol, status}\FunctionTok{)} \CommentTok{\# \textless{}= updated to public}
      \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
    \OtherTok{@repo}\OperatorTok{.}\NormalTok{get\_by}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)} \CommentTok{\# \textless{}= updated to use @repo}
    \OperatorTok{|\textgreater{}} \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Changeset}\OperatorTok{.}\NormalTok{change}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\VariableTok{status:}\NormalTok{ status}\FunctionTok{\})}
    \OperatorTok{|\textgreater{}} \OtherTok{@repo}\OperatorTok{.}\NormalTok{update}\FunctionTok{()} \CommentTok{\# \textless{}= updated to use @repo}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we need to update the \texttt{DynamicTraderSupervisor} module to call the \texttt{update\_status/2} from the \texttt{Naive.Strategy} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/dynamic\_trader\_supervisor.ex}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}
  \OperatorTok{...}

  \KeywordTok{def}\NormalTok{ start\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"on"}\FunctionTok{)} \CommentTok{\# \textless{}= updated}
    \OperatorTok{..}

  \KeywordTok{def}\NormalTok{ stop\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)} \CommentTok{\# \textless{}= updated}
    \OperatorTok{...}

  \KeywordTok{def}\NormalTok{ shutdown\_worker}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, settings}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\NormalTok{symbol, }\StringTok{"shutdown"}\FunctionTok{)} \CommentTok{\# \textless{}= updated}
\end{Highlighting}
\end{Shaded}

\subsection{Handling updated settings}\label{handling-updated-settings}

We can now move on to the \texttt{Naive.Trader} module, where we need to add a new \texttt{notify/2} interface function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ notify}\FunctionTok{(}\VariableTok{:settings\_updated}\NormalTok{, settings}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    call\_trader}\FunctionTok{(}\NormalTok{settings}\OperatorTok{.}\NormalTok{symbol, }\FunctionTok{\{}\VariableTok{:update\_settings}\NormalTok{, settings}\FunctionTok{\})}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ call\_trader}\FunctionTok{(}\NormalTok{symbol, data}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Registry}\OperatorTok{.}\NormalTok{lookup}\FunctionTok{(}\OtherTok{@registry}\NormalTok{, symbol}\FunctionTok{)} \KeywordTok{do}
      \OtherTok{[}\FunctionTok{\{}\NormalTok{pid, \_}\FunctionTok{\}}\OtherTok{]} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{GenServer}\OperatorTok{.}\NormalTok{call}\FunctionTok{(}
\NormalTok{          pid,}
\NormalTok{          data}
        \FunctionTok{)}

\NormalTok{      \_ }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{warning}\FunctionTok{(}\StringTok{"Unable to locate trader process assigned to }\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:error}\NormalTok{, }\VariableTok{:unable\_to\_locate\_trader}\FunctionTok{\}}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The \texttt{notify/2} function acts as a part of the public interface of the \texttt{Naive.Trader} module. It uses the \texttt{call\_trader/2} helper function to abstract away looking up the \texttt{Trader} process from the \texttt{Registry} and making a \texttt{GenServer.call}. Besides the ``looking up'' part being an implementation detail that should be abstracted, we will also need to look up traders' PIDs to provide other functionalities in the upcoming sections.

As we are making a call to the trader process, we need to add a callback:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:update\_settings}\NormalTok{, new\_settings}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_,}
\NormalTok{        state}
      \FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, }\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{state }\OperatorTok{|} \VariableTok{settings:}\NormalTok{ new\_settings}\FunctionTok{\}\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Updating the \texttt{Naive.Strategy} to honour the ``shutdown'' state}{Updating the Naive.Strategy to honour the ``shutdown'' state}}\label{updating-the-naive.strategy-to-honour-the-shutdown-state}

We updated all of the modules to update the \texttt{settings} inside the \texttt{\%State\{\}} of the \texttt{Trader} process. That's the first step, but now we need to modify our strategy to act appropriately.

The first step will be to update the \texttt{generate\_decision/4} clause that handles the rebuy being triggered to take under consideration the \texttt{settings.status}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{price:}\NormalTok{ current\_price}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{price:}\NormalTok{ buy\_price}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{rebuy\_interval:}\NormalTok{ rebuy\_interval,}
          \VariableTok{rebuy\_notified:} \ConstantTok{false}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_positions,}
\NormalTok{        settings }\CommentTok{\# \textless{}= updated}
      \FunctionTok{)} \KeywordTok{do}
    \ControlFlowTok{if}\NormalTok{ trigger\_rebuy?}\FunctionTok{(}\NormalTok{buy\_price, current\_price, rebuy\_interval}\FunctionTok{)} \OperatorTok{\&\&}
\NormalTok{         settings}\OperatorTok{.}\NormalTok{status}\OperatorTok{ !=} \StringTok{"shutdown"} \KeywordTok{do} \CommentTok{\# \textless{}= updated}
      \VariableTok{:rebuy}
    \ControlFlowTok{else}
      \VariableTok{:skip}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Another clause that we need to update is the one responsible for matching end of the trading cycle:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{status:} \StringTok{"FILLED"}
          \FunctionTok{\}}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_positions,}
\NormalTok{        settings }\CommentTok{\# \textless{}= updated}
      \FunctionTok{)} \KeywordTok{do}
    \ControlFlowTok{if}\NormalTok{ settings}\OperatorTok{.}\NormalTok{status}\OperatorTok{ !=} \StringTok{"shutdown"} \KeywordTok{do} \CommentTok{\# \textless{}= updated}
      \VariableTok{:finished}
    \ControlFlowTok{else}
      \VariableTok{:exit} \CommentTok{\# \textless{}= new decision}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we added a new \texttt{:exit} decision that we need to handle inside the \texttt{generate\_decisions/4} - it needs to remove this decision from the list of generated decisions:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decisions}\FunctionTok{(}\OtherTok{[}\NormalTok{position }\OperatorTok{|}\NormalTok{ rest}\OtherTok{]} \OperatorTok{=}\NormalTok{ positions, generated\_results, trade\_event, settings}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \KeywordTok{case}\NormalTok{ generate\_decision}\FunctionTok{(}\NormalTok{trade\_event, position, current\_positions, settings}\FunctionTok{)} \KeywordTok{do}
      \VariableTok{:exit} \OperatorTok{{-}\textgreater{}}
\NormalTok{        generate\_decisions}\FunctionTok{(}\NormalTok{rest, generated\_results, trade\_event, settings}\FunctionTok{)}

\NormalTok{      decision }\OperatorTok{{-}\textgreater{}} \OperatorTok{...}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Inside the recursive function, we are skipping all the positions that ended up with the \texttt{:exit} decisions. This will slowly cause the list of positions to drain to an empty list, which will cause the \texttt{parse\_results/1} function to fail(as it expects non-empty list). We will add a new first clause to match the empty list of positions and return the \texttt{:exit} atom:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ parse\_results}\FunctionTok{(}\OtherTok{[]}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= added clause}
    \VariableTok{:exit}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ parse\_results}\FunctionTok{(}\OtherTok{[}\NormalTok{\_ }\OperatorTok{|}\NormalTok{ \_}\OtherTok{]} \OperatorTok{=}\NormalTok{ results}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

In the end, the \texttt{:exit} atom will cause the \texttt{Naive.Trader} module to stop the process.

The final step will be to update the \texttt{Naive.Trader} to log a message and update the status to \texttt{"off"} before exiting the process:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, \%}\ConstantTok{State}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ state}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \KeywordTok{case} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{execute}\FunctionTok{(}\NormalTok{trade\_event, state}\OperatorTok{.}\NormalTok{positions, state}\OperatorTok{.}\NormalTok{settings}\FunctionTok{)} \KeywordTok{do}
      \OperatorTok{...}
      \VariableTok{:exit} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \_settings}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol, }\StringTok{"off"}\FunctionTok{)}
        \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Trading for }\OtherTok{\#\{}\NormalTok{trade\_event}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{ stopped"}\FunctionTok{)}
        \FunctionTok{\{}\VariableTok{:stop}\NormalTok{, }\VariableTok{:normal}\NormalTok{, state}\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

We can test this by running the following:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{4}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{4}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.shutdown\_trading}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{22:35:58.929} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Shutdown of trading on ETHUSDT initialized}
\ExtensionTok{23:05:40.068} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651788334058}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ The SELL order is now partially filled}
\ExtensionTok{23:05:40.123} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Trading for ETHUSDT stopped}
\end{Highlighting}
\end{Shaded}

That finishes the shutdown functionality. As mentioned previously, one after another, positions will complete their trading cycles, and the whole process will exit at the end.

\section{Updating the Strategy to handle rebuys}\label{updating-the-strategy-to-handle-rebuys}

Previously, both the \texttt{Trader} and the \texttt{Leader} were involved in the rebuy functionality. As now we removed the \texttt{Leader}, it's an excellent opportunity to move as much as possible of that logic into our strategy.

We will start by updating the \texttt{generate\_decision/4} clause responsible for matching the rebuy scenario. We will take into consideration the number of currently open positions(this check was previously done inside the \texttt{Naive.Leader}):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decision}\FunctionTok{(}
\NormalTok{        \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
          \VariableTok{price:}\NormalTok{ current\_price}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
            \VariableTok{price:}\NormalTok{ buy\_price}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{rebuy\_interval:}\NormalTok{ rebuy\_interval,}
          \VariableTok{rebuy\_notified:} \ConstantTok{false}
        \FunctionTok{\}}\NormalTok{,}
\NormalTok{        positions, }\CommentTok{\# \textless{}= updated}
\NormalTok{        settings}
      \FunctionTok{)} \KeywordTok{do}
    \ControlFlowTok{if}\NormalTok{ trigger\_rebuy?}\FunctionTok{(}\NormalTok{buy\_price, current\_price, rebuy\_interval}\FunctionTok{)} \OperatorTok{\&\&}
\NormalTok{         settings}\OperatorTok{.}\NormalTok{status}\OperatorTok{ !=} \StringTok{"shutdown"} \OperatorTok{\&\&}
\NormalTok{         length}\FunctionTok{(}\NormalTok{positions}\FunctionTok{)} \OperatorTok{\textless{}}\NormalTok{ settings}\OperatorTok{.}\NormalTok{chunks }\KeywordTok{do} \CommentTok{\# \textless{}= added}
      \VariableTok{:rebuy}
    \ControlFlowTok{else}
      \VariableTok{:skip}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we need to deal with the \texttt{:rebuy} decision(previously, we removed the logic notifying the \texttt{Naive.Leader} about the rebuy being triggered).

\newpage

In case of rebuy decision we need to add a new position to the positions list which can be done by modifying the \texttt{generate\_decisions/4} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ generate\_decisions}\FunctionTok{(}\OtherTok{[}\NormalTok{position }\OperatorTok{|}\NormalTok{ rest}\OtherTok{]} \OperatorTok{=}\NormalTok{ positions, generated\_results, trade\_event, settings}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \KeywordTok{case}\NormalTok{ generate\_decision}\FunctionTok{(}\NormalTok{trade\_event, position, current\_positions, settings}\FunctionTok{)} \KeywordTok{do}
      \VariableTok{:exit} \OperatorTok{{-}\textgreater{}} \OperatorTok{...}
      \VariableTok{:rebuy} \OperatorTok{{-}\textgreater{}}
\NormalTok{        generate\_decisions}\FunctionTok{(}
\NormalTok{          rest,}
          \OtherTok{[}\FunctionTok{\{}\VariableTok{:skip}\NormalTok{, \%}\FunctionTok{\{}\NormalTok{position }\OperatorTok{|} \VariableTok{rebuy\_notified:} \ConstantTok{true}\FunctionTok{\}\}}\NormalTok{, }\FunctionTok{\{}\VariableTok{:rebuy}\NormalTok{, position}\FunctionTok{\}}\OtherTok{]} \OperatorTok{++}\NormalTok{ generated\_results,}
\NormalTok{          trade\_event,}
\NormalTok{          settings}
        \FunctionTok{)} \CommentTok{\# \^{}\^{}\^{}\^{}\^{} added}
\NormalTok{      decision }\OperatorTok{{-}\textgreater{}} \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

In the case of the \texttt{:rebuy} decision, we are updating the \texttt{rebuy\_notified} of the position that triggered it, as well as adding another position to the list with the \texttt{:rebuy} decision(it's the same position that triggered rebuy but we will ignore it further down the line).

The final step will be to update the \texttt{execute\_decision/3} clause that matches the \texttt{:rebuy} decision to

\texttt{generate\_fresh\_position/1}, log and return that newly created position:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ execute\_decision}\FunctionTok{(}
         \VariableTok{:rebuy}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{Position}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ id,}
           \VariableTok{symbol:}\NormalTok{ symbol}
         \FunctionTok{\}}\NormalTok{, }\CommentTok{\# \textless{}= position removed}
\NormalTok{         settings }\CommentTok{\# \textless{}= updated}
       \FunctionTok{)} \KeywordTok{do}
\NormalTok{    new\_position }\OperatorTok{=}\NormalTok{ generate\_fresh\_position}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)} \CommentTok{\# \textless{}= updated}

    \OtherTok{@logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Position (}\OtherTok{\#\{}\NormalTok{symbol}\OtherTok{\}}\StringTok{/}\OtherTok{\#\{}\NormalTok{id}\OtherTok{\}}\StringTok{): Rebuy triggered. Starting new position"}\FunctionTok{)} \CommentTok{\# \textless{}= updated}

    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_position}\FunctionTok{\}} \CommentTok{\# \textless{}= updated}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We updated the whole function body as now it deals with initialising a new position instead of just flipping the \texttt{rebuy\_triggered} flag inside the original position.

\newpage

We can now run the strategy to confirm that rebuy starts new positions:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{18:00:29.872} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651856406828}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Rebuy triggered. Starting new position}
\ExtensionTok{18:00:29.880} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1651856429871}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Placing a BUY order @ 13.39510000,}
  \ExtensionTok{quantity:}\NormalTok{ 14.93000000}
\end{Highlighting}
\end{Shaded}

The above shows that a single buy position can trigger rebuy, starting a new position immediately placing another buy order.

At this moment the integration tests should already be passing, but first, we need to fix the \texttt{Naive.TraderTest} a bit to make the test code compile:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive/trader\_test.exs}
  \KeywordTok{defp}\NormalTok{ dummy\_trader\_state}\FunctionTok{()} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Position}\FunctionTok{\{} \CommentTok{\# \textless{}= updated}
\end{Highlighting}
\end{Shaded}

That's just the bare minimum as this test won't run, but Elixir would not be able to find the \texttt{:id} attribute inside the \texttt{State} struct at the compilation time. We can now run the integration tests:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ MIX\_ENV=integration mix test.integration}
\ExtensionTok{...}
\ExtensionTok{Finished}\NormalTok{ in 7.2 seconds }\ErrorTok{(}\ExtensionTok{0.00s}\NormalTok{ async, 7.2s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

Yay! We reached the point where our strategy took over all the functionality that the \texttt{Naive.Leader} provided.

\section{Fetching active positions}\label{fetching-active-positions}

Previously, we were able to figure out the number of currently open positions by looking at the supervision tree, but now there's just a single trader process with possibly multiple open positions.

To aid observability of the state of our trading on the symbols, we will add an interface that can be used to fetch the currently open positions of the trader process.

We will start with the interface itself. It will take a symbol to be able to find the trader responsible for it:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive.ex}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ get\_positions}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol}
    \OperatorTok{|\textgreater{}} \ConstantTok{String}\OperatorTok{.}\NormalTok{upcase}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{Trader}\OperatorTok{.}\NormalTok{get\_positions}\FunctionTok{()}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now the trader's interface function will forward the symbol to the \texttt{GenServer.call/2} to the actual process \texttt{Naive.Trader} process responsible for trading on that symbol:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ get\_positions}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    call\_trader}\FunctionTok{(}\NormalTok{symbol, }\FunctionTok{\{}\VariableTok{:get\_positions}\NormalTok{, symbol}\FunctionTok{\})}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we need to look up the PID of the trader process in the \texttt{Registry}, we can use the same \texttt{call\_trader/2} helper as in the case of the \texttt{notify/2} function.

The message will get sent to the \texttt{Trader} process, where we need to add a callback that will return all the current positions:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:get\_positions}\NormalTok{, \_symbol}\FunctionTok{\}}\NormalTok{,}
\NormalTok{        \_,}
\NormalTok{        state}
      \FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:reply}\NormalTok{, state}\OperatorTok{.}\NormalTok{positions, state}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

We can now test fetching currently open positions by running:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{3}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.get\_positions}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\BuiltInTok{[}
\NormalTok{  \%Naive.Strategy.Position\{}
\NormalTok{    ...}
\NormalTok{  \},}
  \ErrorTok{\%Naive.Strategy.Position\{}
    \ErrorTok{...}
  \ErrorTok{\},}
  \ErrorTok{...}
\BuiltInTok{]}  
\end{Highlighting}
\end{Shaded}

We can see that we now have a better overview of what's happening. Previously we needed to go to the database as the state was shared between multiple Trader processes. Now everything is in one place, which we could leverage to load the initial state for some frontend dashboards(subsequent positions' updates could be done by listening to the PubSub topic and pushing diffs to the browser via WebSocket).

\section{Tidying up}\label{tidying-up}

Let's tidy up the codebase start with removing the \texttt{/apps/naive/lib/naive/leader.ex}

and \texttt{/apps/naive/lib/naive/symbol\_supervisor.ex} as we don't need them anymore.

This will cause problems with our mocks that we need to update in the test helper:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\ConstantTok{Mox}\OperatorTok{.}\NormalTok{defmock}\FunctionTok{(}\ConstantTok{Test}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{LeaderMock}\NormalTok{, }\KeywordTok{for}\NormalTok{: }\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\FunctionTok{)} \CommentTok{\# \textless{}= remove}
\end{Highlighting}
\end{Shaded}

Our integration test will now run again and pass. Sadly that won't be the case for our unit tests. We will revisit the mocking and unit tests in the next chapter, where we will once again look into how we should structure our code to be more testable and ``mockable''.

\section{Final thoughts}\label{final-thoughts-1}

In this chapter, we gathered parts of our strategy that were spread across multiple processes and put them into the \texttt{Naive.Strategy} module. Furthermore, we made efforts to separate parts of the strategy that are pure from side-effectfull code, which we pushed to the edge. It should be visible that this way, we can cover the vast amount of logic with simple and easy to understand tests that don't require mocking or setup. In the next chapter, we will look into how we could improve the testing of the parts ``pushed to the edge''(side effects).

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_20}{GitHub}

\chapter{Layers of abstraction}\label{layers-of-abstraction}

\section{Objectives}\label{objectives-20}

\begin{itemize}
\tightlist
\item
  admitting the simplification
\item
  abstracting the exchange
\item
  mimicking the reality
\item
  swapping back to attributes
\end{itemize}

\section{Admitting the simplification}\label{admitting-the-simplification}

There comes a time when I need to admit to something that I've learned on the way as I was writing this book and was misused throughout.

When we were using the \texttt{Mox} package, we were disappointed that most packages don't provide behaviours we could use in our tests(to mock the actual implementations).

To fix that, we were creating behaviours for 3rd party packages we are using, like \texttt{Binance} or even \texttt{Ecto.Repo}. This approach felt weird, and it should, as I believe that was \textbf{not the intended usage} of the \texttt{Mox} package.

\newpage

Instead, we should introduce an additional layer(of abstraction) on top of the 3rd party modules we are using. A typical example could be abstracting dealing with an exchange to an behaviour and providing different implementations(for example, one could be wrapping the \texttt{Binance} module):

\begin{center}\includegraphics[width=1\linewidth]{images/chapter_21_01_additional_layer} \end{center}

In the example above, we will introduce a new behaviour module called \texttt{Core.Exchange} that would define the standard way to interact with any exchange. As this will be a generic \textbf{exchange} behaviour, it needs to accept and return generic structs(we will need to define those as well).

We will also create a new \texttt{Core.Exchange.Binance} module(wrapping up the \texttt{Binance} module) and update the \texttt{BinanceMock} module. Both will implement the \texttt{Core.Exchange} behaviour.

In this chapter, we will look into the intended way/scenario for using the \texttt{Mox} package, its advantages and disadvantages and go beyond and look into alternatives.

\section{Abstracting the exchange}\label{abstracting-the-exchange}

First, we will look at an intended use case for the \texttt{Mox} module, as mentioned above.

\subsection{\texorpdfstring{Defining the \texttt{Core.Exchange} behaviour}{Defining the Core.Exchange behaviour}}\label{defining-the-core.exchange-behaviour}

We will start by creating a new file \texttt{/apps/core/lib/core/exchange.ex} together with a new module inside it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/exchange.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange} \KeywordTok{do}

\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

Now, based on how we currently interact with the \texttt{Binance} module inside the \texttt{Naive.Strategy}, we can define the following callback functions:

\texttt{order\_limit\_buy/3} - almost the same as the \texttt{Binance.order\_limit\_buy/4}, just skipped the optional argument

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange.ex}
  \OtherTok{@callback}\NormalTok{ order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol :: }\ConstantTok{String}\OperatorTok{.}\NormalTok{t}\FunctionTok{()}\NormalTok{, quantity :: number}\FunctionTok{()}\NormalTok{, price :: number}\FunctionTok{())}\NormalTok{ ::}
              \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\OperatorTok{.}\NormalTok{t}\FunctionTok{()\}}
              \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, any}\FunctionTok{()\}}
\end{Highlighting}
\end{Shaded}

\texttt{order\_limit\_sell/3} - almost the same as the \texttt{Binance.order\_limit\_sell/4}, just skipped the optional argument

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange.ex}
  \OtherTok{@callback}\NormalTok{ order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol :: }\ConstantTok{String}\OperatorTok{.}\NormalTok{t}\FunctionTok{()}\NormalTok{, quantity :: number}\FunctionTok{()}\NormalTok{, price :: number}\FunctionTok{())}\NormalTok{ ::}
              \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\OperatorTok{.}\NormalTok{t}\FunctionTok{()\}}
              \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, any}\FunctionTok{()\}}
\end{Highlighting}
\end{Shaded}

\texttt{get\_order/3} - the same as the \texttt{Binance.get\_order/3}

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange.ex}
  \OtherTok{@callback}\NormalTok{ get\_order}\FunctionTok{(}
\NormalTok{              symbol :: }\ConstantTok{String}\OperatorTok{.}\NormalTok{t}\FunctionTok{()}\NormalTok{,}
\NormalTok{              timestamp :: non\_neg\_integer}\FunctionTok{()}\NormalTok{,}
\NormalTok{              order\_id :: non\_neg\_integer}\FunctionTok{()}
            \FunctionTok{)}\NormalTok{ ::}
              \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\OperatorTok{.}\NormalTok{t}\FunctionTok{()\}}
              \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, any}\FunctionTok{()\}}
\end{Highlighting}
\end{Shaded}

All of the above callbacks rely on the \texttt{Core.Exchange.Order} struct, which we will add now inside the \texttt{Core.Exchange} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange.ex}
  \KeywordTok{defmodule} \ConstantTok{Order} \KeywordTok{do}
    \OtherTok{@type}\NormalTok{ t :: \%}\ConstantTok{\_\_MODULE\_\_}\FunctionTok{\{}
            \VariableTok{id:}\NormalTok{ non\_neg\_integer}\FunctionTok{()}\NormalTok{,}
            \VariableTok{symbol:} \ConstantTok{String}\OperatorTok{.}\NormalTok{t}\FunctionTok{()}\NormalTok{,}
            \VariableTok{price:}\NormalTok{ number}\FunctionTok{()}\NormalTok{,}
            \VariableTok{quantity:}\NormalTok{ number}\FunctionTok{()}\NormalTok{,}
            \VariableTok{side:} \VariableTok{:buy} \OperatorTok{|} \VariableTok{:sell}\NormalTok{,}
            \VariableTok{status:} \VariableTok{:new} \OperatorTok{|} \VariableTok{:filled}\NormalTok{,}
            \VariableTok{timestamp:}\NormalTok{ non\_neg\_integer}\FunctionTok{()}
          \FunctionTok{\}}

    \KeywordTok{defstruct} \OtherTok{[}\VariableTok{:id}\NormalTok{, }\VariableTok{:symbol}\NormalTok{, }\VariableTok{:price}\NormalTok{, }\VariableTok{:quantity}\NormalTok{, }\VariableTok{:side}\NormalTok{, }\VariableTok{:status}\NormalTok{, }\VariableTok{:timestamp}\OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above struct is a simplification of the \texttt{Binance.Order} struct limited to just the fields we are using in our strategy.

Additionally, we use the \texttt{Binance} module to fetch symbol filters inside the \texttt{Naive.Strategy} (we actually fetch the whole exchange info and then dig inside to find our filters) - we will create a dedicated struct for those filters:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange.ex}
  \CommentTok{\# add below inside the Core.Exchange module}
  \KeywordTok{defmodule} \ConstantTok{SymbolInfo} \KeywordTok{do}
    \OtherTok{@type}\NormalTok{ t :: \%}\ConstantTok{\_\_MODULE\_\_}\FunctionTok{\{}
            \VariableTok{symbol:} \ConstantTok{String}\OperatorTok{.}\NormalTok{t}\FunctionTok{()}\NormalTok{,}
            \VariableTok{tick\_size:}\NormalTok{ number}\FunctionTok{()}\NormalTok{,}
            \VariableTok{step\_size:}\NormalTok{ number}\FunctionTok{()}
          \FunctionTok{\}}

    \KeywordTok{defstruct} \OtherTok{[}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:tick\_size}\NormalTok{, }\VariableTok{:step\_size}\OtherTok{]}
  \KeywordTok{end}

  \OtherTok{@callback}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol :: }\ConstantTok{String}\OperatorTok{.}\NormalTok{t}\FunctionTok{())}\NormalTok{ ::}
              \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{SymbolInfo}\OperatorTok{.}\NormalTok{t}\FunctionTok{()\}}
              \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, any}\FunctionTok{()\}}
\end{Highlighting}
\end{Shaded}

The final usage of the \texttt{Binance} module comes from the seed scripts, where we fetch the exchange info just to get the list of the supported currencies. We will make getting a list of supported currencies part of our behaviour:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange.ex}
  \CommentTok{\# add below inside the Core.Exchange module}
  \OtherTok{@callback}\NormalTok{ fetch\_symbols}\FunctionTok{()}\NormalTok{ ::}
              \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\OtherTok{[}\ConstantTok{String}\OperatorTok{.}\NormalTok{t}\FunctionTok{()}\OtherTok{]}\FunctionTok{\}}
              \OperatorTok{|} \FunctionTok{\{}\VariableTok{:error}\NormalTok{, any}\FunctionTok{()\}}
\end{Highlighting}
\end{Shaded}

This finishes the definition of the \texttt{Core.Exchange} behaviour. It should consist of five callback functions(
\texttt{fetch\_symbols/0}, \texttt{fetch\_symbol\_filters/1}, \texttt{get\_order/3}, \texttt{order\_limit\_buy/3} and \texttt{order\_limit\_sell/3}) together with two structs(\texttt{Order} and \texttt{SymbolInfo}).

\subsection{\texorpdfstring{Implementation of the \texttt{Core.Exchange.Binance} module}{Implementation of the Core.Exchange.Binance module}}\label{implementation-of-the-core.exchange.binance-module}

As we defined the behaviour, we can now wrap the production implementation(the \texttt{Binance} module) inside a module that will implement that behaviour.

We will start by creating a new directory called ``exchange'' inside the \texttt{apps/core/lib/core} directory, together with a new file called \texttt{binance.ex}. Inside it, we will define a module that will implement the \texttt{Core.Exchange} behaviour:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/core/lib/core/exchange/binance.ex}
\KeywordTok{defmodule} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Binance} \KeywordTok{do}
  \OtherTok{@behaviour} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Now we are obliged to implement all functions defined in the behaviour, starting with the \texttt{fetch\_symbols/0}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange/binance.ex}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}

  \OtherTok{@impl} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
  \KeywordTok{def}\NormalTok{ fetch\_symbols}\FunctionTok{()} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbols:}\NormalTok{ symbols}\FunctionTok{\}\}} \OperatorTok{{-}\textgreater{}}
\NormalTok{        symbols}
        \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&} \OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]}\FunctionTok{)}
        \OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\OperatorTok{\&}\DecValTok{1}\FunctionTok{\})}

\NormalTok{      error }\OperatorTok{{-}\textgreater{}}
\NormalTok{        error}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we can see - the \texttt{case} statement wraps the call to the \texttt{Binance} module, and either we evaluate further business logic or forward the error so the ``consumer'' of our library can decide what to do with the error condition. This pattern will appear in all our functions as the \texttt{Core.Exchange.Binance} module is our own ``library'' module.

Let's continue with implementing the remaining functions defined in the behaviour:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange/binance.ex}
  \OtherTok{@impl} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
  \KeywordTok{def}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, exchange\_info}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}} \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol, exchange\_info}\FunctionTok{)\}}
\NormalTok{      error }\OperatorTok{{-}\textgreater{}}\NormalTok{ error}
    \KeywordTok{end}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol, exchange\_info}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    symbol\_filters }\OperatorTok{=}
\NormalTok{      exchange\_info}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\VariableTok{:symbols}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]} \OperatorTok{==}\NormalTok{ symbol}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"filters"}\FunctionTok{)}

\NormalTok{    tick\_size }\OperatorTok{=}
\NormalTok{      symbol\_filters}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"PRICE\_FILTER"}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"tickSize"}\FunctionTok{)}

\NormalTok{    step\_size }\OperatorTok{=}
\NormalTok{      symbol\_filters}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"filterType"}\OtherTok{]} \OperatorTok{==} \StringTok{"LOT\_SIZE"}\FunctionTok{))}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{get}\FunctionTok{(}\StringTok{"stepSize"}\FunctionTok{)}

\NormalTok{    \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{SymbolInfo}\FunctionTok{\{}
      \VariableTok{symbol:}\NormalTok{ symbol,}
      \VariableTok{tick\_size:}\NormalTok{ tick\_size,}
      \VariableTok{step\_size:}\NormalTok{ step\_size}
    \FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The \texttt{fetch\_symbol\_filters/1} function follows the previously discussed pattern. The \texttt{fetch\_symbol\_filters/2}, on the other hand, is a modified copy of the \texttt{merge\_filters\_into\_settings/2} function from the \texttt{Naive.Strategy} module is now returning the \texttt{Exchange.SymbolInfo} struct.

Another function to be implemented to fulfil the behaviour is \texttt{get\_order/3}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange/binance.ex}
  \OtherTok{@impl} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
  \KeywordTok{def}\NormalTok{ get\_order}\FunctionTok{(}\NormalTok{symbol, timestamp, order\_id}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}\NormalTok{symbol, timestamp, order\_id}\FunctionTok{)} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ order}\OperatorTok{.}\NormalTok{order\_id,}
           \VariableTok{symbol:}\NormalTok{ order}\OperatorTok{.}\NormalTok{symbol,}
           \VariableTok{price:}\NormalTok{ order}\OperatorTok{.}\NormalTok{price,}
           \VariableTok{quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{orig\_qty,}
           \VariableTok{side:}\NormalTok{ side\_to\_atom}\FunctionTok{(}\NormalTok{order}\OperatorTok{.}\NormalTok{side}\FunctionTok{)}\NormalTok{,}
           \VariableTok{status:}\NormalTok{ status\_to\_atom}\FunctionTok{(}\NormalTok{order}\OperatorTok{.}\NormalTok{status}\FunctionTok{)}\NormalTok{,}
           \VariableTok{timestamp:}\NormalTok{ order}\OperatorTok{.}\NormalTok{time}
         \FunctionTok{\}\}}

\NormalTok{      error }\OperatorTok{{-}\textgreater{}}
\NormalTok{        error}
    \KeywordTok{end}
  \KeywordTok{end}
  
  \KeywordTok{defp}\NormalTok{ side\_to\_atom}\FunctionTok{(}\StringTok{"BUY"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:buy}
  \KeywordTok{defp}\NormalTok{ side\_to\_atom}\FunctionTok{(}\StringTok{"SELL"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:sell}

  \KeywordTok{defp}\NormalTok{ status\_to\_atom}\FunctionTok{(}\StringTok{"NEW"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:new}
  \KeywordTok{defp}\NormalTok{ status\_to\_atom}\FunctionTok{(}\StringTok{"FILLED"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:filled}
\end{Highlighting}
\end{Shaded}

As in the case of the previously implemented functions, the \texttt{get\_order/3} implementation wraps the \texttt{Binance}'s function inside the \texttt{case} statement. To satisfy the \texttt{Core.Exchange} behaviour, it needs to return the \texttt{Exchange.Order} struct - hence the conversion. It also needs to convert the string \texttt{side} and \texttt{status} fields to atoms before assigning them to the struct(that's the role of the \texttt{status\_to\_atom} and \texttt{side\_to\_atom} helper functions).

The final two functions to be implemented will be the \texttt{order\_limit\_buy/3} and \texttt{order\_limit\_sell/3}:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/core/lib/core/exchange/binance.ex}
  \OtherTok{@impl} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
  \KeywordTok{def}\NormalTok{ order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Binance}\OperatorTok{.}\NormalTok{order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"GTC"}\FunctionTok{)} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ order}\OperatorTok{.}\NormalTok{order\_id,}
           \VariableTok{price:}\NormalTok{ order}\OperatorTok{.}\NormalTok{price,}
           \VariableTok{quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{orig\_qty,}
           \VariableTok{side:} \VariableTok{:buy}\NormalTok{,}
           \VariableTok{status:} \VariableTok{:new}\NormalTok{,}
           \VariableTok{timestamp:}\NormalTok{ order}\OperatorTok{.}\NormalTok{transact\_time}
         \FunctionTok{\}\}}

\NormalTok{      error }\OperatorTok{{-}\textgreater{}}
\NormalTok{        error}
    \KeywordTok{end}
  \KeywordTok{end}

  \OtherTok{@impl} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
  \KeywordTok{def}\NormalTok{ order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, price}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Binance}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"GTC"}\FunctionTok{)} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{,}
\NormalTok{         \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{}
           \VariableTok{id:}\NormalTok{ order}\OperatorTok{.}\NormalTok{order\_id,}
           \VariableTok{price:}\NormalTok{ order}\OperatorTok{.}\NormalTok{price,}
           \VariableTok{quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{orig\_qty,}
           \VariableTok{side:} \VariableTok{:sell}\NormalTok{,}
           \VariableTok{status:} \VariableTok{:new}\NormalTok{,}
           \VariableTok{timestamp:}\NormalTok{ order}\OperatorTok{.}\NormalTok{transact\_time}
         \FunctionTok{\}\}}

\NormalTok{      error }\OperatorTok{{-}\textgreater{}}
\NormalTok{        error}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

That finishes our first implementation of the \texttt{Core.Exchange} behaviour. It will be used in the production by our \texttt{Naive.Strategy}, but before we will update it, let's update the \texttt{BinanceMock} module to implement the same behaviour for testing/backtesting.

\subsection{\texorpdfstring{Updating the \texttt{BinanceMock} module to implement the \texttt{Core.Exchange} behaviour}{Updating the BinanceMock module to implement the Core.Exchange behaviour}}\label{updating-the-binancemock-module-to-implement-the-core.exchange-behaviour}

The \texttt{BinanceMock} module must implement the \texttt{Core.Exchange} behaviour. It will (at compile time) guarantee that both \texttt{Core.Exchange.Binance} and \texttt{BinanceMock} share a common interface that can be used by the \texttt{Naive.Strategy}.

First, we will start by declaring that the \texttt{BinanceMock} actually implements the \texttt{Core.Exchange} behaviour:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
\KeywordTok{defmodule} \ConstantTok{BinanceMock} \KeywordTok{do}
  \OtherTok{@behaviour} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange} \CommentTok{\# \textless{}= added}
\end{Highlighting}
\end{Shaded}

Next, we can replace all the aliases to the \texttt{Binance} structs with a single alias to the \texttt{Core.Exchange} module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
\end{Highlighting}
\end{Shaded}

Don't forget to update all references to the \texttt{Binance.Order} with \texttt{Exchange.Order} module.

As the behaviour is now defined in the \texttt{Core.Exchange} module, we can remove all \texttt{@type} and \texttt{@callback} attributes.

Moving on, we will replace the \texttt{get\_exchange\_info/0}(together with it's \texttt{get\_cached\_exchange\_info/0} helper function) with \texttt{fetch\_symbols/0} and \texttt{fetch\_symbol\_filters/1}(and their helper functions):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ fetch\_symbols}\FunctionTok{()} \KeywordTok{do}
    \KeywordTok{case}\NormalTok{ fetch\_exchange\_info}\FunctionTok{()} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\FunctionTok{\{}\VariableTok{symbols:}\NormalTok{ symbols}\FunctionTok{\}\}} \OperatorTok{{-}\textgreater{}}
\NormalTok{        symbols}
        \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&} \OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]}\FunctionTok{)}
        \OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, }\OperatorTok{\&}\DecValTok{1}\FunctionTok{\})}

\NormalTok{      error }\OperatorTok{{-}\textgreater{}}
\NormalTok{        error}
    \KeywordTok{end}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \KeywordTok{case}\NormalTok{ fetch\_exchange\_info}\FunctionTok{()} \KeywordTok{do}
      \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, exchange\_info}\FunctionTok{\}} \OperatorTok{{-}\textgreater{}}
        \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol, exchange\_info}\FunctionTok{)\}}

\NormalTok{      error }\OperatorTok{{-}\textgreater{}}
\NormalTok{        error}
    \KeywordTok{end}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ fetch\_exchange\_info}\FunctionTok{()} \KeywordTok{do}
    \KeywordTok{case} \ConstantTok{Application}\OperatorTok{.}\NormalTok{get\_env}\FunctionTok{(}\VariableTok{:binance\_mock}\NormalTok{, }\VariableTok{:use\_cached\_exchange\_info}\FunctionTok{)} \KeywordTok{do}
      \ConstantTok{true} \OperatorTok{{-}\textgreater{}}
\NormalTok{        get\_cached\_exchange\_info}\FunctionTok{()}

\NormalTok{      \_ }\OperatorTok{{-}\textgreater{}}
        \ConstantTok{Binance}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{()}
    \KeywordTok{end}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ get\_cached\_exchange\_info }\KeywordTok{do}
    \ConstantTok{File}\OperatorTok{.}\NormalTok{cwd!}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{Path}\OperatorTok{.}\NormalTok{split}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{drop}\FunctionTok{(}\OperatorTok{{-}}\DecValTok{1}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Kernel}\OperatorTok{.++}\FunctionTok{(}\OtherTok{[}
      \StringTok{"binance\_mock"}\NormalTok{,}
      \StringTok{"test"}\NormalTok{,}
      \StringTok{"assets"}\NormalTok{,}
      \StringTok{"exchange\_info.json"}
    \OtherTok{]}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Path}\OperatorTok{.}\NormalTok{join}\FunctionTok{()}
    \OperatorTok{|\textgreater{}} \ConstantTok{File}\OperatorTok{.}\NormalTok{read}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol, exchange\_info}\FunctionTok{)} \KeywordTok{do}
    \CommentTok{\# \textless{}= this is a copy of \textasciigrave{}Core.Exchange.Binance.fetch\_symbol\_filters/2\textasciigrave{} function}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

There are a few additional helpers above, and it got a bit long - let's unpack it.

First, both the \texttt{fetch\_symbols/0} and \texttt{fetch\_symbol\_filters/1} look very similar to the ones we implemented for the \texttt{Core.Exchange.Binance} module. The main difference here is that we support cached exchange info by introducing the \texttt{fetch\_exchange\_info/0} function, which branches out to either using the \texttt{Binance} module or the \texttt{get\_cached\_exchange\_info/0} function. The latter was updated to return the raw data instead of the \texttt{Binance.ExchangeInfo} struct.

Next, there's the \texttt{get\_oder/3} function - as it's working in the same way as per our behaviour, we will leave it as it is.

\newpage

The final two functions to update will be the \texttt{order\_limit\_buy/4} and \texttt{order\_limit\_sell/4}, which will now become three argument functions:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    order\_limit}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"BUY"}\FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, price}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    order\_limit}\FunctionTok{(}\NormalTok{symbol, quantity, price, }\StringTok{"SELL"}\FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

In the above functions, we simply skipped the fourth arguments to fulfil the behaviour.

The changes to different structs will have a ripple effect in other parts of the BinanceMock module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/binance\_mock/lib/binance\_mock.ex}
  \KeywordTok{def}\NormalTok{ generate\_fake\_order}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{}
      \VariableTok{id:}\NormalTok{ order\_id,}
      \VariableTok{symbol:}\NormalTok{ symbol,}
      \VariableTok{price:}\NormalTok{ price,}
      \VariableTok{quantity:}\NormalTok{ quantity,}
      \VariableTok{side:}\NormalTok{ side\_to\_atom}\FunctionTok{(}\NormalTok{side}\FunctionTok{)}\NormalTok{,}
      \VariableTok{status:}\NormalTok{ status\_to\_atom}\FunctionTok{(}\StringTok{"NEW"}\FunctionTok{)}\NormalTok{,}
      \VariableTok{timestamp:}\NormalTok{ current\_timestamp}
    \FunctionTok{\}} \CommentTok{\# \textless{}= keys updated \& \textasciigrave{}.new\textasciigrave{} dropped}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ side\_to\_atom}\FunctionTok{(}\StringTok{"BUY"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:buy}   \CommentTok{\# \textless{}= added}
  \KeywordTok{defp}\NormalTok{ side\_to\_atom}\FunctionTok{(}\StringTok{"SELL"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:sell} \CommentTok{\# \textless{}= added}

  \KeywordTok{defp}\NormalTok{ status\_to\_atom}\FunctionTok{(}\StringTok{"NEW"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:new}       \CommentTok{\# \textless{}= added}
  \KeywordTok{defp}\NormalTok{ status\_to\_atom}\FunctionTok{(}\StringTok{"FILLED"}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \VariableTok{:filled} \CommentTok{\# \textless{}= added}

  \KeywordTok{def}\NormalTok{ handle\_call}\FunctionTok{(}
        \FunctionTok{\{}\VariableTok{:get\_order}\NormalTok{, symbol, time, order\_id}\FunctionTok{\}}\NormalTok{,}
        \OperatorTok{...}
  \FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{find}\FunctionTok{(}
        \OperatorTok{\&}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{symbol }\OperatorTok{==}\NormalTok{ symbol }\KeywordTok{and}
            \OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{timestamp }\OperatorTok{==}\NormalTok{ time }\KeywordTok{and} \CommentTok{\# \textless{}= field updated}
            \OperatorTok{\&}\DecValTok{1}\OperatorTok{.}\NormalTok{id }\OperatorTok{==}\NormalTok{ order\_id}\FunctionTok{)}       \CommentTok{\# \textless{}= field updated}
      \FunctionTok{)}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}
\NormalTok{      \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event,}
      \OperatorTok{...}
  \FunctionTok{)} \KeywordTok{do}
  \OperatorTok{...}
\NormalTok{    filled\_buy\_orders }\OperatorTok{=}
      \OperatorTok{...}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\ConstantTok{Map}\OperatorTok{.}\NormalTok{replace!}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\VariableTok{:status}\NormalTok{, }\VariableTok{:filled}\FunctionTok{))} \CommentTok{\# \textless{}= changed to atom}
  \OperatorTok{...}
\NormalTok{    filled\_sell\_orders }\OperatorTok{=}
      \OperatorTok{...}
      \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\ConstantTok{Map}\OperatorTok{.}\NormalTok{replace!}\FunctionTok{(}\OperatorTok{\&}\DecValTok{1}\NormalTok{, }\VariableTok{:status}\NormalTok{, }\VariableTok{:filled}\FunctionTok{))} \CommentTok{\# \textless{}= changed to atom}
  \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ order\_limit}\FunctionTok{(}\NormalTok{symbol, quantity, price, side}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
   \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, fake\_order}\FunctionTok{\}} \CommentTok{\# \textless{}= no need to convert between structs any more}
  \KeywordTok{end}

  \CommentTok{\# remove the \textasciigrave{}convert\_order\_to\_order\_response/1\textasciigrave{} function {-} not required anymore}

  \CommentTok{\# and finally ;)}

  \KeywordTok{defp}\NormalTok{ convert\_order\_to\_event}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order, time}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
      \VariableTok{event\_time:}\NormalTok{ time }\OperatorTok{{-}} \DecValTok{1}\NormalTok{,}
      \VariableTok{symbol:}\NormalTok{ order}\OperatorTok{.}\NormalTok{symbol,}
      \VariableTok{trade\_id:} \ConstantTok{Integer}\OperatorTok{.}\NormalTok{floor\_div}\FunctionTok{(}\NormalTok{time, }\DecValTok{1000}\FunctionTok{)}\NormalTok{,}
      \VariableTok{price:}\NormalTok{ order}\OperatorTok{.}\NormalTok{price,}
      \VariableTok{quantity:}\NormalTok{ order}\OperatorTok{.}\NormalTok{quantity,  }
      \VariableTok{buyer\_order\_id:}\NormalTok{ order}\OperatorTok{.}\NormalTok{id,}
      \VariableTok{seller\_order\_id:}\NormalTok{ order}\OperatorTok{.}\NormalTok{id,}
      \VariableTok{trade\_time:}\NormalTok{ time }\OperatorTok{{-}} \DecValTok{1}\NormalTok{,}
      \VariableTok{buyer\_market\_maker:} \ConstantTok{false}
    \FunctionTok{\}} \CommentTok{\# \^{}\^{}\^{}\^{}\^{}\^{}= updated mapping}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above changes finish the modifications to the BiananceMock. The module now correctly implements the behaviour.

\subsection{\texorpdfstring{Updating the \texttt{Naive.Strategy}}{Updating the Naive.Strategy}}\label{updating-the-naive.strategy}

We can now move on to the code that will use our implementations of the \texttt{Core.Exchange} behaviour - the \texttt{Naive.Strategy} module.

We will start by adding an alias to the \texttt{Core.Exchange} at the top of the module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}
\end{Highlighting}
\end{Shaded}

Next, we can rename the configuration based \texttt{@binance\_client} to \texttt{@exchange\_client} and update references to it throughout the module:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \OtherTok{@exchange\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:exchange\_client}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Besides the above, we are now relying on the generic structs, so we need to update all references to the \texttt{Binance.OrderResponse} and \texttt{Binance.Order} modules with the \texttt{Exchange.Order} (including updating all field names) - for example:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \CommentTok{\# from:}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{}
            \VariableTok{order\_id:}\NormalTok{ order\_id,}
            \VariableTok{status:} \StringTok{"FILLED"}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{sell\_order:} \ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}}
        \FunctionTok{\}}\NormalTok{,}

  \CommentTok{\# to:}
\NormalTok{        \%}\ConstantTok{Position}\FunctionTok{\{}
          \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{} \CommentTok{\# \textless{}= struct updated}
            \VariableTok{id:}\NormalTok{ order\_id,   }\CommentTok{\# \textless{}= key updated}
            \VariableTok{status:} \VariableTok{:filled} \CommentTok{\# \textless{}= updated to atom}
          \FunctionTok{\}}\NormalTok{,}
          \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}}
        \FunctionTok{\}}

  \CommentTok{\# rename cheatsheet:}
  \CommentTok{\# order\_id to id (do not use "global" file replace)}
  \CommentTok{\# orig\_qty to quantity ("global" file replace safe)}
  \CommentTok{\# transact\_time to timestamp ("global" file replace safe)}
  \CommentTok{\# "FILLED" to :filled ("global" file replace safe)}
\end{Highlighting}
\end{Shaded}

\newpage

As the behaviour's interface(public functions) differs from the \texttt{Binance} module, we need to update all calls that we simplified:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=} \OtherTok{@exchange\_client}\OperatorTok{.}\NormalTok{order\_limit\_buy}\FunctionTok{(}\NormalTok{symbol, quantity, price}\FunctionTok{)}
  \OperatorTok{...}
  \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, \%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{\}} \OperatorTok{=}
      \OtherTok{@exchange\_client}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\NormalTok{symbol, quantity, sell\_price}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

As of now, we will deal only with the \texttt{Exchange.Order} structs instead a pair of \texttt{Binance.OrderResponse} and \texttt{Binance.Order}, we can simplify the existing two clauses of \texttt{broadcast\_order/1} into a single one(and remove the \texttt{convert\_to\_order/1} function):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{defp}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{)} \KeywordTok{do}
    \OtherTok{@pubsub\_client}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Core}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \StringTok{"ORDERS:}\OtherTok{\#\{}\NormalTok{order}\OperatorTok{.}\NormalTok{symbol}\OtherTok{\}}\StringTok{"}\NormalTok{,}
\NormalTok{      order}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The final change to the \texttt{Naive.Strategy} module will be to update the \texttt{fetch\_symbol\_settings/1} function (and remove the \texttt{merge\_filters\_into\_settings/3} function):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \KeywordTok{def}\NormalTok{ fetch\_symbol\_settings}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, filters}\FunctionTok{\}} \OperatorTok{=} \OtherTok{@exchange\_client}\OperatorTok{.}\NormalTok{fetch\_symbol\_filters}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)}
\NormalTok{    db\_settings }\OperatorTok{=} \OtherTok{@repo}\OperatorTok{.}\NormalTok{get\_by!}\FunctionTok{(}\ConstantTok{Settings}\NormalTok{, }\VariableTok{symbol:}\NormalTok{ symbol}\FunctionTok{)}

    \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}
\NormalTok{      filters }\OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}\NormalTok{,}
\NormalTok{      db\_settings }\OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}
    \FunctionTok{)}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The function is now much more straightforward as we use the \texttt{fetch\_symbol\_filters/1} function implemented as a part of the \texttt{Core.Exchange} behaviour.

\newpage

\subsection{Updating the seed scripts}\label{updating-the-seed-scripts}

The other places we use the exchange are seed scripts that we need to update. First inside the \texttt{Naive} application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/priv/seed\_settings.exs}
\NormalTok{exchange\_client }\OperatorTok{=} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:exchange\_client}\FunctionTok{)}
\OperatorTok{...}
\FunctionTok{\{}\VariableTok{:ok}\NormalTok{, symbols}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ exchange\_client}\OperatorTok{.}\NormalTok{fetch\_symbols}\FunctionTok{()}
\OperatorTok{...}
\NormalTok{maps }\OperatorTok{=}\NormalTok{ symbols}
  \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\NormalTok{base\_settings }\OperatorTok{|} \VariableTok{symbol:} \OperatorTok{\&}\DecValTok{1}\FunctionTok{\}))}
\end{Highlighting}
\end{Shaded}

We no longer use the \texttt{binance\_client} but \texttt{exchange\_client} instead - in the same fashion as inside the \texttt{Naive.Strategy} module. Both implementations provide the \texttt{fetch\_symbols/0} function, which returns a list of symbols - hence the change inside the \texttt{Enum/2} function.

We will follow up with changes to the seeding script of the \texttt{Streamer} application(I will skip listing the changes here as they are \textbf{the same} as in the case of the \texttt{Naive} application).

At this moment, we can change the configuration to make the \texttt{Naive.Strategy} work:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.ex }
\NormalTok{config }\VariableTok{:streamer}\NormalTok{,}
  \VariableTok{exchange\_client:} \ConstantTok{BinanceMock}\NormalTok{, }\CommentTok{\# \textless{}= key updated}

\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{exchange\_client:} \ConstantTok{BinanceMock}\NormalTok{, }\CommentTok{\# \textless{}= key updated}

\CommentTok{\# /config/prod.exs}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{exchange\_client:} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Binance} \CommentTok{\# \textless{}= key and module updated}

\NormalTok{config }\VariableTok{:streamer}\NormalTok{,}
  \VariableTok{exchange\_client:} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Binance} \CommentTok{\# \textless{}= key and module updated}

\CommentTok{\# /config/test.exs}
\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{exchange\_client:} \ConstantTok{Test}\OperatorTok{.}\ConstantTok{BinanceMock}\NormalTok{, }\CommentTok{\# \textless{}= key updated}
\end{Highlighting}
\end{Shaded}

\newpage

\subsection{Manual testing after the refactoring}\label{manual-testing-after-the-refactoring}

We can now test that \texttt{Naive.Strategy} works:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"XRPUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{21:42:12.813} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{XRPUSDT/1662842530254}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Placing a BUY order @ 0.35560000,}
\ExtensionTok{quantity:}\NormalTok{ 562.00000000}
\ExtensionTok{21:42:15.280} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{XRPUSDT/1662842530254}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ The BUY order is now partially filled}
\ExtensionTok{21:42:15.281} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{XRPUSDT/1662842530254}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ The BUY order is now filled. Placing}
\ExtensionTok{a}\NormalTok{ SELL order @ 0.35580000, quantity: 562.00000000}
\ExtensionTok{21:42:15.536} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{XRPUSDT/1662842530254}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ The SELL order is now partially}
\ExtensionTok{filled}
\ExtensionTok{21:42:15.593} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{  Position }\ErrorTok{(}\ExtensionTok{XRPUSDT/1662842530254}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Trade cycle finished}
\end{Highlighting}
\end{Shaded}

The above output confirms that we have a full working trading flow using either \texttt{Core.Exchange.Binance} or \texttt{BinanceMock}.

\subsection{Storing the data}\label{storing-the-data}

As we are now using generic structs like the \texttt{Core.Exchange.Order}, all data storage-related code needs to be updated.

We will start by updating the migration script to store only limited passed data:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/priv/repo/migrations/20210222224522\_create\_orders.exs}
  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
\NormalTok{    create table}\FunctionTok{(}\VariableTok{:orders}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:id}\NormalTok{, }\VariableTok{:bigint}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{true}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:price}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:quantity}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:side}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\VariableTok{:text}\FunctionTok{)}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:timestamp}\NormalTok{, }\VariableTok{:bigint}\FunctionTok{)}

\NormalTok{      timestamps}\FunctionTok{()}
    \KeywordTok{end}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

A lot of fields got removed/renamed, including the primary key. We will follow up by updating the schema for that table:

\begin{Shaded}
\begin{Highlighting}[]
 \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/schema/order.ex}
  \OtherTok{@primary\_key} \FunctionTok{\{}\VariableTok{:id}\NormalTok{, }\VariableTok{:integer}\NormalTok{, }\VariableTok{autogenerate:} \ConstantTok{false}\FunctionTok{\}} \CommentTok{\# \textless{}= column updated}

\NormalTok{  schema }\StringTok{"orders"} \KeywordTok{do}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:symbol}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:price}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:quantity}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:side}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\VariableTok{:string}\FunctionTok{)}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:timestamp}\NormalTok{, }\VariableTok{:integer}\FunctionTok{)}

\NormalTok{    timestamps}\FunctionTok{()}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The schema was updated to mirror the new shape of the \texttt{orders} db table.
We can now progress to the Worker, where we will start to use the \texttt{Core.Exchange} based structs:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/data\_warehouse/lib/data\_warehouse/subscriber/worker.ex}
  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Exchange} \CommentTok{\# \textless{}= alias added}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order, state}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    data }\OperatorTok{=}
\NormalTok{      order}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{from\_struct}\FunctionTok{()}
      \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
        \VariableTok{side:}\NormalTok{ atom\_to\_side}\FunctionTok{(}\NormalTok{order}\OperatorTok{.}\NormalTok{side}\FunctionTok{)}\NormalTok{,}
        \VariableTok{status:}\NormalTok{ atom\_to\_status}\FunctionTok{(}\NormalTok{order}\OperatorTok{.}\NormalTok{status}\FunctionTok{)}
      \FunctionTok{\})}

\NormalTok{    struct}\FunctionTok{(}\ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Schema}\OperatorTok{.}\ConstantTok{Order}\NormalTok{, data}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{DataWarehouse}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert}\FunctionTok{(}
      \VariableTok{on\_conflict:} \VariableTok{:replace\_all}\NormalTok{,}
      \VariableTok{conflict\_target:} \VariableTok{:id} \CommentTok{\# \textless{}= column updated}
    \FunctionTok{)}
    \OperatorTok{...}

  \KeywordTok{defp}\NormalTok{ atom\_to\_side}\FunctionTok{(}\VariableTok{:buy}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \StringTok{"BUY"}
  \KeywordTok{defp}\NormalTok{ atom\_to\_side}\FunctionTok{(}\VariableTok{:sell}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \StringTok{"SELL"}

  \KeywordTok{defp}\NormalTok{ atom\_to\_status}\FunctionTok{(}\VariableTok{:new}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \StringTok{"NEW"}
  \KeywordTok{defp}\NormalTok{ atom\_to\_status}\FunctionTok{(}\VariableTok{:filled}\FunctionTok{)}\NormalTok{, }\VariableTok{do:} \StringTok{"FILLED"}
\end{Highlighting}
\end{Shaded}

The \texttt{Worker} will now pattern matches on the \texttt{Core.Exchange.Order} struct instead of \texttt{Binance.Order} as before. Inside the callback, we simplified the mapping to the schema struct and updated the conflict to the renamed \texttt{id} column. Finally, we added the helper functions to convert \texttt{status} and \texttt{side} atoms to strings.

\subsection{\texorpdfstring{The \texttt{Mox} approach summary}{The Mox approach summary}}\label{the-mox-approach-summary}

We didn't yet look into updating our tests, but instead of focusing on that, we will chat about our implementation.

First, it's worth stressing that it required multiple changes to many parts of the system spanning from the \texttt{Naive} application through \texttt{Streamer} (seeding) and ending in the \texttt{DataWarehouse} application.

More importantly, we needed to define a behaviour. It gives us a compile-time guarantee, but on the other hand, we were pushed to define it very early.

Let me explain.

Up to this moment, we have been using only the \texttt{Binance} module. We didn't have an opportunity to work with other modules/exchanges. In fact, we \textbf{didn't want to} create an \texttt{Exchange} level abstraction. We were happy with using the \texttt{Binance} module, and we added the behaviour just to be able to use the \texttt{Mox} package to mock it inside our tests. All of this feels like a really heavy over-engineering just to be able to test.

Furthermore, as we defined the behaviour, we needed to define the generic structs that we based on the ones from the \texttt{Binance} module. We have never seen examples of structs from other packages, so we took only fields that we are using in our strategy to limit the possibility of missing data from another exchange in the future. The knock-on effect will be that we are already missing valuable data in the database as well as adding any new exchanges in the future may require updates to the behaviour, behaviour's existing implementations and most of the code that uses it (like the \texttt{Naive.Strategy}).

Additionally, we returned the \texttt{Binance}'s error messages straight to the user of our abstraction(\texttt{Naive.Strategy}). We should be converting those to generic errors, but we don't have a clue about other exchanges and the errors they could raise.

At this moment, abstracting our code into behaviour+implementations is uneducated over-engineering and simply asking for troubles in the future.

What's the alternative?

The first thing that comes to mind would be to look for some ``standard'' that could be leveraged to build our behaviour/define structs. For cryptocurrency exchanges, that will be ``CCXT'' - it's an open-source ``library'' available for Python, JavaScript and PHP.

We could look further and look for an Elixir implementation of the CCXT package and find the package named \texttt{ccxtex}. It's a wrapper around the JavaScript version of the CCXT package.

Using the above(either the \texttt{ccxtex} package or \texttt{ccxt} as a ``blueprint'') instead of trying to figure out our own behaviour based on our limited knowledge about exchanges would most certainly let us avoid continuous updates to our code.

Those updates, coupled with the fact that we would add the behaviour just to be able to test the implementation, put usage of the \texttt{Mox} package in serious doubt.

The source code up to this moment can be found at \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_21_mox}{Github}

We will stop here and \textbf{revert} to the source code from the end of the \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_20}{20th chapter}. Instead of leaving something we are not prepared to continue with, we will look into alternative ways to test our strategy.

\section{Mimicking the reality}\label{mimicking-the-reality}

In this section, we will look into using the \texttt{Mimic} package to mock the \texttt{Binance} module to test our \texttt{Naive.Strategy}. The advantage of using the \texttt{Mimic} package is that we don't need to define behaviours to mock our modules.

Let's kick this off by swapping the \texttt{mox} package to the \texttt{mimic} package in the dependencies of the \texttt{Naive} application:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:mimic}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.7"}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{:test}\NormalTok{, }\VariableTok{:integration}\OtherTok{]}\FunctionTok{\}}\NormalTok{,}
      \OperatorTok{...}
    \OtherTok{]}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Don't forget to run \texttt{mix\ deps.get} to resolve the dependencies.

\subsection{\texorpdfstring{Updating the \texttt{Naive.Strategy}}{Updating the Naive.Strategy}}\label{updating-the-naive.strategy-1}

Before we dive into writing new tests, we can update the \texttt{Naive.Strategy} module. The \texttt{mimic} module doesn't require us to inject dependencies into module attributes based on config, so we can remove them:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \CommentTok{\# remove the below lines}
  \OtherTok{@binance\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}
  \OtherTok{@logger} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:logger}\FunctionTok{)}
  \OtherTok{@pubsub\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:pubsub\_client}\FunctionTok{)}
  \OtherTok{@repo} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:repo}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

We will switch back to using modules' names as before. We will update all references to attributes throughout the module with corresponding hardcoded module names:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\CommentTok{\# change @logger to Logger}
\CommentTok{\# change @binance\_client to Binance}
\CommentTok{\# change @pubsub\_client to Phoenix.PubSub}
\CommentTok{\# change @repo to Repo}
\end{Highlighting}
\end{Shaded}

As we are pointing to \texttt{Repo} instead of \texttt{Naive.Repo}, we need to add an alias at the top of the module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
\ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}
\end{Highlighting}
\end{Shaded}

{[}Note: At this moment, we will apply the above changes to the \texttt{Indicator.Ohlc.Worker} and \texttt{Indicator.Ohlc}(

\texttt{apps/indicator/lib/indicator/ohlc/worker.ex} and \texttt{apps/indicator/lib/indicator/ohlc.ex}) to avoid breaking the application when we will clean
up the config in the next step.{]}

\newpage

That finishes our conversion to hardcoded module names. As we are no longer basing our module on the configuration, we can remove all redundant configuration keys from the main \texttt{config.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:core}\NormalTok{,                   }\CommentTok{\# \textless{}= remove}
  \VariableTok{logger:} \ConstantTok{Logger}\NormalTok{,               }\CommentTok{\# \textless{}= remove}
  \VariableTok{pubsub\_client:} \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub} \CommentTok{\# \textless{}= remove}

\NormalTok{config }\VariableTok{:streamer}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock}\NormalTok{,  }\CommentTok{\# \textless{}= remove}
  \OperatorTok{...}

\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock}\NormalTok{,  }\CommentTok{\# \textless{}= remove}
  \VariableTok{repo:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{,             }\CommentTok{\# \textless{}= remove}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

We can now move on to figure out how we are going to test it.

\subsection{\texorpdfstring{Testing the \texttt{Naive.Strategy}}{Testing the Naive.Strategy}}\label{testing-the-naive.strategy}

First, we can remove the existing unit tests(\texttt{apps/naive/test/naive/trader\_test.exs}) as they are not applicable anymore.

Next, we will create a new file \texttt{apps/naive/test/naive/strategy\_test.exs} with a skeleton of a test:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/strategy\_test.exs}
\KeywordTok{defmodule} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{StrategyTest} \KeywordTok{do}
  \ImportTok{use} \ConstantTok{ExUnit}\OperatorTok{.}\ConstantTok{Case}\NormalTok{, }\VariableTok{async:} \ConstantTok{true}
  \ImportTok{use} \ConstantTok{Mimic}

  \ImportTok{alias} \ConstantTok{Core}\OperatorTok{.}\ConstantTok{Struct}\OperatorTok{.}\ConstantTok{TradeEvent}
  \ImportTok{alias} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}

  \CommentTok{\# we will add our tests here}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

As we will stub dependencies using \texttt{mimic}, we need to \texttt{use} it inside the test module.

We will be testing the primary entry function, the \texttt{Naive.Strategy.execute/3}, where we will first focus on placing a buy order scenario:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/strategy\_test.exs}
  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Strategy places a buy order"} \KeywordTok{do}
    \CommentTok{\# we will put our code here}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\newpage

The simplest scenario will be to pass hardcoded settings, a fresh position(based on those settings) and a trade event(that will trigger the buy order):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/strategy\_test.exs}
\NormalTok{  settings }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}
    \VariableTok{symbol:} \StringTok{"ABC"}\NormalTok{,   }
    \VariableTok{chunks:} \StringTok{"5"}\NormalTok{,     }
    \VariableTok{budget:} \StringTok{"200"}\NormalTok{,   }
    \VariableTok{buy\_down\_interval:} \StringTok{"0.2"}\NormalTok{,}
    \VariableTok{profit\_interval:} \StringTok{"0.1"}\NormalTok{,}
    \VariableTok{rebuy\_interval:} \StringTok{"0.5"}\NormalTok{,}
    \VariableTok{tick\_size:} \StringTok{"0.000001"}\NormalTok{,}
    \VariableTok{step\_size:} \StringTok{"0.001"}\NormalTok{,}
    \VariableTok{status:} \VariableTok{:on}
  \FunctionTok{\}}

  \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, new\_positions}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{execute}\FunctionTok{(}
\NormalTok{    \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
      \VariableTok{price:} \StringTok{"1.00000"}
    \FunctionTok{\}}\NormalTok{,}
    \OtherTok{[}
      \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_fresh\_position}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)}
    \OtherTok{]}\NormalTok{,}
\NormalTok{    settings}
  \FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Now, the above call to the \texttt{Naive.Strategy.execute/3} will cause the \texttt{Binance.order\_limit\_buy/4}, \texttt{Phoenix.PubSub.brodcast/3} and \texttt{Logger.info/1}(we will skip this one and get back to it later) functions to be called. We need to mock those functions at the beginning of our test before calling the \texttt{Naive.Strategy.execute/3} function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/strategy\_test.exs}
\NormalTok{  expected\_order }\OperatorTok{=}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{} 
    \VariableTok{client\_order\_id:} \StringTok{"1"}\NormalTok{, }
    \VariableTok{executed\_qty:} \StringTok{"0.000"}\NormalTok{, }
    \VariableTok{order\_id:} \StringTok{"x1"}\NormalTok{, }
    \VariableTok{orig\_qty:} \StringTok{"50.000"}\NormalTok{, }
    \VariableTok{price:} \StringTok{"0.800000"}\NormalTok{, }
    \VariableTok{side:} \StringTok{"BUY"}\NormalTok{, }
    \VariableTok{status:} \StringTok{"NEW"}\NormalTok{, }
    \VariableTok{symbol:} \StringTok{"ABC"}
  \FunctionTok{\}}
 
  \ConstantTok{Binance}
  \OperatorTok{|\textgreater{}}\NormalTok{ stub}\FunctionTok{(}
    \VariableTok{:order\_limit\_buy}\NormalTok{,}
    \KeywordTok{fn} \StringTok{"ABC"}\NormalTok{, }\StringTok{"50.000"}\NormalTok{, }\StringTok{"0.800000"}\NormalTok{, }\StringTok{"GTC"} \OperatorTok{{-}\textgreater{}} \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, expected\_order}\FunctionTok{\}} \KeywordTok{end}   
  \FunctionTok{)}

  \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}
  \OperatorTok{|\textgreater{}}\NormalTok{ stub}\FunctionTok{(}
    \VariableTok{:broadcast}\NormalTok{,}
    \KeywordTok{fn}\NormalTok{ \_pubsub, \_topic, \_message }\OperatorTok{{-}\textgreater{}} \VariableTok{:ok} \KeywordTok{end}
  \FunctionTok{)}
\end{Highlighting}
\end{Shaded}

We can use the \texttt{expected\_order} above to assert that the \texttt{Naive.Strategy.execute/3} returned the correct value - the \texttt{buy\_order} field should hold the same data as the \texttt{expected\_order}. We can add the below assertions at the end of the test:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/strategy\_test.exs}
\NormalTok{    assert }\FunctionTok{(}\NormalTok{length new\_positions}\FunctionTok{)} \OperatorTok{==} \DecValTok{1}

\NormalTok{    \%}\FunctionTok{\{}\VariableTok{buy\_order:}\NormalTok{ buy\_order}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{List}\OperatorTok{.}\NormalTok{first}\FunctionTok{(}\NormalTok{new\_positions}\FunctionTok{)}
\NormalTok{    assert buy\_order }\OperatorTok{==}\NormalTok{ expected\_order}
\end{Highlighting}
\end{Shaded}

That finishes the test implementation, but before we will be able to use the \texttt{mimic} module, we need to prepare modules so we can stub them inside tests - here are the new contents of the test helper file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\ConstantTok{Application}\OperatorTok{.}\NormalTok{ensure\_all\_started}\FunctionTok{(}\VariableTok{:mimic}\FunctionTok{)}

\ConstantTok{Mimic}\OperatorTok{.}\NormalTok{copy}\FunctionTok{(}\ConstantTok{Binance}\FunctionTok{)}
\ConstantTok{Mimic}\OperatorTok{.}\NormalTok{copy}\FunctionTok{(}\ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\FunctionTok{)}

\ConstantTok{ExUnit}\OperatorTok{.}\NormalTok{start}\FunctionTok{()}
\end{Highlighting}
\end{Shaded}

We removed all references to the \texttt{mox} module and replaced them with calls to the \texttt{Mimic.copy/1} function.

We are now ready to run our new test:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix test.unit}
\ExtensionTok{...}
\ExtensionTok{21:49:39.737} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{ Position }\ErrorTok{(}\ExtensionTok{ABC/1675460979732}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Placing a BUY order @ 0.800000,}
\ExtensionTok{quantity:}\NormalTok{ 50.000}
\BuiltInTok{.}
\ExtensionTok{Finished}\NormalTok{ in 0.2 seconds }\ErrorTok{(}\ExtensionTok{0.2s}\NormalTok{ async, 0.00s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

As we can see, we successfully mocked the \texttt{Binance} and \texttt{Phoenix.PubSub} modules. We can also see that we are getting log messages that we will deal with next.

\subsection{Logging elephant in the room}\label{logging-elephant-in-the-room}

As we moved back to using the \texttt{Logger} module instead of some dummy implementation, we are now back to square one, seeing logs in our tests. We could go on the route of mocking the \texttt{Logger} module using the \texttt{Mimic}, but actually, there's a better way to deal with logs in the tests.

As ExUnit starts, it allows us to pass options that will modify its behaviour. One of those is \texttt{capture\_log}, which, when set to \texttt{true}, will cause ExUnit to hide all log messages - let's update the test helper script to enable this feature:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\OperatorTok{...}
\ConstantTok{ExUnit}\OperatorTok{.}\NormalTok{start}\FunctionTok{(}\VariableTok{capture\_log:} \ConstantTok{true}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Let's rerun our tests to see the difference:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix test.unit}
\ExtensionTok{...}
\BuiltInTok{.}
\ExtensionTok{Finished}\NormalTok{ in 0.2 seconds }\ErrorTok{(}\ExtensionTok{0.2s}\NormalTok{ async, 0.00s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

We can see that the ExUnit output is now free of any logs.

But what if we would like to assert the logged message? We were able to do that using the \texttt{mox} package, as we were mocking and asserting log messages' contents inside those mocks.

ExUnit provides a helper function for that case as well. We will modify our test to capture the log inside it and assert that it logs the correct value (the price of \$0.8):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/naive/strategy\_test.exs}
  \ImportTok{import} \ConstantTok{ExUnit}\OperatorTok{.}\ConstantTok{CaptureLog} \CommentTok{\# \textless{}= import logging capturing functionality}
  \OperatorTok{...}
\NormalTok{  test }\StringTok{"Strategy places a buy order"} \KeywordTok{do}
    \OperatorTok{...}
    \FunctionTok{\{\{}\VariableTok{:ok}\NormalTok{, new\_positions}\FunctionTok{\}}\NormalTok{, log}\FunctionTok{\}} \OperatorTok{=}
\NormalTok{      with\_log}\FunctionTok{(}\KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
        \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{execute}\FunctionTok{(}
\NormalTok{          \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
            \VariableTok{price:} \StringTok{"1.00000"}
          \FunctionTok{\}}\NormalTok{,}
          \OtherTok{[}
            \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_fresh\_position}\FunctionTok{(}\NormalTok{settings}\FunctionTok{)}
          \OtherTok{]}\NormalTok{,}
\NormalTok{          settings}
        \FunctionTok{)}
      \KeywordTok{end}\FunctionTok{)}

\NormalTok{    assert log }\OperatorTok{=\textasciitilde{}} \StringTok{"0.8"}
\end{Highlighting}
\end{Shaded}

In the above code, we wrapped our call to the \texttt{Naive.Strategy.execute/3} into an anonymous function that we passed as an argument to the \texttt{with\_log/1} function. The \texttt{with\_log/1} function returns a tuple containing the result of the passed function and the generated log message(s). We can then assert that the logged message contains the expected value, strengthening our test. We can now rerun our unit test:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix test.unit}
\ExtensionTok{...}
\BuiltInTok{.}
\ExtensionTok{Finished}\NormalTok{ in 0.2 seconds }\ErrorTok{(}\ExtensionTok{0.2s}\NormalTok{ async, 0.00s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

It's worth noting that we were able to capture the log message even with global capture\_log enabled(inside the test helper when starting ExUnit). This gives us ultimate flexibility. None of the logs are displayed, although whenever we need, we can always capture logs inside test cases on a test-by-tas basis.

That would wrap up the writing unit tests part. But how will this work with running our code locally(or in ``production'') or running integration tests?

\section{Swapping back to attributes}\label{swapping-back-to-attributes}

We need to have a way to swap Binance's implementation between dev/test/integration and prod environments.

We can't use the \texttt{mimic} package to swap the implementation as this is a ``running'' mode, not some tests.

Please note that most of the applications won't need to change the implementation based on the environment as the 3rd party library/package itself will provide some flags to enable/disable the functionality(like sending emails to newly registered users).

Let's get back to the \texttt{Naive.Strategy} module, where we will bring back the attribute-based \texttt{@binance\_client}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/strategy.ex}
  \OtherTok{@binance\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:naive}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_buy}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{order\_limit\_sell}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_order}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)}
  \OperatorTok{...}
  \OtherTok{@binance\_client}\OperatorTok{.}\NormalTok{get\_exchange\_info}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

We need to update all references to the Binance module's functions to use the \texttt{@binance\_client} module's attribute.

\newpage

As we are already modifying the \texttt{Naive} application, we can follow up by removing the \texttt{@logger} and \texttt{@pubsub\_client} module's attributes in the \texttt{Naive.Trader}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/lib/naive/trader.ex}
  \CommentTok{\# remove the below attributes}
  \OtherTok{@logger} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:logger}\FunctionTok{)}
  \OtherTok{@pubsub\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:core}\NormalTok{, }\VariableTok{:pubsub\_client}\FunctionTok{)}
  \OperatorTok{...}
  \CommentTok{\# change @logger to Logger}
  \CommentTok{\# change @pubsub\_client to Phoenix.PubSub}
\end{Highlighting}
\end{Shaded}

\subsection{Config files}\label{config-files}

We will now move to config files, where we will re-add the \texttt{binance\_client} configuration. As previously we will want the \texttt{BinanceMock} to be used everywhere besides production:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:streamer}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock} \CommentTok{\# \textless{}= add}

\NormalTok{config }\VariableTok{:naive}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{BinanceMock}\NormalTok{,  }\CommentTok{\# \textless{}= add}
  \VariableTok{leader:} \ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Leader}\NormalTok{,         }\CommentTok{\# \textless{}= remove}

\CommentTok{\# /config/prod.exs}
\CommentTok{\# stays as it was {-} pointing to the \textasciigrave{}Binance\textasciigrave{} module}

\CommentTok{\# /config/test.exs}
\CommentTok{\# remove everything besides the \textasciigrave{}import\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

It's important to understand that we don't need to configure the \texttt{binance\_client} inside the test configuration. As we now utilise the \texttt{mimic} package, we can drive mocking from the test level.

The knock-on effect of bringing back the environment driven \texttt{@binance\_client} is that now we will need to mimic the \texttt{BinanceMock} module instead of \texttt{Binance} for our unit tests. To fix that, we need to update the test helper:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /apps/naive/test/test\_helper.exs}
\OperatorTok{...}
\ConstantTok{Mimic}\OperatorTok{.}\NormalTok{copy}\FunctionTok{(}\ConstantTok{BinanceMock}\FunctionTok{)} \CommentTok{\# \textless{}= updated from Binance}
\end{Highlighting}
\end{Shaded}

and the unit test:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{\# /apps/naive/test/naive/strategy\_test.exs}
    \OperatorTok{...}
    \ConstantTok{BinanceMock} \CommentTok{\# \textless{}= updated from Binance}
    \OperatorTok{|\textgreater{}}\NormalTok{ stub}\FunctionTok{(}
\end{Highlighting}
\end{Shaded}

We needed to change the above as now, in the case of dev and integration, we are using the \texttt{BinanceMock}.

After applying the above changes, we can now run the unit tests:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ mix test.unit}
\ExtensionTok{...}
\BuiltInTok{.}
\ExtensionTok{Finished}\NormalTok{ in 0.2 seconds }\ErrorTok{(}\ExtensionTok{0.2s}\NormalTok{ async, 0.00s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

As well as run the integration tests:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ MIX\_ENV=integration mix test.integration}
\BuiltInTok{.}
\ExtensionTok{Finished}\NormalTok{ in 7.2 seconds }\ErrorTok{(}\ExtensionTok{0.04s}\NormalTok{ async, 7.1s sync}\KeywordTok{)}
\ExtensionTok{2}\NormalTok{ tests, 0 failures, 1 excluded}
\end{Highlighting}
\end{Shaded}

And finally, we are able to run the project:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ iex }\AttributeTok{{-}S}\NormalTok{ mix}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{1}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Streamer.start\_streaming}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{iex}\ErrorTok{(}\ExtensionTok{2}\KeywordTok{)}\OperatorTok{\textgreater{}}\NormalTok{ Naive.start\_trading}\KeywordTok{(}\StringTok{"ETHUSDT"}\KeywordTok{)}
\ExtensionTok{...}
\ExtensionTok{22:57:53.834} \PreprocessorTok{[}\SpecialStringTok{info}\PreprocessorTok{]}\NormalTok{ Position }\ErrorTok{(}\ExtensionTok{ETHUSDT/1675724273832}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ Placing a BUY order @ 1632.82000000,}
\ExtensionTok{quantity:}\NormalTok{ 0.12240000}
\end{Highlighting}
\end{Shaded}

In this chapter, we've reiterated the ideas behind the \texttt{mox} package, highlighting its shortcomings, especially the push to create needless abstractions(behaviours). We then dropped our changes to show the alternative approach using the `mimic' package, which was way handier and easier to understand. In the end, we realized that to facilitate using different implementations between dev and production, we will need to keep the \texttt{@binance\_client} attribute.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_21}{GitHub}

\chapter{80/20 win with pure logic}\label{win-with-pure-logic}

\section{Objectives}\label{objectives-21}

\begin{itemize}
\tightlist
\item
  testing the pure logic
\end{itemize}

\section{Testing the pure logic}\label{testing-the-pure-logic}

We worked hard across the last few chapters to make our code more testable. We wandered into the world of mocking and mimicking to allow us to write end-to-end tests, but we didn't really reap the benefits of the fact that we made a substantial part of our code pure.

In this chapter, we will cover most of our trading strategy with tests to showcase the value of pure/non-pure code segregation.

We will start by removing all ``hello world'' tests that were generated when we were creating each of the umbrella apps - all of them look the same:

\begin{verbatim}
  test "greets the world" do
    assert $app.hello() == :world
  end
\end{verbatim}

After taking care of this nuisance, we can now focus on testing our strategy.

We will start by opening the \texttt{apps/naive/test/naive/strategy\_test.exs} where we will add tests of \texttt{generate\_decision/4} function. We will test each clause starting with the first (returning \texttt{:place\_buy\_order}):

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive/lib/strategy\_test.exs}
  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating place buy order decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
               \VariableTok{price:} \StringTok{"1.0"}
             \FunctionTok{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{budget:} \StringTok{"10.0"}\NormalTok{,}
               \VariableTok{buy\_down\_interval:} \StringTok{"0.01"}
             \FunctionTok{\})}\NormalTok{,}
             \VariableTok{:ignored}\NormalTok{,}
             \VariableTok{:ignored}
           \FunctionTok{)} \OperatorTok{==} \FunctionTok{\{}\VariableTok{:place\_buy\_order}\NormalTok{, }\StringTok{"0.99000000"}\NormalTok{, }\StringTok{"10.00000000"}\FunctionTok{\}}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

The above test checks that the function returns': place\_buy\_order' in case of a lack of buy/sell order. Inside the test, we are using a helper function that we need to add below:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive/lib/strategy\_test.exs}
  \KeywordTok{defp}\NormalTok{ generate\_position}\FunctionTok{(}\NormalTok{data}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    \%}\FunctionTok{\{}
      \VariableTok{id:} \DecValTok{1\_678\_920\_020\_426}\NormalTok{,}
      \VariableTok{symbol:} \StringTok{"XRPUSDT"}\NormalTok{,}
      \VariableTok{profit\_interval:} \StringTok{"0.005"}\NormalTok{,}
      \VariableTok{rebuy\_interval:} \StringTok{"0.01"}\NormalTok{,}
      \VariableTok{rebuy\_notified:} \ConstantTok{false}\NormalTok{,}
      \VariableTok{budget:} \StringTok{"10.0"}\NormalTok{,}
      \VariableTok{buy\_order:} \ConstantTok{nil}\NormalTok{,}
      \VariableTok{sell\_order:} \ConstantTok{nil}\NormalTok{,}
      \VariableTok{buy\_down\_interval:} \StringTok{"0.01"}\NormalTok{,}
      \VariableTok{tick\_size:} \StringTok{"0.00010000"}\NormalTok{,}
      \VariableTok{step\_size:} \StringTok{"1.00000000"}
    \FunctionTok{\}}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}\NormalTok{data}\FunctionTok{)}
    \OperatorTok{|\textgreater{}}\NormalTok{ then}\FunctionTok{(}\OperatorTok{\&}\NormalTok{struct}\FunctionTok{(}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Position}\NormalTok{, }\OperatorTok{\&}\DecValTok{1}\FunctionTok{))}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

At this moment, we should already be able to run the above test:

\begin{verbatim}
$ MIX_ENV=test mix test.unit
...
==> naive
...
3 tests, 0 failures, 1 excluded
\end{verbatim}

We will now take care of the remaining clauses of \texttt{generate\_decision/4} function:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /apps/naive/test/naive/lib/strategy\_test.exs}
  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating skip decision as buy and sell already placed(race condition occurred)"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
               \VariableTok{buyer\_order\_id:} \DecValTok{123}
             \FunctionTok{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{order\_id:} \DecValTok{123}\NormalTok{,}
                 \VariableTok{status:} \StringTok{"FILLED"}
               \FunctionTok{\}}\NormalTok{,}
               \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}}
             \FunctionTok{\})}\NormalTok{,}
             \VariableTok{:ignored}\NormalTok{,}
             \VariableTok{:ignored}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:skip}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating place sell order decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{status:} \StringTok{"FILLED"}\NormalTok{,}
                 \VariableTok{price:} \StringTok{"1.00"}
               \FunctionTok{\}}\NormalTok{,}
               \VariableTok{sell\_order:} \ConstantTok{nil}\NormalTok{,}
               \VariableTok{profit\_interval:} \StringTok{"0.01"}\NormalTok{,}
               \VariableTok{tick\_size:} \StringTok{"0.0001"}
             \FunctionTok{\})}\NormalTok{,}
             \VariableTok{:ignored}\NormalTok{,}
             \VariableTok{:ignored}
           \FunctionTok{)} \OperatorTok{==} \FunctionTok{\{}\VariableTok{:place\_sell\_order}\NormalTok{, }\StringTok{"1.0120"}\FunctionTok{\}}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating fetch buy order decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
               \VariableTok{buyer\_order\_id:} \DecValTok{1234}
             \FunctionTok{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{order\_id:} \DecValTok{1234}
               \FunctionTok{\}}
             \FunctionTok{\})}\NormalTok{,}
             \VariableTok{:ignored}\NormalTok{,}
             \VariableTok{:ignored}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:fetch\_buy\_order}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating finish position decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{status:} \StringTok{"FILLED"}
               \FunctionTok{\}}\NormalTok{,}
               \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{status:} \StringTok{"FILLED"}
               \FunctionTok{\}}
             \FunctionTok{\})}\NormalTok{,}
             \VariableTok{:ignored}\NormalTok{,}
\NormalTok{             \%}\FunctionTok{\{}\VariableTok{status:} \StringTok{"on"}\FunctionTok{\}}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:finished}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating exit position decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{status:} \StringTok{"FILLED"}
               \FunctionTok{\}}\NormalTok{,}
               \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{status:} \StringTok{"FILLED"}
               \FunctionTok{\}}
             \FunctionTok{\})}\NormalTok{,}
             \VariableTok{:ignored}\NormalTok{,}
\NormalTok{             \%}\FunctionTok{\{}\VariableTok{status:} \StringTok{"shutdown"}\FunctionTok{\}}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:exit}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating fetch sell order decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
               \VariableTok{seller\_order\_id:} \DecValTok{1234}
             \FunctionTok{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{\}}\NormalTok{,}
               \VariableTok{sell\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{order\_id:} \DecValTok{1234}
               \FunctionTok{\}}
             \FunctionTok{\})}\NormalTok{,}
             \VariableTok{:ignored}\NormalTok{,}
             \VariableTok{:ignored}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:fetch\_sell\_order}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating rebuy decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
               \VariableTok{price:} \StringTok{"0.89"}
             \FunctionTok{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{price:} \StringTok{"1.00"}
               \FunctionTok{\}}\NormalTok{,}
               \VariableTok{rebuy\_interval:} \StringTok{"0.1"}\NormalTok{,}
               \VariableTok{rebuy\_notified:} \ConstantTok{false}
             \FunctionTok{\})}\NormalTok{,}
             \OtherTok{[}\VariableTok{:position}\OtherTok{]}\NormalTok{,}
\NormalTok{             \%}\FunctionTok{\{}\VariableTok{status:} \StringTok{"on"}\NormalTok{, }\VariableTok{chunks:} \DecValTok{2}\FunctionTok{\}}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:rebuy}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating skip(rebuy) decision because rebuy is already notified"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
               \VariableTok{price:} \StringTok{"0.89"}
             \FunctionTok{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{price:} \StringTok{"1.00"}
               \FunctionTok{\}}\NormalTok{,}
               \VariableTok{rebuy\_interval:} \StringTok{"0.1"}\NormalTok{,}
               \VariableTok{rebuy\_notified:} \ConstantTok{true}
             \FunctionTok{\})}\NormalTok{,}
             \OtherTok{[}\VariableTok{:position}\OtherTok{]}\NormalTok{,}
\NormalTok{             \%}\FunctionTok{\{}\VariableTok{status:} \StringTok{"on"}\NormalTok{, }\VariableTok{chunks:} \DecValTok{2}\FunctionTok{\}}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:skip}
  \KeywordTok{end}

  \OtherTok{@tag} \VariableTok{:unit}
\NormalTok{  test }\StringTok{"Generating skip rebuy decision"} \KeywordTok{do}
\NormalTok{    assert }\ConstantTok{Strategy}\OperatorTok{.}\NormalTok{generate\_decision}\FunctionTok{(}
\NormalTok{             \%}\ConstantTok{TradeEvent}\FunctionTok{\{}
               \VariableTok{price:} \StringTok{"0.9"}
             \FunctionTok{\}}\NormalTok{,}
\NormalTok{             generate\_position}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
               \VariableTok{buy\_order:}\NormalTok{ \%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{OrderResponse}\FunctionTok{\{}
                 \VariableTok{price:} \StringTok{"1.00"}
               \FunctionTok{\}}\NormalTok{,}
               \VariableTok{rebuy\_interval:} \StringTok{"0.1"}\NormalTok{,}
               \VariableTok{rebuy\_notified:} \ConstantTok{false}
             \FunctionTok{\})}\NormalTok{,}
             \OtherTok{[}\VariableTok{:position}\OtherTok{]}\NormalTok{,}
\NormalTok{             \%}\FunctionTok{\{}\VariableTok{status:} \StringTok{"on"}\NormalTok{, }\VariableTok{chunks:} \DecValTok{1}\FunctionTok{\}}
           \FunctionTok{)} \OperatorTok{==} \VariableTok{:skip}
  \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

This brings us to 12 tests:

\begin{verbatim}
$ MIX_ENV=test mix test.unit
...
==> naive
...
12 tests, 0 failures, 1 excluded
\end{verbatim}

The above tests are straightforward and uneventful, but that's good. They prove that tests of pure code are easy to write and maintain.

Furthermore, besides the \texttt{generate\_decision/4} function, we also have \texttt{generate\_decisions/4}, \texttt{parse\_results/1} and helper methods that are all pure functions. After a little bit of math, we can work out that out of 424 lines, 262 lines contain pure code - that's a whopping 61\%.

The above shows that we can gain great coverage and easy maintainability by splitting our business logic into pure and effectful functions. This approach is the most pragmatic execution of functional programming and can easily be proven to bring quantitative benefits.

In this chapter, we've tested our trading strategy, emphasizing the simplicity gained from separating pure/non-pure code.

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_22}{GitHub}

\chapter{Back to the Monolith}\label{back-to-the-monolith}

\section{Objectives}\label{objectives-22}

\begin{itemize}
\tightlist
\item
  reverting the course to the monolith
\item
  creating a new Phoenix app
\item
  reintegrating the \texttt{core} app
\item
  reintegrating the \texttt{binance\_mock} app
\item
  reintegrating the \texttt{streamer} app
\item
  reintegrating the \texttt{naive} app
\item
  reintegrating the \texttt{data\_warehouse} app
\item
  reintegrating the \texttt{indicator} app
\end{itemize}

\section{Reverting the course to the monolith}\label{reverting-the-course-to-the-monolith}

We started our journey with the idea that we would use an umbrella to ``future-proof'' our project in case we would migrate to microservices architecture.

As we delved deeper into our project(which also included me gaining more knowledge and experience over three years of writing this book), we began to see that the umbrella approach was, at best, an example of overengineering.

Looking back, the umbrella approach introduced significant complexity, a factor that became increasingly difficult to justify as our understanding of the project evolved.

For example, each umbrella app has its configuration, which resulted in using multiple databases and duplicated settings for things like the Binance client, making our deployment unnecessarily expensive and complex.

In this chapter, we will simplify the whole project by ditching the umbrella and migrating to Phoenix, which will be instrumental in our next steps, including deployment and clustering.

\section{Creating a new Phoenix app}\label{creating-a-new-phoenix-app}

Instead of improving the existing structure, we will start from scratch. We will create a new Phoenix project side-by-side next to the current umbrella app, and then we will reintegrate each nested app one after another.

First, let's make sure that we have the latest version of the Phoenix application generator installed:

\begin{verbatim}
$ mix archive.install hex phx_new
\end{verbatim}

Note: At the time of writing this chapter, the current version of the Phoenix framework is 1.7.12.

With this taken care of, we can progress with the creation of a new Phoenix application and a database:

\begin{verbatim}
$ mix phx.new hedgehog
...
$ cd hedgehog
$ mix ecto.create
\end{verbatim}

With the Phoenix app skeleton in place, we can move on to reintegrating the umbrella apps' contents into it.

\section{\texorpdfstring{Reintegrating the \texttt{core} app}{Reintegrating the core app}}\label{reintegrating-the-core-app}

We will start with the \texttt{core} app, as it is used/referenced by other apps in the umbrella.

It contains just a single module called \texttt{Core.Struct.TradeEvent} (inside the \texttt{apps/core/lib/core/struct/trade\_event.ex} file) which we will rename to \texttt{Hedgehog.Exchange.TradeEvent} inside the newly created Phoenix app (we need to create a new \texttt{exchange} directory inside the \texttt{/lib/hedgehog} and paste the updated \texttt{trade\_event.ex} file inside).

Besides the \texttt{TradeEvent} module, the \texttt{core} application supervises the \texttt{PubSub} supervision tree. After a quick check inside the \texttt{/lib/hedgehog/application.ex} file, we can confirm that Phoenix already uses PubSub:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /lib/hedgehog/application.ex}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{, }\VariableTok{name:} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{PubSub}\FunctionTok{\}}\NormalTok{,}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Furthermore, the \texttt{phoenix\_pubsub} dependency is already included in the \texttt{mix.lock} file, and its default backend is now \texttt{Phoenix.PubSub.PG2}(the adapter we have been explicitly specifying before).

The above change finishes merging the \texttt{core} app into our new Phoenix app. We should be able to run our app:

\begin{verbatim}
$ iex -S mix phx.server
...
[info] Running HedgehogWeb.Endpoint with Bandit 1.4.2 at 127.0.0.1:4000 (http)
...
iex(1)> alias Hedgehog.Exchange.TradeEvent
...
iex(2)> %TradeEvent{}
%Hedgehog.Exchange.TradeEvent{
...
}
\end{verbatim}

\section{\texorpdfstring{Reintegrating the \texttt{binance\_mock} app}{Reintegrating the binance\_mock app}}\label{reintegrating-the-binance_mock-app}

The \texttt{binance\_mock} app is used by both the \texttt{naive} and \texttt{streamer} apps, so we will need to focus on it next.

First, we will find a new home for the cached exchange info file which was previously based in

\texttt{/apps/binance\_mock/test/assets/exchange\_info.json}. We will create a new directory called \texttt{/priv/cache} where we will paste the \texttt{exchange\_info.json} file.

Next, we will take care of configuration that was deciding should we use the cached exchange info file mentioned above - inside the new application it will look as follows:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:hedgehog}\NormalTok{,}
  \OperatorTok{...}
  \VariableTok{exchanges:} \OtherTok{[} \CommentTok{\# \textless{}= added}
    \VariableTok{binance\_mock:} \OtherTok{[} 
      \VariableTok{use\_cached\_exchange\_info:} \ConstantTok{true}
    \OtherTok{]}
  \OtherTok{]}
\end{Highlighting}
\end{Shaded}

Moving on to the main file of interest - \texttt{apps/binance\_mock/lib/binance\_mock.ex}, which we will move to the \texttt{/lib/hedgehog/exchange} directory.

Inside the module, we need to apply the following changes:

\begin{itemize}
\tightlist
\item
  change the module name to \texttt{Hedgehog.Exchange.BinanceMock}
\item
  update the alias to the \texttt{Core.Struct.TradeEvent} struct to be \texttt{Hedgehog.Exchange.TradeEvent}
\item
  update references to the \texttt{Core.PubSub} with \texttt{Hedgehog.PubSub}
\item
  extract to boolean config flag to a module's attribute and use it inside the \texttt{get\_exchange\_info/0} function:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /lib/hedgehog/exchange/binance\_mock.ex}
  \OtherTok{@use\_cached\_exchange\_info} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env!}\FunctionTok{(}\VariableTok{:hedgehog}\NormalTok{, }\OtherTok{[}
                              \VariableTok{:exchanges}\NormalTok{,}
                              \VariableTok{:binance\_mock}\NormalTok{,}
                              \VariableTok{:use\_cached\_exchange\_info}
                            \OtherTok{]}\FunctionTok{)}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ get\_exchange\_info}\FunctionTok{()} \KeywordTok{do}
    \KeywordTok{case} \OtherTok{@use\_cached\_exchange\_info} \KeywordTok{do}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Update the \texttt{get\_cached\_exchange\_info/0} function to point to the new location of the \texttt{exchange\_info.json} file:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /lib/hedgehog/exchange/binance\_mock.ex    }
  \KeywordTok{defp}\NormalTok{ get\_cached\_exchange\_info }\KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:ok}\NormalTok{, data}\FunctionTok{\}} \OperatorTok{=}
      \ConstantTok{File}\OperatorTok{.}\NormalTok{cwd!}\FunctionTok{()}
      \OperatorTok{|\textgreater{}} \ConstantTok{Path}\OperatorTok{.}\NormalTok{split}\FunctionTok{()}
      \OperatorTok{|\textgreater{}} \ConstantTok{Kernel}\OperatorTok{.++}\FunctionTok{(}\OtherTok{[}
        \StringTok{"priv"}\NormalTok{,}
        \StringTok{"cache"}\NormalTok{,}
        \StringTok{"exchange\_info.json"}
      \OtherTok{]}\FunctionTok{)}
      \OperatorTok{|\textgreater{}} \ConstantTok{Path}\OperatorTok{.}\NormalTok{join}\FunctionTok{()}
      \OperatorTok{|\textgreater{}} \ConstantTok{File}\OperatorTok{.}\NormalTok{read}\FunctionTok{()}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

That finishes our changes to the \texttt{Hedgehog.Exchange.BinanceMock} module which we need to add supervision tree of our application:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /lib/hedgehog/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{BinanceMock}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The \texttt{Hedgehog.Exchange.BinanceMock} module depends on a few packages that we need to add to the \texttt{mix.exs} dependencies:

\begin{Shaded}
\begin{Highlighting}[]
  \CommentTok{\# /mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:binance}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.0"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:decimal}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 2.0"}\FunctionTok{\}}\NormalTok{,}
      \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

Please remember to run the \texttt{mix\ deps.get} before trying out our changes:

\begin{verbatim}
$ iex -S mix phx.server
...
iex(1)> alias Hedgehog.Exchange.BinanceMock
iex(2)> Process.whereis(BinanceMock)
#PID<...>
iex(3)> |> Process.alive?()
true
iex(4)> BinanceMock.get_exchange_info()
%{
  ...
}
\end{verbatim}

The above confirms that we now have a \texttt{BinanceMock} process running in the background and we are able to fetch exchange info.

\section{\texorpdfstring{Reintegrating the \texttt{streamer} app}{Reintegrating the streamer app}}\label{reintegrating-the-streamer-app}

In the case of the \texttt{streamer} app, there are multiple files to move, so we will first create a new \texttt{/lib/hedgehog/streamer}(inside the new Phoenix app) directory and then copy both the \texttt{/apps/streamer/lib/streamer} directory and the \texttt{/apps/streamer/lib/streamer.ex} file into that new directory.

As we will be updating/renaming all of those files, we will use this opportunity to place all of them inside the \texttt{Binance} namespace.

We now need to modify each file starting with renaming \texttt{/lib/hedgehog/streamer/streamer.ex} to \texttt{/lib/hedgehog/streamer/binance.ex} and updating the module name and alias:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/streamer/binance.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}
\end{Highlighting}
\end{Shaded}

The next step will be to update the \texttt{/lib/hedgehog/streamer/streamer} directory to

\texttt{/lib/hedgehog/streamer/binance}. We will now move on to the files inside this directory.

\subsection{Supervisor}\label{supervisor}

Starting with the \texttt{supervisor.ex} file, we need to update the module's name and alias:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/streamer/binance/supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Supervisor} \KeywordTok{do}
   \OperatorTok{...}
   \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor}
\end{Highlighting}
\end{Shaded}

Moving forward, we can remove the \texttt{repo.ex} file as we will use the \texttt{Hedgehog.Repo} module to work with the database.

\subsection{Worker}\label{worker}

Next, we will rename the \texttt{/lib/hedgehog/streamer/binance/binance.ex} to

\texttt{/lib/hedgehog/streamer/binance/worker.ex} - mainly to avoid ``binance/binance'' name after we added the namespace. Following the filename change, we need to update the module's name and a couple of references to the \texttt{Core} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/streamer/binance/worker.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Worker} \KeywordTok{do}
\OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ process\_event}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\StringTok{"e"} \OperatorTok{=\textgreater{}} \StringTok{"trade"}\FunctionTok{\}} \OperatorTok{=}\NormalTok{ event}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    trade\_event }\OperatorTok{=}\NormalTok{ \%}\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}\FunctionTok{\{}
\OperatorTok{...}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{DynamicStreamerSupervisor}\label{dynamicstreamersupervisor}

Next, we will update the \texttt{dynamic\_streamer\_supervisor.ex}, where we will update the module's name and all the aliases:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/streamer/binance/dynamic\_streamer\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{DynamicStreamerSupervisor} \KeywordTok{do}
\OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Worker}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Settings}
\OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ start\_child}\FunctionTok{(}\NormalTok{args}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
      \ConstantTok{\_\_MODULE\_\_}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Worker}\NormalTok{, args}\FunctionTok{\}}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{schema/settings.ex and schema/streaming\_status\_enum.ex}\label{schemasettings.ex-and-schemastreaming_status_enum.ex}

We will move the \texttt{/lib/hedgehog/streamer/binance/schema/settings.ex} file to

\texttt{/lib/hedgehog/streamer/settings.ex} and the

\texttt{/lib/hedgehog/streamer/binance/schema/streaming\_status\_enum.ex} file to

\texttt{/lib/hedgehog/streamer/settings\_status\_enum.ex}(file renamed). We can now remove the empty

\texttt{/lib/hedgehog/streamer/binance/schema} directory. Both of those modules need their modules' names and references updated:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/streamer/settings.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Settings} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}
  \OperatorTok{...}
\NormalTok{  schema }\StringTok{"streamer\_settings"} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SettingsStatusEnum}\FunctionTok{)}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

and:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/streamer/settings\_status\_enum.ex}
\OperatorTok{...}
\NormalTok{defenum}\FunctionTok{(}\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}\NormalTok{, }\VariableTok{:status}\NormalTok{, }\OtherTok{[}\VariableTok{:on}\NormalTok{, }\VariableTok{:off}\OtherTok{]}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{application}\label{application}

The final file that we need to look into is \texttt{/lib/hedgehog/streamer/binance/application.ex}, where we will look into children who were supervised by the \texttt{streamer} app:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/streamer/binance/application.ex}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Repo}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Supervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

We don't need to worry about the \texttt{Streamer.Repo} as we will use the \texttt{Hedgehog.Repo}. On the other hand, the \texttt{Streamer.Supervisor} which we renamed to \texttt{Hedgehog.Streamer.Binance.Supervisor} needs to be added to the main \texttt{Hedgehog.Application} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/application.ex}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Supervisor}
    \OtherTok{]}
\end{Highlighting}
\end{Shaded}

We can now remove \texttt{/lib/hedgehog/streamer/binance/application.ex} as it is no longer required.

\subsection{DB migrations and seeding}\label{db-migrations-and-seeding}

Streaming depends on the database tables and settings(seed data). We will start by copying

\texttt{apps/streamer/priv/repo/migrations/20210203184805\_create\_settings.exs} migration to

\texttt{/priv/repo/migrations}(and renaming the file to \texttt{20210203184805\_create\_streamer\_settings.exs}) directory and update the most of the code inside:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/migrations/20210203184805\_create\_streamer\_settings.exs}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateStreamerSettings} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{SettingsStatusEnum}\OperatorTok{.}\NormalTok{create\_type}\FunctionTok{()}

\NormalTok{    create table}\FunctionTok{(}\VariableTok{:streamer\_settings}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
      \OperatorTok{...}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SettingsStatusEnum}\OperatorTok{.}\NormalTok{type}\FunctionTok{()}\NormalTok{, }\VariableTok{default:} \StringTok{"off"}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
    \OperatorTok{...}
\NormalTok{    create}\FunctionTok{(}\NormalTok{unique\_index}\FunctionTok{(}\VariableTok{:streamer\_settings}\NormalTok{, }\OtherTok{[}\VariableTok{:symbol}\OtherTok{]}\FunctionTok{))}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\newpage

Next, we will copy the seeding script's code from \texttt{/apps/streamer/priv/seed\_settings.exs} to

\texttt{/priv/repo/seeds.exs} and make the following updates:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/seeds.exs}
\ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}
\ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Settings}

\NormalTok{binance\_client }\OperatorTok{=} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:hedgehog}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Config}\label{config}

Inside the script above, we were reading the application's configuration expecting the \texttt{binance\_client} to be there - let's append the required settings to the configuration:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:hedgehog}\NormalTok{,}
  \VariableTok{binance\_client:} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{BinanceMock}\NormalTok{, }\CommentTok{\# \textless{}= added}
  \VariableTok{ecto\_repos:} \OtherTok{[}\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}\OtherTok{]}\NormalTok{,}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{Deps}\label{deps}

We need to add a couple of new dependencies that the streaming code is using:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\VariableTok{:ecto\_enum}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.4"}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\VariableTok{:websockex}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 0.4.2"}\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

With the above changes, the reintegration of the \texttt{Streamer} app is finished. We need to remember about getting new deps, running migrations, seeding database and we can test that everything works up to this point:

\begin{verbatim}
$ mix deps.get
...
$ mix setup
...
$ iex -S mix phx.server
...
iex(1)> Hedgehog.Streamer.Binance.start_streaming("XRPUSDT")
...
[info] Binance streamer is connecting to websocket stream for XRPUSDT trade events
{:ok, #PID<0.801.0>}
[debug] Trade event received XRPUSDT@0.55080000
BREAK: (a)bort (A)bort with dump (c)ontinue (p)roc info (i)nfo
       (l)oaded (v)ersion (k)ill (D)b-tables (d)istribution
^C
$ iex -S mix phx.server
...
[info] Binance streamer is connecting to websocket stream for XRPUSDT trade events
[debug] Trade event received XRPUSDT@0.55240000
iex(1)> Hedgehog.Streamer.Binance.stop_streaming("XRPUSDT")
[info] Stopping streaming XRPUSDT trade events
...
\end{verbatim}

The above confirms that we can start and stop streaming, and upon startup, streaming starts on its own when enabled in the database.

\section{\texorpdfstring{Reintegrating the \texttt{naive} app}{Reintegrating the naive app}}\label{reintegrating-the-naive-app}

We will kick off the \texttt{naive} application reintegration by creating a new directory called \texttt{strategy} inside the \texttt{/lib/hedgehog/}, where we will place both the \texttt{naive.ex} file and the \texttt{naive} directory(both originally located inside the \texttt{/apps/naive/lib/}).

\subsection{naive.ex}\label{naive.ex}

We can update the module name and aliases inside the \texttt{naive.ex} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/strategy/naive.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive} \KeywordTok{do}
  \OperatorTok{..}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicTraderSupervisor}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}
\end{Highlighting}
\end{Shaded}

\subsection{strategy.ex -\textgreater{} formula.ex}\label{strategy.ex---formula.ex}

Moving on to the \texttt{naive} directory, first, we will rename the \texttt{strategy.ex} file to \texttt{formula.ex} and update the references inside:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/strategy/naive/formula.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Formula} \KeywordTok{do}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Settings}
  \OperatorTok{...}

  \OtherTok{@binance\_client} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:hedgehog}\NormalTok{, }\VariableTok{:binance\_client}\FunctionTok{)}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ broadcast\_order}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{trader.ex}}{trader.ex}}\label{trader.ex}

Next, we will update the \texttt{trader.ex}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/strategy/naive/trader.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Formula}
\end{Highlighting}
\end{Shaded}

as well as all update all references to:

\begin{itemize}
\tightlist
\item
  \texttt{Naive.Strategy} or \texttt{Strategy} to \texttt{Formula}
\item
  \texttt{Core.PubSub} to \texttt{Hedgehog.PubSub}
\end{itemize}

\subsection{\texorpdfstring{\texttt{supervisor.ex}}{supervisor.ex}}\label{supervisor.ex}

Similarly, for the \texttt{supervisor.ex} file, we need to update the module name and alias:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/strategy/naive/supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Supervisor} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicTraderSupervisor}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{dynamic\_trader\_supervisor.ex}}{dynamic\_trader\_supervisor.ex}}\label{dynamic_trader_supervisor.ex}

For the \texttt{dynamic\_trader\_supervisor.ex}~file, we need to update the module name, aliases and all the references to the \texttt{Strategy} module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/strategy/naive/dynamic\_trader\_supervisor.ex}
\NormalTok{defmodule }\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{DynamicTraderSupervisor} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Settings}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Formula}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Trader}
  \OperatorTok{...}
  \CommentTok{\# three occurrences of \textasciigrave{}Strategy.update\_status/2\textasciigrave{} call}
  \ConstantTok{Strategy}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)} \OperatorTok{{-}\textgreater{}} \ConstantTok{Formula}\OperatorTok{.}\NormalTok{update\_status}\FunctionTok{(}\OperatorTok{...}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Repo and \texttt{schema} files}{Repo and schema files}}\label{repo-and-schema-files}

As we will use \texttt{Hedgehog.Repo}, we can remove the \texttt{/lib/hedgehog/strategy/naive/repo.ex} file.

We will move both the \texttt{schema/settings.ex} and the \texttt{schema/trading\_status\_enum.ex} out of the \texttt{schema} directory into the main Naive's strategy directory(\texttt{/lib/hedgehog/strategy/naive}). We can now remove the empty \texttt{schema} directory.

\newpage

In line with the other Enum modules' changes, we will update the file name from

\texttt{/lib/hedgehog/strategy/naive/trading\_status\_enum.ex} to

\texttt{/lib/hedgehog/strategy/naive/settings\_status\_enum.ex}.

Inside the file, we will update the module name inside the \texttt{defenum}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/strategy/naive/settings\_status\_enum.ex}
\NormalTok{defenum}\FunctionTok{(}
  \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}\NormalTok{,}
  \VariableTok{:naive\_trading\_status}\NormalTok{,}
  \OtherTok{[}\VariableTok{:on}\NormalTok{, }\VariableTok{:off}\NormalTok{, }\VariableTok{:shutdown}\OtherTok{]}
\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Moving on to the \texttt{settings.ex} file, where we need to update the module name, alias as well as table name and status enum module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/strategy/naive/settings\_status\_enum.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Settings} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}
  \OperatorTok{...}
\NormalTok{  schema }\StringTok{"naive\_strategy\_settings"} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SettingsStatusEnum}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{application.ex}}{application.ex}}\label{application.ex}

The final file that we copied across from the \texttt{naive} umbrella app is \texttt{application.ex}, where we will look into the supervised \texttt{children} list. It was supervising the \texttt{Naive.Repo}, which we don't need any more and \texttt{Naive.Supervisor}, which we renamed and need to put into our new main \texttt{application.ex} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Supervisor}
\end{Highlighting}
\end{Shaded}

After the above addition, we can remove the \texttt{/lib/hedgehog/strategy/naive/application.ex} file.

\subsection{Migration and seeding}\label{migration-and-seeding}

First, we will move two migration files from the \texttt{/apps/naive/priv/repo/migrations/} to \texttt{/priv/repo/migrations}. We will rename the \texttt{20210202223209\_create\_settings.exs} to

\texttt{20210202223209\_create\_naive\_strategy\_settings.exs} where we will update the module name and all references to modules and table name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/migrations/20210202223209\_create\_naive\_strategy\_settings.exs}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateNaiveStrategySettings} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{SettingsStatusEnum}\OperatorTok{.}\NormalTok{create\_type}\FunctionTok{()}

\NormalTok{    create table}\FunctionTok{(}\VariableTok{:naive\_strategy\_settings}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
      \OperatorTok{...}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SettingsStatusEnum}\OperatorTok{.}\NormalTok{type}\FunctionTok{()}\NormalTok{, }\VariableTok{default:} \StringTok{"off"}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
    \OperatorTok{...}

\NormalTok{    create}\FunctionTok{(}\NormalTok{unique\_index}\FunctionTok{(}\VariableTok{:naive\_strategy\_settings}\NormalTok{, }\OtherTok{[}\VariableTok{:symbol}\OtherTok{]}\FunctionTok{))}
\end{Highlighting}
\end{Shaded}

Next, we will rename the \texttt{20210205232303\_update\_trading\_status.exs} to

\texttt{20210205232303\_update\_naive\_strategy\_settings\_status.exs} where we will update the module name and all references to modules:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/migrations/20210205232303\_update\_naive\_strategy\_settings\_status.exs}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{UpdateNaiveStrategySettingsStatus} \KeywordTok{do}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{Ecto}\OperatorTok{.}\ConstantTok{Migration}\OperatorTok{.}\NormalTok{execute}\FunctionTok{(}
      \StringTok{"ALTER TYPE naive\_trading\_status ADD VALUE IF NOT EXISTS \textquotesingle{}shutdown\textquotesingle{}"}
    \FunctionTok{)}
\end{Highlighting}
\end{Shaded}

Finally, we need to merge the code that seeds the naive's strategy settings into the \texttt{/priv/repo/seeds.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/seeds.exs}
\ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Streamer}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{, }\VariableTok{as:} \ConstantTok{StreamerSettings} \CommentTok{\# \textless{}= updated}
\ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{, }\VariableTok{as:} \ConstantTok{NaiveStrategySettings} \CommentTok{\# \textless{}= added}
\OperatorTok{...}
\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserting default streamer settings for symbols"}\FunctionTok{)}
\OperatorTok{...}
\CommentTok{\# updated, \textasciigrave{}on\_conflict\textasciigrave{} added}
\FunctionTok{\{}\NormalTok{count, }\ConstantTok{nil}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert\_all}\FunctionTok{(}\ConstantTok{StreamerSettings}\NormalTok{, maps, }\VariableTok{on\_conflict:} \VariableTok{:nothing}\FunctionTok{)}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserted streamer settings for }\OtherTok{\#\{}\NormalTok{count}\OtherTok{\}}\StringTok{ symbols"}\FunctionTok{)}

\CommentTok{\# below added at the end}
\NormalTok{\%}\FunctionTok{\{}
  \VariableTok{chunks:}\NormalTok{ chunks,}
  \VariableTok{budget:}\NormalTok{ budget,}
  \VariableTok{buy\_down\_interval:}\NormalTok{ buy\_down\_interval,}
  \VariableTok{profit\_interval:}\NormalTok{ profit\_interval,}
  \VariableTok{rebuy\_interval:}\NormalTok{ rebuy\_interval}
\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Application}\OperatorTok{.}\NormalTok{compile\_env}\FunctionTok{(}\VariableTok{:hedgehog}\NormalTok{, }\OtherTok{[}\VariableTok{:strategy}\NormalTok{, }\VariableTok{:naive}\NormalTok{, }\VariableTok{:defaults}\OtherTok{]}\FunctionTok{)}

\NormalTok{base\_settings }\OperatorTok{=}\NormalTok{ \%}\FunctionTok{\{}
  \VariableTok{symbol:} \StringTok{""}\NormalTok{,}
  \VariableTok{chunks:}\NormalTok{ chunks,}
  \VariableTok{budget:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{budget}\FunctionTok{)}\NormalTok{,}
  \VariableTok{buy\_down\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{buy\_down\_interval}\FunctionTok{)}\NormalTok{,}
  \VariableTok{profit\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{profit\_interval}\FunctionTok{)}\NormalTok{,}
  \VariableTok{rebuy\_interval:} \ConstantTok{Decimal}\OperatorTok{.}\NormalTok{new}\FunctionTok{(}\NormalTok{rebuy\_interval}\FunctionTok{)}\NormalTok{,}
  \VariableTok{status:} \StringTok{"off"}\NormalTok{,}
  \VariableTok{inserted\_at:}\NormalTok{ timestamp,}
  \VariableTok{updated\_at:}\NormalTok{ timestamp}
\FunctionTok{\}}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserting default naive strategy settings for symbols"}\FunctionTok{)}

\NormalTok{maps }\OperatorTok{=}\NormalTok{ symbols}
  \OperatorTok{|\textgreater{}} \ConstantTok{Enum}\OperatorTok{.}\NormalTok{map}\FunctionTok{(}\OperatorTok{\&}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}\NormalTok{base\_settings }\OperatorTok{|} \VariableTok{symbol:} \OperatorTok{\&}\DecValTok{1}\OtherTok{[}\StringTok{"symbol"}\OtherTok{]}\FunctionTok{\}))}

\FunctionTok{\{}\NormalTok{count, }\ConstantTok{nil}\FunctionTok{\}} \OperatorTok{=} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert\_all}\FunctionTok{(}\ConstantTok{NaiveStrategySettings}\NormalTok{, maps, }\VariableTok{on\_conflict:} \VariableTok{:nothing}\FunctionTok{)}

\ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Inserted naive strategy settings for }\OtherTok{\#\{}\NormalTok{count}\OtherTok{\}}\StringTok{ symbols"}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Configuration}\label{configuration}

The seeding script above requires additional configuration that we will add now to the \texttt{/config/config.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /config/config.exs}
\NormalTok{config }\VariableTok{:hedgehog}\NormalTok{,}
  \OperatorTok{...}
  \VariableTok{strategy:} \OtherTok{[}
    \VariableTok{naive:} \OtherTok{[}
      \VariableTok{defaults:}\NormalTok{ \%}\FunctionTok{\{}
        \VariableTok{chunks:} \DecValTok{5}\NormalTok{,}
        \VariableTok{budget:} \DecValTok{1000}\NormalTok{,}
        \VariableTok{buy\_down\_interval:} \StringTok{"0.0001"}\NormalTok{,}
        \VariableTok{profit\_interval:} \StringTok{"{-}0.0012"}\NormalTok{,}
        \VariableTok{rebuy\_interval:} \StringTok{"0.001"}
      \FunctionTok{\}}
    \OtherTok{]}
  \OtherTok{]}
\end{Highlighting}
\end{Shaded}

\subsection{Tests}\label{tests}

The final part of the \texttt{naive} application that we need to copy across are tests located in \texttt{/apps/naive/test}. We will create new directories \texttt{/test/hedgehog/strategy} and paste there the \texttt{/apps/naive/test/naive\_test.exs} file and \texttt{/apps/naive/test/naive} directory.

First, we will update the \texttt{naive\_test.exs} by updating its module name and aliases:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /test/hedgehog/strategy/naive\_test.exs}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{NaiveTest} \KeywordTok{do}
  \OperatorTok{...}
\NormalTok{  doctest }\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}

  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order} \CommentTok{\# \textless{}= to be migrated...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Settings}\NormalTok{, }\VariableTok{as:} \ConstantTok{TradingSettings}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}
\end{Highlighting}
\end{Shaded}

Next, we will rename the \texttt{/test/hedgehog/strategy/naive/strategy\_test.exs} to

\texttt{/test/hedgehog/strategy/naive/formula\_test.exs} and update its module name and aliases:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /test/hedgehog/strategy/naive/formula\_test.exs}
\NormalTok{defmodule }\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{FormulaTest} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{BinanceMock}    \CommentTok{\# \textless{}= added}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Strategy}\OperatorTok{.}\ConstantTok{Naive}\OperatorTok{.}\ConstantTok{Formula}
  \OperatorTok{...}
  \CommentTok{\# update all references to \textasciigrave{}Strategy\textasciigrave{} with \textasciigrave{}Formula\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

Finally, we will overwrite the \texttt{test\_helper.exs} based on the one from the \texttt{naive} app:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /test/test\_helper.exs}
\ConstantTok{ExUnit}\OperatorTok{.}\NormalTok{start}\FunctionTok{(}\VariableTok{capture\_log:} \ConstantTok{true}\FunctionTok{)}

\ConstantTok{Application}\OperatorTok{.}\NormalTok{ensure\_all\_started}\FunctionTok{(}\VariableTok{:mimic}\FunctionTok{)}

\ConstantTok{Mimic}\OperatorTok{.}\NormalTok{copy}\FunctionTok{(}\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{BinanceMock}\FunctionTok{)}
\ConstantTok{Mimic}\OperatorTok{.}\NormalTok{copy}\FunctionTok{(}\ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Dependencies}\label{dependencies}

The final part of the integration will be to move dependencies to the \texttt{mix.exs} file:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /mix.exs}
  \KeywordTok{defp}\NormalTok{ deps }\KeywordTok{do}
    \OtherTok{[}
       \OperatorTok{...}
       \FunctionTok{\{}\VariableTok{:mimic}\NormalTok{, }\StringTok{"\textasciitilde{}\textgreater{} 1.7"}\NormalTok{, }\VariableTok{only:} \OtherTok{[}\VariableTok{:test}\NormalTok{, }\VariableTok{:integration}\OtherTok{]}\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

The final test will be to fetch the required deps and run the unit tests:

\begin{verbatim}
$ mix deps.get
...
$ mix setup
...
$ mix test --only unit --no-start
...
......
Finished in 0.1 seconds (0.1s async, 0.00s sync)
17 tests, 0 failures, 6 excluded
\end{verbatim}

We will see a lot of warnings as we haven't yet migrated the \texttt{DataWarehouse} application. Either way, we received the confirmation that unit tests ran successfully. We are also able to run the application to see that it can go through the trading cycle:

\begin{verbatim}
$ iex -S mix phx.server
...
iex(1)> alias Hedgehog.Strategy.Naive
...
iex(2)> alias Hedgehog.Streamer.Binance
...
iex(3)> Binance.start_streaming("XRPUSDT")
...
iex(4)> Naive.start_trading("XRPUSDT")
...
[info] Position (XRPUSDT/1715703392316): Placing a BUY order @ 0.50650000,
quantity: 394.86000000
[info] Position (XRPUSDT/1715704251578): The BUY order is now partially filled
[info] Position (XRPUSDT/1715704251578): The BUY order is now filled. Placing a
SELL order @ 0.50690000, quantity: 394.86000000
[info] Position (XRPUSDT/1715704251578): The SELL order is now partially filled
[info] Position (XRPUSDT/1715704251578): Trade cycle finished
[info] Position (XRPUSDT/1715704342038): Placing a BUY order @ 0.50680000,
quantity: 394.63000000
\end{verbatim}

The above confirms that our trading strategy works - we have successfully integrated the \texttt{naive} app. Things will be easier from now on.

\section{\texorpdfstring{Reintegrating the \texttt{data\_warehouse} app}{Reintegrating the data\_warehouse app}}\label{reintegrating-the-data_warehouse-app}

Inside the new Phoenix application, we will reintegrate the previously named \texttt{data\_warehoure} app into \texttt{data/collector} and \texttt{data/publisher} ``namespaces''.

We will start by creating a new directory called \texttt{data} inside the \texttt{lib/headgehog} directory. Inside the \texttt{data} directory, we will create a \texttt{collector} directory. We will update all the \texttt{subscriber\_*} modules to \texttt{collector\_*}.

We will kick off the transition by copying files from the \texttt{/apps/data\_warehouse/lib/data\_warehouse/} directory to \texttt{/lib/hedgehog/} and renaming them as follows:

\begin{itemize}
\tightlist
\item
  \texttt{subscriber\_supervisor.ex} -\textgreater{} \texttt{data/collector/collector\_supervisor.ex}
\item
  \texttt{subscriber/dynamic\_supervisor.ex} -\textgreater{} \texttt{data/collector/dynamic\_worker\_supervisor.ex}
\item
  \texttt{subscriber/worker.ex} -\textgreater{} \texttt{data/collector/worker.ex}
\item
  \texttt{publisher.ex} -\textgreater{} \texttt{data/publisher.ex}
\item
  \texttt{schema/order.ex} -\textgreater{} \texttt{exchange/order.ex}
\item
  \texttt{schema/trade\_event.ex} -\textgreater{} \texttt{exchange/trade\_event.ex} (overwrite)
\item
  \texttt{schema/subscriber\_settings.ex} -\textgreater{} \texttt{data/collector/settings.ex}
\item
  \texttt{schema/subscriber\_status\_enum.ex} -\textgreater{} \texttt{data/collector/settings\_status\_enum.ex}
\item
  \texttt{../data\_warehouse.ex} -\textgreater{} \texttt{data/collector.ex}
\end{itemize}

Now, we will update the new(copied/renamed) files one by one.

\subsection{\texorpdfstring{\texttt{exchange/order.ex}}{exchange/order.ex}}\label{exchangeorder.ex}

We will start with \texttt{exchange/order.ex}, where we will update the module name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/exchange/order.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{exchange/trade\_event.ex}}{exchange/trade\_event.ex}}\label{exchangetrade_event.ex}

This file got overwritten by the contents from the \texttt{data\_warehoure} app - we just need to update the module name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/exchange/trade\_event.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{data/publisher.ex}}{data/publisher.ex}}\label{datapublisher.ex}

This module uses tons of other modules, including \texttt{Repo} - we need to update all of these:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/publisher.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Publisher} \KeywordTok{do}
\OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}                 \CommentTok{\# \textless{}= added}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}  \CommentTok{\# \textless{}= added}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{arg}\FunctionTok{)} \KeywordTok{do} \CommentTok{\# \textless{}= renamed the \textasciigrave{}start\_link/1\textasciigrave{} function }
    \OperatorTok{...}
  \KeywordTok{end}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ run}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
    \OperatorTok{...}
 \FunctionTok{\})} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{transaction}\FunctionTok{(}
      \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
\NormalTok{        from}\FunctionTok{(}\NormalTok{te }\KeywordTok{in} \ConstantTok{TradeEvent}\NormalTok{,}
          \OperatorTok{...}
        \FunctionTok{)}
        \OperatorTok{|\textgreater{}} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{stream}\FunctionTok{()}
    \OperatorTok{...}
  \KeywordTok{end}

  \KeywordTok{defp}\NormalTok{ publish\_trade\_event}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    new\_trade\_event }\OperatorTok{=}
\NormalTok{      struct}\FunctionTok{(}
        \ConstantTok{TradeEvent}\NormalTok{,}
        \OperatorTok{...}
      \FunctionTok{)}

    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \OperatorTok{...}
    \FunctionTok{)}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{data/collector.ex}}{data/collector.ex}}\label{datacollector.ex}

This module was an interface for both collectors and publishers. From now on, it will only cater for collectors:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/collector.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector} \KeywordTok{do}
  \OtherTok{@moduledoc """}
\CommentTok{ Documentation for }\InformationTok{\textasciigrave{}Hedgehog.Data.Collector\textasciigrave{}}\CommentTok{.}
\CommentTok{ }\OtherTok{"""}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{DynamicWorkerSupervisor}

  \KeywordTok{def}\NormalTok{ start\_storing}\FunctionTok{(}\NormalTok{stream, symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicWorkerSupervisor}\OperatorTok{.}\NormalTok{start\_worker}\FunctionTok{()}
  \KeywordTok{end}

  \KeywordTok{def}\NormalTok{ stop\_storing}\FunctionTok{(}\NormalTok{stream, symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \OperatorTok{|\textgreater{}} \ConstantTok{DynamicWorkerSupervisor}\OperatorTok{.}\NormalTok{stop\_worker}\FunctionTok{()}
  \KeywordTok{end}

  \CommentTok{\# remove \textasciigrave{}publish\_data/1\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{data/collector/collector\_supervisor.ex}}{data/collector/collector\_supervisor.ex}}\label{datacollectorcollector_supervisor.ex}

In the case of the main collector supervisor, we need to update the aliases:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/collector/collector\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{CollectorSupervisor} \KeywordTok{do}
\OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{DynamicWorkerSupervisor}
\OperatorTok{...}
  \OtherTok{@registry} \VariableTok{:collector\_workers}
\OperatorTok{...}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{\_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\ConstantTok{DynamicWorkerSupervisor}\NormalTok{, }\OtherTok{[]}\FunctionTok{\}}\NormalTok{,}
      \FunctionTok{\{}\ConstantTok{Task}\NormalTok{,}
        \KeywordTok{fn} \OperatorTok{{-}\textgreater{}}
          \ConstantTok{DynamicWorkerSupervisor}\OperatorTok{.}\NormalTok{autostart\_workers}\FunctionTok{()}
        \KeywordTok{end}\FunctionTok{\}}
     \OtherTok{]}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{/data/collector/dynamic\_worker\_supervisor.ex}}{/data/collector/dynamic\_worker\_supervisor.ex}}\label{datacollectordynamic_worker_supervisor.ex}

In the case of the dynamic worker supervisor that we renamed, we need to update the module name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/collector/dynamic\_worker\_supervisor.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{DynamicWorkerSupervisor} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{Settings}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{Worker}
  \OperatorTok{...}
  \OtherTok{@registry} \VariableTok{:collector\_workers}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ autostart\_workers }\KeywordTok{do}
    \ConstantTok{Repo}\OperatorTok{.}\NormalTok{all}\FunctionTok{(}
\NormalTok{      from}\FunctionTok{(}\NormalTok{s }\KeywordTok{in} \ConstantTok{Settings}\NormalTok{,}
   \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ update\_status}\FunctionTok{(}\NormalTok{topic, status}\FunctionTok{)}
       \KeywordTok{when}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{and}\NormalTok{ is\_binary}\FunctionTok{(}\NormalTok{status}\FunctionTok{)} \KeywordTok{do}
\NormalTok{ \%}\ConstantTok{Settings}\FunctionTok{\{}
  \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{/data/collector/settings\_status\_enum.ex}}{/data/collector/settings\_status\_enum.ex}}\label{datacollectorsettings_status_enum.ex}

As in the case of other settings' status enums - we need to update the module name and field name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/collector/settings\_status\_enum.ex}
\ImportTok{import} \ConstantTok{EctoEnum}

\NormalTok{defenum}\FunctionTok{(}\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}\NormalTok{, }\VariableTok{:collector\_status}\NormalTok{, }\OtherTok{[}\VariableTok{:on}\NormalTok{, }\VariableTok{:off}\OtherTok{]}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{/data/collector/settings.ex}}{/data/collector/settings.ex}}\label{datacollectorsettings.ex}

For the settings schema, we need to update module name, aliases, and table name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/collector/settings.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{Settings} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}
  \OperatorTok{...}
\NormalTok{  schema }\StringTok{"collector\_settings"} \KeywordTok{do}
    \OperatorTok{...}
\NormalTok{    field}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SettingsStatusEnum}\FunctionTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{/data/collector/worker.ex}}{/data/collector/worker.ex}}\label{datacollectorworker.ex}

The final module from the \texttt{data\_warehouse} app is a collector worker, where we will update the module name and a few references:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/collector/worker.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{Worker} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{Order}      \CommentTok{\# \textless{}= added}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent} \CommentTok{\# \textless{}= added}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}                \CommentTok{\# \textless{}= added}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{Logger}\OperatorTok{.}\NormalTok{info}\FunctionTok{(}\StringTok{"Collector worker is subscribing to }\OtherTok{\#\{}\NormalTok{topic}\OtherTok{\}}\StringTok{"}\FunctionTok{)}

    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
      \OperatorTok{...}
     \FunctionTok{)}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, state}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}

\NormalTok{    struct!}\FunctionTok{(}\ConstantTok{TradeEvent}\NormalTok{, opts}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert}\FunctionTok{()}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{Binance}\OperatorTok{.}\ConstantTok{Order}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ order, state}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}

\NormalTok{    struct}\FunctionTok{(}\ConstantTok{Order}\NormalTok{, data}\FunctionTok{)}
    \OperatorTok{|\textgreater{}} \ConstantTok{Map}\OperatorTok{.}\NormalTok{merge}\FunctionTok{(}\NormalTok{\%}\FunctionTok{\{}
      \OperatorTok{...}
    \FunctionTok{\})}
    \OperatorTok{|\textgreater{}} \ConstantTok{Repo}\OperatorTok{.}\NormalTok{insert}\FunctionTok{(}
    \OperatorTok{...}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ via\_tuple}\FunctionTok{(}\NormalTok{topic}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:via}\NormalTok{, }\ConstantTok{Registry}\NormalTok{, }\FunctionTok{\{}\VariableTok{:collector\_workers}\NormalTok{, topic}\FunctionTok{\}\}}
\end{Highlighting}
\end{Shaded}

This finishes the module updates. We can move on to the other files from the \texttt{data\_warehouse} application.

\subsection{Supervision tree}\label{supervision-tree}

When we were copying the modules from the \texttt{data\_warehouse} app, we skipped over its \texttt{application.ex} module. Looking inside, we can see that it was supervising the \texttt{DataWarehouse.SubscriberSupervisor} (currently renamed to \texttt{Hedgehog.Data.Collector.CollectorSupervisor}) - we need to add it to the main supervision tree of our new application:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{CollectorSupervisor}
\end{Highlighting}
\end{Shaded}

\subsection{Migrations}\label{migrations}

We will copy three migration files across from the \texttt{data\_warehouse} app (the

\texttt{/apps/data\_warehouse/priv/repo/migrations/} directory) to the new Phoenix application (the

\texttt{priv/repo/migrations/} directory).

In the case of the \texttt{20210227230123\_create\_subscriber\_settings.exs}, we need to rename it to

\texttt{20210227230123\_create\_collector\_settings.exs}.

For all three of the migration files, we need to update module names:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/migrations/20210222224514\_create\_trade\_events.exs}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateTradeEvents} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/migrations/20210222224522\_create\_orders.exs}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateOrders} \KeywordTok{do}
\end{Highlighting}
\end{Shaded}

\newpage

for the final file we will also change alias and table name:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /priv/repo/migrations/20210227230123\_create\_collector\_settings.exs}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Repo}\OperatorTok{.}\ConstantTok{Migrations}\OperatorTok{.}\ConstantTok{CreateSubscriberSettings} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Collector}\OperatorTok{.}\ConstantTok{SettingsStatusEnum}

  \KeywordTok{def}\NormalTok{ change }\KeywordTok{do}
    \ConstantTok{SettingsStatusEnum}\OperatorTok{.}\NormalTok{create\_type}\FunctionTok{()}

\NormalTok{    create table}\FunctionTok{(}\VariableTok{:collector\_settings}\NormalTok{, }\VariableTok{primary\_key:} \ConstantTok{false}\FunctionTok{)} \KeywordTok{do}
      \OperatorTok{...}
\NormalTok{      add}\FunctionTok{(}\VariableTok{:status}\NormalTok{, }\ConstantTok{SettingsStatusEnum}\OperatorTok{.}\NormalTok{type}\FunctionTok{()}\NormalTok{, }\VariableTok{default:} \StringTok{"off"}\NormalTok{, }\VariableTok{null:} \ConstantTok{false}\FunctionTok{)}
    \OperatorTok{...}
\NormalTok{    create}\FunctionTok{(}\NormalTok{unique\_index}\FunctionTok{(}\VariableTok{:collector\_settings}\NormalTok{, }\OtherTok{[}\VariableTok{:topic}\OtherTok{]}\FunctionTok{))}
\end{Highlighting}
\end{Shaded}

The above changes finish the integration of the \texttt{data\_warehouse} application. We can go ahead and drop the database, set the application again, and confirm that it still works:

\begin{verbatim}
$ mix ecto.drop
...
$ mix setup
...
$ mix test --only unit --no-start
...
..........
Finished in 0.1 seconds (0.1s async, 0.00s sync)
17 tests, 0 failures, 6 excluded
$ iex -S mix phx.server
...
iex(1)> alias Hedgehog.Strategy.Naive
...
iex(2)> alias Hedgehog.Streamer.Binance
...
iex(3)> alias Hedgehog.Data.Collector
...
iex(4)> Collector.start_storing("TRADE_EVENTS", "XRPUSDT")
...
iex(5)> Collector.start_storing("ORDERS", "XRPUSDT")
...
iex(6)> Binance.start_streaming("XRPUSDT")
...
iex(7)> Naive.start_trading("XRPUSDT")
...
[debug] QUERY OK source="trade_events" ...
INSERT INTO "trade_events"
...
[debug] QUERY OK source="orders" ...
INSERT INTO "orders"
\end{verbatim}

The above log messages confirm that we are streaming trade events from Binance, placing orders, and storing both in the database.

This finishes the integration of the \texttt{data\_warehouse} application.

\section{\texorpdfstring{Reintegrating the \texttt{indicator} app}{Reintegrating the indicator app}}\label{reintegrating-the-indicator-app}

The final application that we will integrate into our new Phoenix app is \texttt{indicator}, which luckily has only three files that we will move across.

We will use this opportunity to rename the \texttt{indicators} to \texttt{aggregators}.

Let's start by creating a new directory called \texttt{aggregator} inside the \texttt{/lib/hedgehog/data/} directory.

We will copy the \texttt{/apps/indicator/lib/indicator/ohlc} directory and the

\texttt{/apps/indicator/lib/indicator/ohlc.ex} file into it.

We will also copy the \texttt{/apps/indicator/lib/indicator.ex} to the \texttt{/lib/hedgehog/data} directory and rename it to \texttt{aggregator.ex}.

Now, we can update each file to fit the new naming convention.

\subsection{/data/aggregator.ex}\label{dataaggregator.ex}

Here, we need to update the module name a reference to the worker module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/aggregator.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Aggregator} \KeywordTok{do}
  \OtherTok{@moduledoc """}
\CommentTok{ Documentation for }\InformationTok{\textasciigrave{}Hedgehog.Data.Aggregator\textasciigrave{}}\CommentTok{.}
\CommentTok{ }\OtherTok{"""}

  \KeywordTok{def}\NormalTok{ aggregate\_ohlcs}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \ConstantTok{DynamicSupervisor}\OperatorTok{.}\NormalTok{start\_child}\FunctionTok{(}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Aggregator}\OperatorTok{.}\ConstantTok{DynamicWorkerSupervisor}\NormalTok{,}
 \FunctionTok{\{}\ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Aggregator}\OperatorTok{.}\ConstantTok{Ohlc}\OperatorTok{.}\ConstantTok{Worker}\NormalTok{, symbol}\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{/data/aggregator/ohlc.ex}\label{dataaggregatorohlc.ex}

Inside the ohlc module we need to update the reference to the trade event and pubsub:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/aggregator/ohlc.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Aggregator}\OperatorTok{.}\ConstantTok{Ohlc} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}
  \OperatorTok{...}
  \KeywordTok{defp}\NormalTok{ maybe\_broadcast}\FunctionTok{(}\NormalTok{\%}\ConstantTok{\_\_MODULE\_\_}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ ohlc}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{broadcast}\FunctionTok{(}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{/data/aggregator/ohlc/worker.ex}\label{dataaggregatorohlcworker.ex}

The final file to update will be the worker module, where we need to update the references to pubsub and the ohlc module:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/data/aggregator/ohlc/worker.ex}
\KeywordTok{defmodule} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Aggregator}\OperatorTok{.}\ConstantTok{Ohlc}\OperatorTok{.}\ConstantTok{Worker} \KeywordTok{do}
  \OperatorTok{...}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Aggregator}\OperatorTok{.}\ConstantTok{Ohlc} \CommentTok{\# \textless{}= added}
  \ImportTok{alias} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Exchange}\OperatorTok{.}\ConstantTok{TradeEvent}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ init}\FunctionTok{(}\NormalTok{symbol}\FunctionTok{)} \KeywordTok{do}
    \OperatorTok{...}
    \ConstantTok{Phoenix}\OperatorTok{.}\ConstantTok{PubSub}\OperatorTok{.}\NormalTok{subscribe}\FunctionTok{(}
      \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{PubSub}\NormalTok{,}
  \OperatorTok{...}
  \KeywordTok{def}\NormalTok{ handle\_info}\FunctionTok{(}\NormalTok{\%}\ConstantTok{TradeEvent}\FunctionTok{\{\}} \OperatorTok{=}\NormalTok{ trade\_event, ohlc}\FunctionTok{)} \KeywordTok{do}
    \FunctionTok{\{}\VariableTok{:noreply}\NormalTok{, }\ConstantTok{Ohlc}\OperatorTok{.}\NormalTok{process}\FunctionTok{(}\NormalTok{ohlc, trade\_event}\FunctionTok{)\}}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

\subsection{Supervision tree}\label{supervision-tree-1}

A quick look at the \texttt{application.ex} module of the \texttt{indicator} app will tell us that we need to add a dynamic supervisor to the supervision tree of the new app (we referred to it already as

\texttt{Hedgehog.Data.Aggregator.DynamicWorkerSupervisor} inside the \texttt{Hedgehog.Data.Aggregator} as we were updating it):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# /lib/hedgehog/application.ex}
  \KeywordTok{def}\NormalTok{ start}\FunctionTok{(}\NormalTok{\_type, \_args}\FunctionTok{)} \KeywordTok{do}
\NormalTok{    children }\OperatorTok{=} \OtherTok{[}
      \OperatorTok{...}
      \FunctionTok{\{}\ConstantTok{DynamicSupervisor}\NormalTok{,}
       \VariableTok{strategy:} \VariableTok{:one\_for\_one}\NormalTok{, }\VariableTok{name:} \ConstantTok{Hedgehog}\OperatorTok{.}\ConstantTok{Data}\OperatorTok{.}\ConstantTok{Aggregator}\OperatorTok{.}\ConstantTok{DynamicWorkerSupervisor}\FunctionTok{\}}
    \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

The above change finishes integrating the \texttt{indicator} app and the changes in this chapter, as it was the last application to be merged in.

We can make the last check that everything works by starting the streaming and aggregating:

\begin{verbatim}
$ mix ecto.drop
...
$ mix setup
...
$ iex -S mix phx.server
...
iex(1)> alias Hedgehog.Streamer.Binance
...
iex(2)> alias Hedgehog.Data.Aggregator
...
iex(3)> Aggregator.aggregate_ohlcs("XRPUSDT")
...
iex(4)> Binance.start_streaming("XRPUSDT")
...
[debug] Broadcasting OHLC: %Hedgehog.Data.Aggregator.Ohlc{symbol: "XRPUSDT",
start_time: 1717173780, duration: 1, open: "0.51350000", high: "0.51380000",
low: "0.51350000", close: "0.51370000"}
\end{verbatim}

The above log confirms that we have a fully working aggregation that gets broadcasted and could be stored in the database or used inside the strategy.

It was a lot of repetitive copy/moving/renaming - thank you for sticking with me through this. After our migration to Phoenix application we will have a great start into potential deploying, which we will focus on in the upcoming chapter!

{[}Note{]} Please remember to run the \texttt{mix\ format} to keep things nice and tidy.

The source code for this chapter can be found on \href{https://github.com/Cinderella-Man/hands-on-elixir-and-otp-cryptocurrency-trading-bot-source-code/tree/chapter_23}{GitHub}

\end{document}
