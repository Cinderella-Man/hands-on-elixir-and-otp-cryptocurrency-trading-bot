stream-live-cryptocurrency-prices-from-the-binance-wss
objectives
create-a-new-umbrella-app
create-a-supervised-application-inside-an-umbrella
connect-to-binances-websocket-stream-using-the-websockex-module
decode-incoming-events-using-the-jason-module
create-a-naive-trading-strategy---a-single-trader-process-without-supervision
objectives-1
initializiation
how-trading-strategy-will-work
implementation-of-the-first-scenario
implementation-of-the-second-scenario
implementation-of-the-third-scenario
implementation-fallback-scenario
updating-the-naive-interface
updating-streamer-app
access-details-to-binance
test-run
introduce-pubsub-as-a-communication-method
objectives-2
design
implementation
mock-the-binance-api
objectives-3
design-1
create-binancemock-app
implement-getting-exchange-info
implement-placing-buy-and-sell-orders
implement-order-retrival
implement-callback-for-incoming-trade-events
upgrade-trader-and-config
test-the-implementation
enable-parallel-trading-on-multiple-symbols
objectives-4
introduction---architectural-design
update-application-supervisor
add-interface-method
implement-naive.symbolsupervisor
implement-naive.leader
updating-the-leader-module
updating-the-naive.trader-module
finalizing-naive.leader-implementation
iex-testing
introduce-a-buy_down_interval-to-make-a-single-trader-more-profitable
objectives-5
why-we-need-to-buy-below-the-current-price-feature-overview
naive.trader-implementation
naive.leader-implementation
iex-testing-1
introduce-a-trader-budget-and-calculating-the-quantity
objectives-6
fetch-step_size
append-budget-and-step_size-to-the-traders-state-inside-the-leader
append-budget-and-step_size-to-the-traders-state
calculate-quantity
iex-testing-2
add-support-for-multiple-transactions-per-order
objectives-7
the-issue-with-the-current-implementation
improve-buy-order-filled-callback
implement-buy-order-filled-callback
improve-sell-order-callback
test-the-implementation-1
run-multiple-traders-in-parallel
objectives-8
describe-and-design-the-required-functionality
implement-rebuy-inside-naive.trader
implement-rebuy-in-the-naive.leader
improve-logs-by-assigning-ids-to-traders
test-the-implementation-2
fine-tune-trading-strategy-per-symbol
objectives-9
describe-and-design-the-required-functionality-1
add-docker-to-project
set-up-ecto-inside-the-naive-app
create-and-migrate-the-db
seed-symbols-settings
update-the-naive.leader-to-fetch-settings
supervise-and-autostart-streaming
objectives-10
describe-and-design-the-required-functionality-2
register-the-streamer.binance-processes-with-names
set-up-ecto-inside-the-streamer-app
create-and-migrate-the-db-1
seed-default-settings
implement-the-supervision-tree-and-start-streaming-functionality
implement-the-stop-functionality
implement-the-autostart-streaming-functionality
test-the-implementation-3
start-stop-shutdown-and-autostart-trading
objectives-11
describe-and-design-the-required-functionality-3
re-implement-the-start-trading-functionality
implement-the-stop-trading-functionality
implement-the-autostart-trading-functionality
implement-the-shutdown-trading-functionality
abstract-duplicated-supervision-code
objectives-12
overview-of-requirements
pseudo-generalize-core.servicesupervisor-module
utilize-pseudo-generalized-code-inside-the-naive-dynamicsymbolsupervisor
implement-a-truly-generic-core.servicesupervisor
first-path-starting-with-the-fetch_symbols_to_start0-function
second-path-starting-with-the-update_status2
third-path-starting-with-the-get_pid1-function
remove-boilerplate-using-use-macro
use-the-core.servicesupervisor-module-inside-the-streamer-application
store-trade-events-and-orders-inside-the-database
objectives-13
overview-of-requirements-1
create-a-new-data_warehouse-application-in-the-umbrella
connect-to-the-database-using-ecto
store-trade-events-data
store-orders-data
implement-supervision
create-subscriber_settings-table
redesign-supervision-using-registry
create-the-datawarehouse.subscriber.dynamicsupervisor-module
register-worker-processes-using-via
create-a-new-supervision-level-for-registry-task-and-the-dynamicsupervisor
link-the-subscribersupervisor-to-the-application
add-interface
test
backtest-trading-strategy
objectives-14
overview-of-requirements-2
implement-the-storing-task
test-the-backtesting
end-to-end-testing
objectives-15
decide-on-the-tested-functionality
implement-basic-test
introduce-environment-based-config-files
add-convenience-aliases
cache-initial-seed-data-inside-a-file
update-seeding-scripts-to-use-the-binancemock
introduce-the-core-application
mox-rocks
objectives-16
introduction-to-mock-based-tests
add-the-mox-package
investigate-the-naive.trader-module
mock-the-binance-module
mock-the-naiveleader-module
mock-the-phoenix.pubsub-module
mock-the-logger-module
implement-a-test-of-the-naive.trader-module
define-an-alias-to-run-unit-tests
functional-elixir
objectives-17
the-reasoning-behind-the-functional-approach
simplifying-by-splitting
abstracting-the-pure-logic
place-a-buy-order-rules
race-condition-rules
place-a-sell-order-rules
fetch-the-buy-order-rules
terminate-trader-rules
fetch-the-sell-order-rules
trigger-rebuy-rules
the-final-clause-rules
changes-to-the-naive.trader-module
naive.trader---place-buy-order
naive.trader---race-condition-clause
naive.trader---place-a-sell-order
naive.trader---fetch-the-buy-order
naive.trader---terminate-the-trader
naive.trader---fetch-the-sell-order
naive.trader---triggering-rebuy
naive.trader---the-final-ignore-clause
dealing-with-dirty-code
making-dirty-code-testable
passing-functions-arguments
passing-grouped-functions-as-a-context
passing-grouped-modules-as-a-context
injecting-modules-to-modules-attributes-based-on-the-configuration
the-power-with-in
idiomatic-error-handling
do-or-not-to-do
final-thoughts
idiomatic-otp
objectives-18
the-concept
initial-implementation
maybe-functions
testing
supervision
idiomatic-solution
