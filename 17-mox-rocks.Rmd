# Mox rocks

## Objectives
- introduction to mock based tests
- add the Mox package
- investigate the `Naive.Trader` module
  * mock binance client

## Introduction to mock based tests

In the previous chapter, we've implemented the end-to-end test. It required a lot of prep work as well as we were able to see the downsides of this type of test clearly:

- we will be unable to run more than one end-to-end test in parallel as they rely on the database's state
- we need to set up the database before every test run
- we need to start processes in the correct order with the suitable parameters
- we needed to wait a (guessed) hardcoded amount of time that it will take to finish the trading(this is extremely bad as it will cause randomly failing tests as people will make the time shorter to speed up tests)
- we wouldn't be able to quickly pinpoint which part error originated from as the test spans over a vast amount of the system
- logging was polluting our test output

How could we fix the above issues?

The most common way is to limit the scope of the test. Instead of testing the whole trading flow, we could focus on testing a single `Naive.Trader` process.

Focusing on a single trader process would remove the requirement for starting multiple processes before testing, but it would also bring its own challenges.

Let's look at a concrete example:

When the `Naive.Trader` process starts, it subscribes to the `TRADE_EVENTS:#{symbol}` PubSub topic. It also broadcasts updates of the orders it's placed to the `ORDERS:#{symbol}` PubSub topic.

How could we break the link between the `Naive.Trader` and the PubSub(or any other module it depends on)?

We could utilize the trick that we used for the `Binance` module. We could create a module that provides the same functions as the `PubSub` module.

We know that the trader process calls `Phoenix.PubSub.subscribe/2` and `Phoenix.PubSub.broadcast/3` functions. We could implement a module that contains the same functions:

```{r, engine = 'elixir', eval = FALSE}
defmodule Test.PubSub do
    def subscribe(_, _), do: :ok
    def broadcast(_, _, _), do: :ok
end
```

The above module would satisfy the PubSub's functionality required by the `Naive.Trader` module, but this solution comes with a couple of drawbacks:

- it doesn't validate incoming arguments. It just ignores them, which is a missed opportunity to confirm that the PubSub module was called with the expected values.
- we cannot define the results of calling the above functions specific to test, for example, if the first argument is `true` return `false`, otherwise `true`.

Using the `mox` module would fix both of the problems mentioned above. With the `mox` module we can define add-hoc function implemention per test:

```{r, engine = 'elixir', eval = FALSE}
    # inside test file
    test ...
        Test.PubSubMock
        |> expect(:subscribe, fn (_module, "TRADE_EVENTS:XRPUSDT") -> :ok end)
        |> expect(:broadcast, fn (_module, "ORDERS:XRPUSDT", _order) -> :ok end)
```

There are multiple benefits to using the `mox` module instead of handcrafting the implementation:

- it allows defining functions that will pattern match values specific to each test(as in the case of the "usual" pattern matching, they will break when called with unexpected values)
- it allows defining implementations of the mocked functions based on incoming(test specific) values
- it can validate that all defined mocked functions have been called when the test was run
- it comes with its own tests, so we don't need to test it as it would need with our custom handcrafted mimicking module implementation

But there's a catch* ;)

For the `mox` to know what sort of functions the module provides, it needs to know its `behaviour`.

In Elixir, to define a behaviour of the module, we need to add the `@callback` attributes to it:

```{r, engine = 'elixir', eval = FALSE}
  defmodule Core.Test.PubSub do
    @type t :: atom
    @type topic :: binary
    @type message :: term

    @callback subscribe(t, topic) :: :ok | {:error, term}
    @callback broadcast(t, topic, message) :: :ok | {:error, term}
  end
```

A `behaviour` can be defined in a separate module if we are working with 3rd party module that doesn't provide it(like in the case of the `Phoenix.PubSub` module).

Note: The additional benefit of using the `behaviours` is that we could tell Elixir that our module *implements* the behaviour by adding the `@behaviour` attribute:

```{r, engine = 'elixir', eval = FALSE}
def MyPubSub do
    @behaviour Core.Test.PubSub
    ...
```

Using the above will cause Elixir to validate at compile time that the `MyPubSub` module implements all functions defined inside the `Core.Test.PubSub` module(or it will cause compilation error).

Back to the main topic. We figured out that we could mock all of the modules that the `Naive.Trader` depends on using the `mox` module. 

But, how would we tell the `Naive.Trader` to use the mocked modules instead of the "real" ones when we run tests?

We could make all modules that the `Naive.Trader` depends on be dynamically injected from the configuration(based on the environment).

The second requirement to make `mox` work is to define the mocks upfront using the `Mox.defmock/2` function. It will dynamically define a new module(first value) that will be limited by the passed behaviour(we will only be able to mock[inside tests] functions defined as a part of that behaviour). 

To sum up, there are a few steps to get the `mox` running:

- implement behaviours that we would like to mock(as most of the packages[like `Phoenix.PubSub`] are not coming with those)
- define mock module using the `Mox.defmock` function
- modify the application's configuration to use the mocked module(s)
- specify mocked module's expectation inside the test

Let's move to the implementation.

## Add the `mox` package

First let's add the `mox` package to the `naive` application's dependencies:

```{r, engine = 'elixir', eval = FALSE}
# /apps/naive/mix.exs
  ...
  defp deps do
    [
      ...
      {:mox, "~> 1.0", only: :test},
      ...
```

We can now run `mix deps.get` to fetch the `mox` package.

## Investigate the `Naive.Trader` module

Let's investigate the `Naive.Trader` module(`/apps/naive/lib/naive/trader.ex`). We are looking for all calls to other modules - we can see:

- `Logger.info/2`
- `Phoenix.PubSub.subscribe/2`
- `@binance_client.order_limit_buy/4`
- `Naive.Leader.notify/2`
- `@binance_client.get_order/3`
- `@binance_client.order_limit_sell/4`
- `Phoenix.PubSub.broadcast/3`

So the `Naive.Trader` relies on four modules:

- `Logger`
- `Phoenix.PubSub`
- `Naive.Leader`
- `@binance_client`(either `Binance` or `BinanceMock`)

We will need to work through them one by one.

### Mock the binance client

Let's start with the binance client, as it's already a dynamic value based on the configuration.

Neither the `Binance` nor the `BinanceMock`(our dummy implementation) module doesn't provide a behaviour - let's fix that by defining the `@callback` attributes at the top of the module before the structs:

```{r, engine = 'elixir', eval = FALSE}
# /apps/binance_mock/lib/binance_mock.ex
  ...
  alias Binance.Order
  alias Binance.OrderResponse
  alias Core.Struct.TradeEvent

  @type symbol :: binary
  @type quantity :: binary
  @type price :: binary
  @type time_in_force :: binary
  @type timestamp :: non_neg_integer
  @type order_id :: non_neg_integer
  @type orig_client_order_id :: binary
  @type recv_window :: binary

  @callback order_limit_buy(
    symbol,
    quantity,
    price,
    time_in_force
  ) :: {:ok, %OrderResponse{}} | {:error, term}

  @callback order_limit_sell(
    symbol,
    quantity,
    price,
    time_in_force
  ) :: {:ok, %OrderResponse{}} | {:error, term}

  @callback get_order(
    symbol,
    timestamp,
    order_id,
    orig_client_order_id | nil,
    recv_window | nil
  ) :: {:ok, %Order{}} | {:error, term}
```

In the above code, we added three `@callback` attributes that define the binance client behaviour. For clarity, we defined a distinct type for each of the arguments.

As we now have a binance client behaviour defined, we can use it to define a mock using the `Mox.defmock/2` function inside the `test_helper.exs` file of the `naive` application:

```{r, engine = 'elixir', eval = FALSE}
ExUnit.start()

Application.ensure_all_started(:mox) #1

Mox.defmock(Test.BinanceMock, for: BinanceMock) #2
```

First(#1), we need to ensure that the `mox` application has been started. Then(#2), we can define the mock based on the `BinanceMock` behaviour.

UPDATE CONFIG HERE

### Mock the naive leader

We can now move back to the `Naive.Trader` module to update all the hardcoded references to the `Naive.Leader` module with a dynamic attribute called `@leader` and add this attribute at the top of the module:

```{r, engine = 'elixir', eval = FALSE}
# /apps/naive/lib/trader.ex
  ...
  @leader Application.get_env(:naive, :leader)
  ...
  
```

Neither the `Binance` nor the `BinanceMock`(our dummy implementation) module doesn't provide a behaviour - let's fix that by defining the `@callback` attributes at the top of the module before the structs:

```{r, engine = 'elixir', eval = FALSE}
# /apps/binance_mock/lib/binance_mock.ex
  ...
  alias Binance.Order
  alias Binance.OrderResponse
  alias Core.Struct.TradeEvent

  @type symbol :: binary
  @type quantity :: binary
  @type price :: binary
  @type time_in_force :: binary
  @type timestamp :: non_neg_integer
  @type order_id :: non_neg_integer
  @type orig_client_order_id :: binary
  @type recv_window :: binary

  @callback order_limit_buy(
    symbol,
    quantity,
    price,
    time_in_force
  ) :: {:ok, %OrderResponse{}} | {:error, term}

  @callback order_limit_sell(
    symbol,
    quantity,
    price,
    time_in_force
  ) :: {:ok, %OrderResponse{}} | {:error, term}

  @callback get_order(
    symbol,
    timestamp,
    order_id,
    orig_client_order_id | nil,
    recv_window | nil
  ) :: {:ok, %Order{}} | {:error, term}
```

In the above code, we added three `@callback` attributes that define the binance client behaviour. For clarity, we defined a distinct type for each of the arguments.

As we now have a binance client behaviour defined, we can use it to define a mock using the `Mox.defmock/2` function inside the `test_helper.exs` file of the `naive` application:

```{r, engine = 'elixir', eval = FALSE}
ExUnit.start()

Application.ensure_all_started(:mox) #1

Mox.defmock(Test.BinanceMock, for: BinanceMock) #2
```

First(#1), we need to ensure that the `mox` application has been started. Then(#2), we can define the mock based on the `BinanceMock` behaviour.

UPDATE CONFIG HERE

[Note] Please remember to run the `mix format` to keep things nice and tidy.

Source code for this chapter can be found at [Github](https://github.com/frathon/create-a-cryptocurrency-trading-bot-in-elixir-source-code/tree/chapter_17)
